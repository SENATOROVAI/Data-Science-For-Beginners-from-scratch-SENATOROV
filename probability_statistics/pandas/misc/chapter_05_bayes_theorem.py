"""Bayes' theorem."""

# # Теорема Байеса

# Этот блокнот является частью [Bite Size Bayes](https://allendowney.github.io/BiteSizeBayes/), введения в вероятность и байесовскую статистику с использованием Python.
#
# Copyright 2020 Allen B. Downey
#
# License: [Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)](https://creativecommons.org/licenses/by-nc-sa/4.0/)

# Следующая ячейка загружает файл `utils.py`, содержащий некоторую полезную функцию, которая нам понадобится:

# +
from os.path import basename, exists
from urllib.request import urlretrieve

import pandas as pd
from pandas import Series


def download(url: str) -> None:
    """Загружает файл по URL, если его нет локально."""
    filename = basename(url)
    if not exists(filename):

        local, _ = urlretrieve(url, filename)
        print("Downloaded " + local)


download("https://github.com/AllenDowney/BiteSizeBayes/raw/master/utils.py")
# -

# Следующая ячейка загружает файл данных, который мы будем использовать в этом блокноте.

download("https://github.com/AllenDowney/BiteSizeBayes/raw/master/gss_bayes.csv")

# Если все, что нам нужно, установлено, следующая ячейка должна работать без сообщений об ошибках:

# ## Обзор
#
# [В предыдущем блокноте](https://dfedorov.spb.ru/pandas/downey/%D0%97%D0%B0%D0%BA%D0%BE%D0%BD%D1%8B%20%D0%B2%D0%B5%D1%80%D0%BE%D1%8F%D1%82%D0%BD%D0%BE%D1%81%D1%82%D0%B8.html) я определил *вероятность*, *конъюнкцию* и *условную вероятность* и использовал данные из GSS для вычисления вероятности различных логических утверждений.
#
# Для обзора, вот как мы загрузили набор данных:

gss = pd.read_csv("gss_bayes.csv", index_col=0)

# А вот и определенные нами логические утверждения, представленные с помощью логических серий (Boolean series):

banker = gss["indus10"] == 6870

female = gss["sex"] == 2

liberal = gss["polviews"] < 4

democrat = gss["partyid"] <= 1

# Я определил следующую функцию, которая использует `mean` для вычисления доли значений `True` в логической серии:

download("https://github.com/AllenDowney/BiteSizeBayes/raw/master/gss_bayes.csv")


# Я определил следующую функцию, которая использует `mean` для вычисления доли значений `True` в логической серии:

def prob(a_var: pd.Series) -> float:  # type: ignore
    """Compute the probability of a proposition, a_var.

    (a_var: Boolean series

    return: probability
    """
    assert isinstance(a_var, pd.Series)
    assert a_var.dtype == "bool"

    return a_var.mean()


# Итак, мы можем вычислить вероятность такого утверждения:

prob(female)

# Затем мы использовали оператор `&` для вычисления вероятности конъюнкции, например:

prob(female & banker)


# Затем я определил следующую функцию, которая использует оператор скобок для вычисления условной вероятности:

# +
# fmt: off

def conditional(
        proposition: Series[bool], 
        condition: Series[bool] 
) -> float:  
    """Conditional probability of proposition given condition.

    proposition: Boolean series
    condition: Boolean series

    return: probability
    """
    return prob(proposition[condition])

# fmt: on


# -

# Мы показали, что конъюнкция коммутативна, так что `prob(A & B)` равно `prob(B & A)` для любых логических утверждений `A` и `B`.
#
# Например:

prob(liberal & democrat)

prob(democrat & liberal)

# Но условная вероятность *НЕ* коммутативна, поэтому `conditional(A, B)` обычно не то же самое, что `conditional(B, A)`.
#
# Например, вот вероятность того, что респондент - женщина, учитывая, что это банкир.

conditional(female, banker)

# И вот вероятность того, что респондент - банкир, учитывая, что она женщина.

conditional(banker, female)

# Даже не близко.

# ## Другие утверждения
#
# Для разнообразия наших примеров давайте определим некоторые новые утверждения.
#
# Вот вероятность того, что случайный респондент - мужчина.

male = gss["sex"] == 1
prob(male)

# Отраслевой код для "Строительства" (Construction) - `770`. Назовем кого-нибудь из этой области "builder" (строителем).

builder = gss["indus10"] == 770
prob(builder)

# И давайте определимся с утверждениями для консерваторов и республиканцев:

conservative = gss["polviews"] > 4
prob(conservative)

republican = gss["partyid"].isin([5, 6])
prob(republican)

# Функция `isin` проверяет, находятся ли значения в заданной последовательности.
#
# В этом примере значения `5` и `6` представляют ответы "Сильный республиканец" (Strong Republican) и "Несильный республиканец" (Not Strong Republican).

# Наконец, я буду использовать `age` для определения утверждений для `young` (молодой) и `old` (пожилой).

young = gss["age"] < 30
prob(young)

old = gss["age"] >= 65
prob(old)

# Для этих порогов я выбрал круглые числа около 20-го и 80-го процентилей. В зависимости от вашего возраста вы можете соглашаться или не соглашаться с этими определениями `young` (молодой) и `old` (пожилой).

# **Упражнение №1:** Есть [известная цитата](https://quoteinvestigator.com/2014/02/24/heart-head/) о молодых людях, стариках, либералах и консерваторах, которая звучит примерно так:
#
# > Если в 25 вы не либерал, у вас нет сердца. Если в 35 лет вы не консерватор, у вас нет мозга.
#
# Независимо от того, согласны вы с этим утверждением или нет, оно предполагает некоторые вероятности, которые мы можем вычислить в качестве проверки.
#
# Используйте `prob` и `conditional` для вычисления этих вероятностей.
#
# * Какова вероятность того, что случайно выбранный респондент окажется молодым либералом?
#
# * Какова вероятность того, что молодой человек будет либералом?
#
# * Какая доля респондентов - пожилые консерваторы?
#
# * Какая часть консерваторов - люди старшего возраста?
#
# Для каждого утверждения подумайте, выражает ли оно конъюнкцию, условную вероятность или и то, и другое.
#
# А для условных вероятностей будьте осторожны с порядком!

# +
# 1. Вероятность того, что случайно выбранный респондент окажется молодым либералом
# Это конъюнкция
prob_young_liberal = prob(young & liberal)
print(f"Вероятность молодого либерала: {prob_young_liberal:.4f}")

# 2. Вероятность того, что молодой человек будет либералом
# Это условная вероятность
prob_liberal_given_young = conditional(liberal, young)
print(f"Вероятность либерала среди молодых: {prob_liberal_given_young:.4f}")

# 3. Доля респондентов - пожилые консерваторы
# Это конъюнкция
prob_old_conservative = prob(old & conservative)
print(f"Доля пожилых консерваторов: {prob_old_conservative:.4f}")

# 4. Доля консерваторов - люди старшего возраста
# Это условная вероятность
prob_old_given_conservative = conditional(old, conservative)
print(f"Доля пожилых среди консерваторов: {prob_old_given_conservative:.4f}")
# -

# Если ваш последний ответ больше 30%, значит, вы получили его наоборот!

# ## Вперед!
#
# В этом ноутбуке мы выведем три отношения между конъюнкцией и условной вероятностью:
#
# * **Теорема 1**. Использование конъюнкции для вычисления условной вероятности.
#
# * **Теорема 2**: Использование условной вероятности для вычисления конъюнкции.
#
# * **Теорема 3**: Использование `conditional(A, B)` для вычисления `conditional(B, A)`.
#
# Теорема 3 также известна как *теорема Байеса*, которая является основой байесовской статистики.
#
# В некоторых частях этого блокнота будет полезно использовать математические обозначения вероятностей, поэтому я представлю их сейчас.
#
# * $P(A)$ - это вероятность утверждения $A$.
#
# * $P(A~\mathrm{and}~B)$ - это вероятность конъюнкции $A$ и $B$, то есть вероятность того, что оба утверждения верны.
#
# * $P(A | B)$ - это условная вероятность $A$ при условии, что $B$ истинно. Вертикальная линия между $A$ и $B$ произносится как "дано".
#
# Теперь мы готовы к Теореме 1.

# ## Теорема 1
#
# Какая часть строителей - мужчины? Мы уже видели один способ вычислить ответ:
#
# 1. с помощью оператора скобок выберите строителей, затем
#
# 2. используйте `mean`, чтобы вычислить долю строителей мужского пола.
#
# Мы можем записать эти шаги так:

male[builder].mean()

# Или мы можем использовать функцию `conditional`, которая делает то же самое:

conditional(male, builder)  # type: ignore[unreachable]

# Но есть другой способ: чтобы вычислить долю строителей-мужчин, мы можем вычислить отношение двух вероятностей:
#
# 1. долю респондентов строителей-мужчин и
#
# 2. долю респондентов строителей.
#
# Вот как это выглядит:

print(prob(male & builder) / prob(builder))

# Результат тот же.
#
# Этот пример демонстрирует *общее правило, которое связывает условную вероятность и конъюнкцию*.
#
# Вот как это выглядит в математической записи:
#
# $P(A|B) = \frac{P(A~\mathrm{and}~B)}{P(B)}$
#
# И это Теорема 1.
#
# В этом примере:
#
# `conditional(male, builder) = prob(male & builder) / prob(builder)`

# **Упражнение №2:** Какая часть консерваторов - республиканцы? Вычислите ответ двумя способами:
#
# * используйте функцию `conditional` (которая использует оператор скобки) и
#
# * используйте Теорему 1.
#
# Подтвердите, что вы получили такой же ответ.
#
# *Примечание*: из-за арифметики с плавающей запятой результаты могут не совпадать, но почти все цифры должны совпадать.

# +
# Способ 1: используя функцию conditional
result1 = conditional(republican, conservative)
print(f"Способ 1: {result1:.6f}")

# Способ 2: используя Теорему 1
result2 = prob(republican & conservative) / prob(conservative)
print(f"Способ 2: {result2:.6f}")

print(f"Результаты совпадают: {abs(result1 - result2) < 1e-10}")
# -

# ## Доказательство?
#
# На самом деле я не доказал Теорему 1; в основном, это утверждение о том, что означает условная вероятность.
#
# Например, рассмотрим эту диаграмму Венна:
#
# <img width="200" src="https://github.com/AllenDowney/BiteSizeBayes/raw/master/theorem1_venn_diagram.png">
#
# Синий кружок представляет респондентов-мужчин. Красный кружок представляет строителей. На пересечении изображены мужчины-строители.
#
# Чтобы вычислить долю мужчин-строителей, мы можем вычислить отношение пересечения, которое представляет собой `prob(male & builder)`, к красному кружку, то есть `prob(builder)`.

# **Упражнение №3:** Для практики вычислите долю пожилых банкиров двумя способами: используя функцию `conditional` и Теорему 1.

# +
# Способ 1: используя функцию conditional
result1 = conditional(old, banker)
print(f"Способ 1: {result1:.6f}")

# Способ 2: используя Теорему 1
result2 = prob(old & banker) / prob(banker)
print(f"Способ 2: {result2:.6f}")

print(f"Результаты совпадают: {abs(result1 - result2) < 1e-10}")
# -

# ## Теорема 2
#
# Снова Теорема 1:
#
# $P(A|B) = \frac{P(A~\mathrm{and}~B)}{P(B)}$
#
# Если умножить обе части на $P(B)$, получим Теорему 2.
#
# $P(A~\mathrm{and}~B) = P(B) P(A|B)$
#
# Эта формула предлагает второй способ вычисления конъюнкции: вместо использования оператора `&` мы можем вычислить произведение двух вероятностей.
#
# Посмотрим, сработает ли это для `conservative` (консерваторов) и `republican` (республиканцев).
#
# Вот результат с использованием `&`:

prob(conservative & republican)

# И вот результат использования Теоремы 2:

print(prob(republican) * conditional(conservative, republican))

# Из-за ошибок с плавающей запятой они могут не совпадать, но почти все цифры одинаковы.

# **Упражнение №4:** Проверьте Теорему 2 еще раз, вычислив долю респондентов, которые являются пожилыми либералами двумя способами:
#
# * с использованием оператора `&`, и
#
# * используя Теорему 2.
#
# Результаты должны быть такими же или, по крайней мере, очень близкими.

# +
# Способ 1: используя оператор &
result1 = prob(old & liberal)
print(f"Способ 1: {result1:.6f}")

# Способ 2: используя Теорему 2
result2 = prob(old) * conditional(liberal, old)
print(f"Способ 2: {result2:.6f}")

print(f"Результаты совпадают: {abs(result1 - result2) < 1e-10}")
# -

# ## Конъюнкция коммутативна
#
# Мы уже установили, что конъюнкция коммутативна. В математической записи это означает:
#
# $P(A~\mathrm{and}~B) = P(B~\mathrm{and}~A)$
#
# Если применить Теорему 2 к обеим сторонам, мы имеем
#
# $P(B) P(A|B) = P(A) P(B|A)$
#
# Вот один способ интерпретировать это: если вы хотите проверить $A$ и $B$, вы можете сделать это в любом порядке:
#
# 1. вы можете сначала проверить $B$, затем $A$ при условии, что $B$, или
#
# 2. вы можете сначала проверить $A$, затем $B$ при условии, что $A$.
#
# Чтобы попробовать, я вычислю долю молодых строителей двумя способами:

print(prob(young) * conditional(builder, young))

print(prob(builder) * conditional(young, builder))

# То же самое!

# **Упражнение №5:** Рассчитайте вероятность быть мужчиной-банкиром двумя способами и посмотрите, получите ли вы то же самое.

# +
# Способ 1: P(male) * P(banker|male)
result1 = prob(male) * conditional(banker, male)
print(f"Способ 1: {result1:.6f}")

# Способ 2: P(banker) * P(male|banker)
result2 = prob(banker) * conditional(male, banker)
print(f"Способ 2: {result2:.6f}")

# Проверка через прямое вычисление
result3 = prob(male & banker)
print(f"Прямое вычисление: {result3:.6f}")

print(
    "Все результаты совпадают: "
    f"{abs(result1 - result2) < 1e-10 and abs(result1 - result3) < 1e-10}"
)
# -

# ## Теорема 3
#
# В предыдущем разделе мы установили, что
#
# $P(B) P(A|B) = P(A) P(B|A)$
#
# Если разделить на $P(B)$, получим Теорему 3:
#
# $P(A|B) = \frac{P(A) P(B|A)}{P(B)}$
#
# И это, друзья мои, **теорема Байеса**.
#
# Чтобы увидеть, как это работает, попробуем еще одну комбинацию наших утверждений.
#
# Давайте вычислим долю либеральных строителей, сначала используя функцию `conditional`:

conditional(liberal, builder)

# Теперь, используя теорему Байеса:

print(prob(liberal) * conditional(builder, liberal) / prob(builder))

# То же самое!

# **Упражнение №6:** Попробуйте сами! Вычислите долю молодых людей, которые являются республиканцами, двумя способами: используя функцию `conditional` и теорему Байеса. Посмотрите, получите ли вы то же самое.

conditional(republican, young)

print(prob(republican) * conditional(young, republican) / prob(young))

# ## Резюме
#
# Вот что у нас есть на данный момент:
#
# **Теорема 1** дает нам новый способ вычисления условной вероятности с помощью конъюнкции:
#
# $P(A|B) = \frac{P(A~\mathrm{and}~B)}{P(B)}$
#
# **Теорема 2** дает нам новый способ вычисления конъюнкции с использованием условной вероятности:
#
# $P(A~\mathrm{and}~B) = P(B) P(A|B)$
#
# **Теорема 3**, также известная как теорема Байеса, дает нам способ перейти от $P(A|B)$ к $P(B|A)$ или наоборот:
#
# $P(A|B) = \frac{P(A) P(B|A)}{P(B)}$
#
# Но тут вы можете спросить: "И что?" Если у нас есть все данные, мы можем вычислить любую желаемую вероятность, любую конъюнкцию или любую условную вероятность, просто подсчитав. Зачем нужны эти формулы?
#
# И вы правы, *если* у нас есть все данные. Но часто мы этого не делаем, и в этом случае эти формулы могут быть очень полезны - особенно теорема Байеса.
#
# В [следующем блокноте](https://colab.research.google.com/github/dm-fedorov/pandas_basic/blob/master/быстрое%20введение%20в%20pandas/Проблема%20с%20печеньками.ipynb) мы увидим, как это сделать.
