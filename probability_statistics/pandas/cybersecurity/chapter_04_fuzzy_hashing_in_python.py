"""Fuzzy hashing in Python."""

# # Нечеткое хеширование на Python

# Сравнение подозрительного файла с ранее проанализированными образцами или образцами, хранящимися в публичном либо частном хранилище, может дать представление о семействе вредоносных программ, их характеристиках и сходстве с предварительно проанализированными образцами.
#
# Хотя криптографические хеш-функции (MD5/SHA1/SHA256) являются отличным методом для обнаружения идентичных образцов, они не помогают в идентификации схожих образцов. Очень часто авторы вредоносных программ меняют мелкие аспекты вредоносных программ, что полностью меняет значение хеш-функции.

# Нечеткое хеширование – отличный способ сравнить файлы на схожесть.
#
# [Ssdeep](https://ssdeep-project.github.io/ssdeep/) – полезный инструмент для создания нечеткого хеша для образца, и он также помогает в определении процентного сходства между
# образцами. Этот метод полезен при сравнении подозрительного файла с образцами из хранилища для идентификации похожих. Это может помочь определить образцы, принадлежащие к одному семейству вредоносных программ или к одной и той же группе субъектов.

# Исходные файлы для блокнота находятся по [ссылке](https://github.com/dm-fedorov/infosec/tree/master/re-tools/samples).

# Скачиваем весь архив с файлами для работы в Colab:

# !wget https://dfedorov.spb.ru/infosec/re/samples.zip

# !unzip samples.zip

# !apt-get -y install libfuzzy-dev

# !apt-get install ssdeep

# !pip install ssdeep

# Чтобы определить нечеткий хеш образца, выполните следующую команду:

# !ssdeep samples/test

# Чтобы продемонстрировать использование нечеткого хеширования, рассмотрим в качестве примера директорию, состоящую из трех образцов вредоносного ПО.
#
# В следующем фрагменте кода видно, что все три файла имеют совершенно разные значения хеш-функций MD5:

# !ls samples

# !md5sum samples/*

# Режим *изящного сравнения* (опция ```-p```) в ```ssdeep``` может использоваться для определения процентного сходства. Из трех образцов два имеют сходство 93%, что предполагает, что они, вероятно, принадлежат к одному и тому же семейству вредоносных программ:

# !ssdeep -pb samples/test_01 samples/test_02 samples/test_03

# Как показано в предыдущем примере, криптографические хеш-функции не помогли установить связь между образцами, тогда как метод нечеткого хеширования выявил сходство.
#
# Можно запустить ```ssdeep``` для каталогов и подкаталогов, содержащих вредоносные образцы, используя рекурсивный режим (```-r```):

# !ssdeep -lrpa samples/

# В следующем примере ssdeep-хеши всех файлов были перенаправлены в текстовый файл (```all_hashes.txt```), а затем подозрительный файл (```test_03```) сопоставляется со всеми хешами в файле:

# !ssdeep samples/test_01 samples/test_02 samples/test_03 > samples/all_hashes.txt

# !cat samples/all_hashes.txt

# В следующем фрагменте кода видно, что подозрительный файл (```test_03```) идентичен ```test_03``` (соответствие – 100%) и имеет сходство 93% с ```test_02```. Можно использовать этот метод для сравнения любого нового файла с хешами ранее проанализированных образцов:

# !ssdeep -m samples/all_hashes.txt samples/test_03

# В Python нечеткий хеш может быть вычислен с использованием ```python-ssdeep```:

# !pip3 install ssdeep

import ssdeep
hash1 = ssdeep.hash_from_file('samples/test_03')
print(hash1)

hash2 = ssdeep.hash_from_file('samples/test_02')
print(hash2)

ssdeep.compare(hash1, hash2)
