# ## Функции в Питоне

# ### Встроенные функции

# In[ ]:


# импортируем библиотеки
import matplotlib.pyplot as plt

# перед вызовом функции нужно не забыть импортировать соответствующую
# библиотеку
import numpy as np

# установим точку отсчета
np.random.seed(42)
# и снова сгенерируем данные о росте (как мы делали на восьмом занятии
# вводного курса)
height = list(np.round(np.random.normal(180, 10, 1000)))

# #### Параметры и аргументы функции

# In[ ]:


# теперь построим гистограмму передав ей два параметра, данные о росте и количество интервалов
# первый параметр у нас позиционный, второй - именованный
plt.hist(height, bins=10)
plt.show()

# In[ ]:


# первый параметр можно также сделать именованным (данные обозначаются через x)
# и тогда порядок параметров можно менять
plt.hist(bins=10, x=height)
plt.show()

# In[ ]:


# у параметра bins есть аргумент по умолчанию (как раз 10 интервалов),
# а значит, этот параметр можно не указывать
plt.hist(height)
plt.show()

# In[ ]:


# функция может не принимать параметров
print("Первая строка")
print()
print("Третья строка")

# #### Функции и методы

# In[ ]:


# дана строка
some_string = "machine learning"

# применим метод .title()
some_string.title()

# In[ ]:


# к списку
some_list = ["machine", "learning"]

# этот метод не применить
some_list.title()

# ### Собственные функции в Питоне

# #### Объявление и вызов функции

# In[ ]:


# создадим функцию, которая удваивает любое передаваемое ей значение
def double(x):
    res = x * 2
    return res


# In[ ]:


# и вызовем ее, передав число 2
double(2)

# #### Пустое тело функции

# In[ ]:


# тело функции не может быть пустым
def only_return():

    # нужно либо указать ключевое слово return
    return


# In[ ]:


only_return()

# In[ ]:


# либо оператор pass
def only_pass():
    pass


# In[ ]:


only_pass()

# In[ ]:


# такая функция вернет тип данных None (отсутствие значения)
print(only_return())

# #### Функция print() вместо return

# In[ ]:


# можно использовать print(), но есть нюансы (см. на странице урока)
def double_print(x):
    res = x * 2
    print(res)


# In[ ]:


double_print(5)

# #### Параметры собственных функций

# In[ ]:


# объявим функцию с параметрами x и y
def calc_sum(x, y):

    # и выведем их сумму
    return x + y


# In[ ]:


# вызовем эту функцию с одним позиционным и одним именованным параметром
calc_sum(1, y=2)

# In[ ]:


# параметрам функции можно задать аргументы по умолчанию
def calc_sum_default(x=1, y=2):
    return x + y


# и при вызове тогда их указывать не обязательно
calc_sum_default()

# In[ ]:


# функция может не иметь параметров
def print_string():
    print("Some string")


print_string()

# #### Аннотация функции

# In[ ]:


# укажем, что на входе функция принимает тип float, а возвращает int
# значение 3,5 - это значение параметра x по умолчанию
def f(x: float = 3.5) -> int:
    return int(x)


# In[ ]:


# желаемый тип данных можно посмотреть через атрибут __annotations__
f.__annotations__

# In[ ]:


# вызовем функцию без параметров
f()

# In[ ]:


# сохраним аннотации, но изменим суть функции
def f(x: float) -> int:
    # теперь вместо int она будет возвращать float
    return float(x)


# In[ ]:


# вновь вызовем функцию, передав ей на входе int, и ожидая на выходе
# получить float
f(3)

# #### Дополнительные возможности

# In[ ]:


# вызов функции можно совмещать с арифметическими
calc_sum(1, 2) * 2

# In[ ]:


# и логическими операциями
calc_sum(1, 2) > 2

# In[ ]:


# можно и так
def first_letter():
    return "Python"


first_letter()[0]

# In[ ]:


# функция может не принимать параметров, но использовать input()
def use_input():

    # запросим у пользователя число и переведем его в тип данных int
    user_inp = int(input("Введите число: "))

    # возведем число в квадрат
    result = user_inp**2

    # вернем результат
    return result


# вызовем функцию
use_input()

# #### Результат вызова функции

# In[ ]:


# функция может возвращать также список, кортеж, словарь и др.


# объявим функцию, которая на входе получает число,
# а на выходе формирует список чисел от 0 и до числа, предшествующего заданному
def create_list(x):

    # создадим пустой список
    result = []

    # в цикле for создадим последовательность
    for i in range(x):

        # и поместим ее в список
        result.append(i)

    return result


# результатом вызова этой функции будет список
create_list(5)

# In[ ]:


# функция может возвращать сразу два значения
def tuple_f():
    string = "Python"
    x = 42
    return string, x


# In[ ]:


# если использовать две переменные
a, b = tuple_f()

# на выходе мы получим строку и число
print(a, b)
print(type(a), type(b))

# In[ ]:


# если одну
c = tuple_f()

# получится кортеж
print(c)
print(type(c))

# In[ ]:


# выводом может быть логическое значение (True или False)
def if_divisible(x):

    # если остаток от деления на два равен нулю
    if x % 2 == 0:

        # вернем True
        return True

    else:

        # в противном случае False
        return False


if_divisible(10)

# #### Использование библиотек

# In[ ]:


# применим функцию mean() библиотеки Numpy для расчета среднего арифметического


# на входе наша функция примет список или массив x,
def mean_f(x):

    # рассчитает среднее арифметическое и прибавит единицу
    return np.mean(x) + 1


# In[ ]:


# и подготовить данные
x = [1, 2, 3]

mean_f(x)

# #### Глобальные и локальные переменные

# In[ ]:


# создадим глобальную переменную вне функции
global_name = "Петр"


# а затем используем ее внутри новой функции
def show_name():
    print(global_name)


# In[ ]:


show_name()

# In[ ]:


# а теперь вначале создадим функцию,
# внутри которой объявим локальную переменную
def show_local_name():
    local_name = "Алена"
    print(local_name)


# In[ ]:


show_local_name()

# In[ ]:


# при попытке обратиться к переменной вне функции мы получим ошибку
local_name

# In[ ]:


# превратить локальную переменную в глобальную можно через ключевое слово
# global
def make_global():
    global local_name
    local_name = "Алена"
    print(local_name)


# In[ ]:


make_global()

# In[ ]:


# теперь ошибки быть не должно
local_name

# In[ ]:


# объявим глобальную переменную
global_number = 5


def print_number():
    # затем объявим локальную переменную
    local_number = 10
    print("Local number:", local_number)


# In[ ]:


# функция всегда "предпочтет" локальную переменную
print_number()

# In[ ]:


# при этом значение глобальной переменной для остального кода не изменится
print("Global number:", global_number)

# ### Lambda-функции

# In[ ]:


# создадим функцию, которая принимает два числа и перемножает их
def lf(a, b):
    return a * b


# вызовем функцию и передадим ей числа 2 и 3
lf(2, 3)

# In[ ]:


# этот же функционал можно поместить в обычную функцию
def normal_f(a, b):
    return a * b


normal_f(2, 3)

# #### Lambda-функция внутри функции filter()

# In[ ]:


# создадим список
nums = [15, 27, 9, 18, 3, 1, 4]

# напишем lambda-функцию, которая выведет True, если число больше 10, и
# False, если меньше


def criterion(n):
    return True if (n > 10) else False


# поместим список и lambda-функцию в функцию filter() и преобразуем
# результат в список
list(filter(criterion, nums))

# In[ ]:


# все это можно записать в одну строчку
list(filter(lambda n: True if (n > 10) else False, nums))

# In[ ]:


# ту же задачу можно решить через обычную функцию,
# но придется написать больше кода
def criterion_2(n):
    if n > 10:
        return True
    else:
        return False


list(filter(criterion_2, nums))

# #### Lambda-функция внутри функции sorted()

# In[ ]:


# напомню, что мы создали список из кортежей,
# и в каждом кортеже был индекс фильма и расстояние до него
indices_distances = [
    (901, 0.0),
    (1002, 0.22982440568634488),
    (442, 0.25401128310081567),
]

# lambda-функция возьмет каждый кортеж и вернет второй [1] его элемент
# передав эту функцию через параметр key, мы отсортируем список по расстоянию
sorted(indices_distances, key=lambda x: x[1], reverse=False)

# #### Немедленно вызываемые функции

# In[ ]:


# lambda-функцию можно вызвать сразу в момент объявления
(lambda x: x * x)(10)

# ### \*args и \**kwargs

# #### \*args

# In[ ]:


# напишем функцию для расчета среднего арифметического двух чисел
def mean(a, b):
    return (a + b) / 2


# In[ ]:


mean(1, 2)

# In[ ]:


# объявим функцию, которой нужно передать список
def mean(list_):

    # зададим переменную для суммы,
    total = 0

    # в цикле сложим все числа из списка
    for i in list_:
        total += i

    # и разделим на количество элементов
    return total / len(list_)


# In[ ]:


# создадим список
list_ = [1, 2, 3, 4]

# и передадим его в новую функцию
mean(list_)

# In[ ]:


# однако новая функция уже не может работать с отдельными числами
mean(1, 2)

# In[ ]:


# объявим функцию с *args
def mean(*nums):

    # в данном случае мы складываем элементы кортежа
    total = 0
    for i in nums:
        total += i

    return total / len(nums)


# In[ ]:


# теперь мы можем передать функции отдельные числа
mean(1, 2, 3, 4)

# In[ ]:


# или список
mean(*list_)

# In[ ]:


# убедимся, что оператор распаковки * формирует кортеж
def test_type(*nums):
    print(nums, type(nums))


test_type(1, 2, 3, 4)

# In[ ]:


# со списком происходит то же самое
test_type(*list_)

# In[ ]:


# для наглядности приведем еще один пример
a = [1, 2, 3]
b = [*a, 4, 5, 6]

print(b)

# #### \**kwargs

# In[ ]:


# **kwargs преобразует именованные параметры в словарь
def f(**kwargs):
    return kwargs.items()


# In[ ]:


f(a=1, b=2)

# In[ ]:


# *nums превращается в кортеж, **params - в словарь
def simple_stats(*nums, **params):

    # если ключ 'mean' есть в словаре params и его значение == True
    if "mean" in params and params["mean"]:

        # рассчитаем среднее арифметическое и округлим
        # \t - это символ табуляции
        print(f"mean: \t{np.round(np.mean(nums), 3)}")

    # если ключ 'std' есть в словаре params и его значение == True
    if "std" in params and params["std"]:

        # рассчитаем СКО и округлим
        print(f"std: \t{np.round(np.std(nums), 3)}")


# In[ ]:


# вызовем функцию simple_stats() и передадим ей числа и именованные аргументы
simple_stats(5, 10, 15, 20, mean=True, std=True)

# In[ ]:


# если для одного из параметров задать значение False,
# функция не выведет соответствующую метрику
simple_stats(5, 10, 15, 20, mean=True, std=False)

# In[ ]:


# если мы хотим передать параметры списком и словарем,
list_ = [5, 10, 15, 20]
settings = {"mean": True, "std": True}

# то нам нужно использовать операторы распаковки * и ** соответственно
simple_stats(*list_, **settings)

# In[ ]:


# ничто не мешает нам добавить еще один параметр
simple_stats(5, 10, 15, 20, mean=True, std=True, median=True)

# In[ ]:
