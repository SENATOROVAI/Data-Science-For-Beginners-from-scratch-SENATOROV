"""OOP."""

# Код никогда не бывает на 100% процедурным, даже когда мы сами не создаем классы, а используем библиотеки, по сути мы просто импортируем уже готовые. Каждый объект получает данные извне и отдает нам результат работы обратно. Например:

# +
import requests

response = requests.get("https://www.google.ru")  # запрос к серверу Google
type(response)
# -

# Программа абсолютно процедурна, однако даже тут, фукнция `get` возвращает нам именно **класс** созданный в самой библиотеке, атрибутами и методами которого мы пользуемся:

dir(response)


# С помощью этих методов и атрибутов класса мы можем получать различный требуемый результат. При этом, если автор поменяет функциональность внутри методов или значения атрибутов, это никак не скажется на мне, на конечном пользователе, моя программа на моём уровне не изменится. Это колоссально упрощает повторное использование кода и его изменения.

# Создание класса:


class Person:  # название в СamelCase
    """Класс человека."""

    name: str = "Ivan"


# Доступ к св-вам класса получаем с помощью точки (dot-notation):

Person.name  # возвращается значение атрибута name

# На самом деле в Python всё является объектом (ещё одним самым основным классом): типы данных, функции и даже сами классы. Например, он имеет атрибут имени:

print(
    Person.__name__
)  # магические методы и св-ва имеют двойное подчеркивание в начале и в конце

# Он содержит строку с названием класса. Чтобы посмотреть все атрибуты можно воспользоваться функцией `dir`:

dir(Person)

# Также можно узнать класс самого класса:

Person.__class__

# **type** означает, что класс - созданный пользователем новый тип данных. Чтобы создать реализацию класса, его экземпляр, нужно вызвать класс. Вызов класса со скобками создает объект его экземпляра:

person_instance = Person()
print(person_instance.__class__)
print(person_instance.__class__.__name__)

# Теперь магический атрибут `__class__` показывает, что это экземпляр конкретного класса Person. Тут можно понять, что на самом деле делает функция `type`, она просто вызывает для передаваемого объекта магический метод `__class__` (А функция `dir` - `__dir__`). Мы даже можем с помощью `type` создавать новые экземпляры, так как она возвращает сам класс:

new_person = type(person_instance)()
new_person

# При этом, это разные экземпляры, что можно проверить по адресам экземпляров:

print(id(person_instance))
print(id(new_person))


# Определение св-в классов делается через присваивание переменным некоторого значения, но они должны быть объявлены внутри класса:


class Person1:
    """Класс человека."""

    name: str = "Ivan"
    age: int
    dob: str


dir(Person1)

# Состояние объектов класса храниться внутри магического атрибута `__dict__`:

Person1.__dict__

# `__dict__` - и есть пространство имён классов и их экземпляров. <br>
# P.S. `mappingproxy` - read-only словарь.

# Изменение подобным образом выведет ошибку:
# ```python
# Person.__dict__["name"] = "asdfdsf"
# ```

# Чтобы влиять на значение атрибута в `__dict__`, нужно использовать либо dot-нотацию, либо одну из функций:
# - `getattr()` - получение атрибута;
# - `setattr()` - задание значения атрибута;
# - `delattr()` - удаление атрибута.

# получение с помощью dot-нотации
Person1.name

# создание с помощью dot-нотации
Person1.age = 232323
Person1.__dict__

# чтение значения
getattr(Person1, "name")

# запись значения
setattr(Person1, "dob", "123")
Person1.__dict__

# удаление атрибута
delattr(Person1, "dob")
Person1.__dict__


# Эти функции полезны, когда имя атрибута прилетает откуда-то извне (не знаем заранее, чтобы использовать dot-нотацию) и мы получаем его в виде строки.

# Точно также мы можем объявлять и функции:


# +
class Person2:
    """Класс человека."""

    name: str = "Ivan"

    @staticmethod
    def hello() -> None:
        """Вывод приветствия."""
        print("Hello")


Person2.hello()
# -

Person2.__dict__


# Тут hello - это именно ФУНКЦИЯ (не метод).

# Классы это callable-объекты, как, например, функции. Когда мы создаем класс с помощью ключевого слова `class`, Python автоматически добавляет к нему некоторые св-ва и поведение:


# +
class Person3:
    """Класс человека."""

    name: str = "Ivan"
    age: int


dir(Person3.__class__)
# -

# Например, св-ва `__doc__`, `__dict__` и метод `__call__`, который и делает все классы callable-объектами.

# Если класс - вызываемый объект, то по аналогии с функциями, которые тоже callable, какое значение он возвращает?

p1 = Person3()
p1

# Ответ: объект экземпляра класса Person.

# Экземпляры это копии основного класса с разными значениями св-в, например: люди с разным весом и ростом. Св-ва основного класса глобальны для всех экземпляров:

p1.name

# Создадим ещё один экземпляр:

p2 = Person3()
print(id(p2) == id(p1))

print(p2.__dict__)
print(p1.__dict__)

print(id(p1.name) == id(p2.name) == id(Person3.name))

# Как можно заметить, экземпляры не имеют атрибута `name`, поэтому при обращении с помощью dot-нотации, после того, как в пространстве имен экземпляров атрибут не обнаруживается, его поиск переходит на пространство имен класса, где он и присутствует. Поэтому id везде равны.

# Св-ва конкретно класса, как бы создают значения и поведение по умолчанию. Но у каждого экземпляра всё это может отличаться. Поэтому у каждого экземпляра своё пространство имен, которое не зависит от пространств имен других экземпляров:

p1.age = 99
p1.__dict__

p2.__dict__

# Также можно переопределить значение св-ва `name` в каждом экземпляре, тогда оно появится в пространствах имен экземпляров:

p1.name = "Oleg"
p2.name = "Yura"

print(p1.__dict__)
print(p2.__dict__)

# При этом значение св-ва `name` у самого класса останется неизменным, и не появится атрибут `age`:

Person3.__dict__

# Тут можно отметить ещё одно отличие, магический атрибут `__dict__` не имеет тип `mappingproxy`, а значит может быть изменён напрямую:

p1.__dict__["age"] = 1
p1.age

# Если в пространстве имён экземпляров нет, родительского атрибута, то изменение его значения в пространстве имён класса, приведёт к тому, что при обращении через экземпляры, значение св-ва также будет новым:

p3 = Person3()
p4 = Person3()
print(p3.name, p4.name)

Person3.name = "Vladimir"
print(p3.name, p4.name)


# Функции по своему поведению отличаются от методов, например:


# +
class Person4:
    """Класс человека."""

    @staticmethod
    def hello() -> None:
        """Вывод приветствия."""
        print("Hello")


print(Person4.hello)
print(type(Person4.hello))
# -

# Сейчас это просто функция, но после создания экземпляра класса это будет уже метод:

person_instance0 = Person4()
print(person_instance0.hello)
print(type(person_instance0.hello))

# Разница заключается в связывании. При вызове метода от экземпляра в качестве аргумента в функцию будет передан объект экземпляра (`self`) и из-за этого появится ошибка, так как функцией не предусмотрены аргументы:

# ```python
# person_instance.hello()
# ```

# Но если вызвать функцию от класса, то ошибки не будет, так как связывание не происходит и дополнительных параметров не передаётся:

Person4.hello()

# Функция при вызове от класса и функция при вызове от экземпляра класса - разные функции:

print(id(Person4.hello) != id(person_instance0.hello))

# Также у них будут разные атрибуты:

len(dir(person_instance0.hello))

len(dir(Person4.hello))

# Связывание нужно для корректного использования пространства имен, чтобы функция могла обращаться к атрибутам и методам конкретного экземпляра, в котором она вызвана.

# Например, при обработки строк методом `split` с помощью связывания функция и понимает над какой строкой производить операцию:
"person-dima".split("-")

# То есть метод связывает функцию класса и экземпляр класса, где функция вызвана. Происходит это с помощью автоматически передаваемого св-ва (атрибута) `self`:

getattr(person_instance0.hello, "__self__")

# Он указывает на id экземпляра в шестнадцатиричной форме:

hex(id(person_instance0))

# А св-во `__func__` хранит функцию класса:

getattr(person_instance0.hello, "__func__")


# То есть под капотом метода находится функция класса:

# ```python
# person_instance.hello.__func__(person_instance.hello.__self__)
# ```

# Поэтому важно предусматривать неявный дополнительный аргумент `self`, при вызове функций класса из его экземпляров:


# +
class Person5:
    """Класс человека."""

    def hello(self) -> None:
        """Вывод экземпляра."""
        print(self)


person_instance1 = Person5()
person_instance1.hello()


# -

# Магический метод `init` вызывается автоматически при создании экземпляра класса, например:


class Person6:
    """Класс человека."""

    def __init__(self, name: str) -> None:
        """Объявление экземпляра."""
        self.name = name

    def display(self) -> None:
        """Вывод имени экземпляра."""
        print(self.name)


person_instance2 = Person6("Oleg")
person_instance2.name

person_instance2.__dict__

# Создание экземпляра класса происходит с помощью поочерёдного выполнения двух магических функций:
# - `__new__` (конструктор класса)
# - `__init__` (инициализирующей метод, для присвоения значений св-в)
