"""Функции. Области видимости.Передача параметров в функции.

вы научитесь создавать собственные функции, передавать в них параметры и возвращать
значения. Разберётесь, как устроены локальные и глобальные переменные и как избежать
ошибок при работе с областями видимости. Вы узнаете, как устроены локальные и глобальные
переменные — и почему с глобальными нужно быть осторожными.
"""

# pylint: disable=unused-import

# ## Функциональное приветствие.
#
# - Когда программа запускается, она может обращаться к пользователю по имени — это просто и приятно.
# - Научимся писать функцию, которая выводит приветствие в нужном формате.
# - Напишите функцию print_hello(name), которая принимает имя и выводит строку приветствия: Hello, <имя>!
# - Не добавляйте вызовов функции вне её тела — программа будет использоваться как библиотека.
# - Примечание
# - Ваше решение должно содержать только функции.
# - В решении не должно быть вызовов требуемых функций. Для форматирования строки используйте f-строку.

# +
from typing import ClassVar, List, Literal, TypeVar, Union


def print_hello(name: str) -> None:
    """Приветствует пользователя по имени."""
    print(f"Hello, {name}!")


# -

# ## Функциональный НОД.
#
# - Программы часто используют математические функции — например, чтобы упростить дробь или найти общий множитель.
# - Одной из таких базовых функций является НОД — наибольший общий делитель двух чисел.
# - Напишите функцию gcd, которая принимает два натуральных числа и возвращает их наибольший общий делитель.
# - Примечание
# - Ваше решение должно содержать только функции.
# - В решении не должно быть вызовов требуемых функций.


def gcd(a_gcd: int, b_gcd: int) -> int:
    """Вычисляет наибольший общий делитель двух чисел."""
    while b_gcd != 0:
        a_gcd, b_gcd = b_gcd, a_gcd % b_gcd
    return a_gcd


# ## Длина числа.
#
# - Иногда в программе нужно узнать, сколько цифр содержит число.
# - Например, чтобы проверить длину пароля, номера телефона или банковского счёта.
# - Разработайте функцию number_length, которая принимает одно целое число и возвращает его длину без учёта знака.
# - Примечание
# - Ваше решение должно содержать только функции.
# - В решении не должно быть вызовов требуемых функций.


def number_length(number_len: int) -> int:
    """Возвращает количество цифр в числе."""
    number_len = abs(number_len)
    number_len = len(str(number_len))
    return number_len


# ## Копейка рубль бережёт.
#
# - Программа может обрабатывать любые данные — даже содержимое кошелька.
# - Представьте, что у вас есть список купюр и монет. Нужно выбрать из него только мелочь — всё, что меньше 100 рублей.
# - Напишите функцию take_small(money), которая принимает список номиналов и возвращает новый список — только с теми значениями, которые меньше 100. Порядок элементов должен сохраниться.
# - Примечание
# - Исходный список должен остаться без изменений.
# - В решении не должно быть вызовов требуемых функций.


def take_small(money_small: list[int]) -> list[int]:
    """Возвращает список значений меньше 100."""
    result_small = []
    for i_small in money_small:
        if i_small < 100:
            result_small.append(i_small)
    return result_small


# ## Виртуальный кликер.
#
# - Допустим, вы создаёте онлайн-кликер — игру, где каждое нажатие увеличивает счёт.
# - Реализуем основу такой игры на Python.
# - Создайте две функции:
# - click() — увеличивает значение счётчика на 1;
# - get_count() — возвращает текущее значение счётчика.
# - Примечание
# - В решении не должно быть вызовов функций.


class Counter:
    """Счетчик кликов."""

    __count: ClassVar[int] = 0

    @classmethod
    def click(cls) -> None:
        """Увеличивает счетчик на 1."""
        cls.__count += 1

    @classmethod
    def get_count(cls) -> int:
        """Возвращает текущее значение счетчика."""
        return cls.__count


# ## Странная игра.
#
# - Позади уже первая пятёрка задач — вы отлично справляетесь!
# - Пора потренироваться с изменяемыми переменными и логикой принятия решений.
# - Петя и Ваня решили сыграть в игру «Перетягивание числа».
# - Правила простые:
# - Петя увеличивает общее число.
# - Ваня уменьшает его.
# - Если в итоге получается положительное число — побеждает Петя.
# - Если отрицательное — выигрывает Ваня.
# - Если сумма равна нулю — ничья.
# - Создайте две функции:
# - move(player, number) — принимает имя игрока и его число, обновляет общий счёт;
# - game_over() — возвращает результат: 'Петя', 'Ваня' или 'Ничья'.
# - Общая сумма изначально равна 0.
# - Примечание
# - В решении не должно быть вызовов требуемых функций.


class Game:
    """Класс для управления игровым счетом."""

    _total: int = 0

    @classmethod
    def move(cls, player: Literal["Петя", "Ваня"], number: int) -> None:
        """Обновляет счет в игре."""
        if player == "Петя":
            cls._total += number
        elif player == "Ваня":
            cls._total -= number

    @classmethod
    def game_over(cls) -> Literal["Петя", "Ваня", "Ничья"]:
        """Определяет победителя игры."""
        if cls._total > 0:
            return "Петя"
        if cls._total < 0:
            return "Ваня"
        return "Ничья"


# ## Максимальный максимум.
#
# - Работа с таблицами чисел — важный навык, особенно если вы анализируете данные.
# - Попробуем найти самое большое число в такой таблице.
# - Напишите функцию max2D(matrix), которая принимает список списков целых чисел и возвращает максимальный элемент.
# - Примечание
# - В решении не должно быть вызовов требуемых функций.


def max_2d(matrix: list[list[int]]) -> int:
    """Находит максимальный элемент в матрице."""
    return max(max(row) for row in matrix)


# ## Числовое фрагментирование.
#
# - Допустим, у вас есть список чисел, и вы хотите разбить его на возрастающие фрагменты — участки, где каждое следующее число больше предыдущего. Такая задача может пригодиться при анализе последовательностей, графиков или пользовательских действий.
# - Напишите функцию fragments(numbers), которая принимает список целых чисел и возвращает список вложенных списков — каждый из которых представляет собой возрастающий отрезок исходной последовательности.
# - Примечание
# - В решении не должно быть вызовов требуемых функций.


def fragments(numbers: list[int]) -> list[list[int]]:
    """Разбивает список на возрастающие последовательности."""
    if not numbers:
        return []

    result = [[numbers[0]]]

    for i in range(1, len(numbers)):
        if numbers[i] > numbers[i - 1]:
            result[-1].append(numbers[i])
        else:
            result.append([numbers[i]])
    return result


# ## Имя of the month.
#
# - Программы часто работают с датами.
# - Допустим, у вас есть номер месяца и язык интерфейса.
# - Напишите функцию, которая по этим данным возвращает название месяца с заглавной буквы.
# - Создайте функцию month(number, language), которая принимает:
# - number — номер месяца от 1 до 12,
# - language — строку "ru" или "en", и возвращает название соответствующего месяца на нужном языке
# - Примечание
# - Ваше решение должно содержать только функции.
# - В решении не должно быть вызовов требуемых функций.


def month(number_month: int, language_month: Literal["ru", "en"]) -> str:
    """Возвращает название месяца по номеру и языку."""
    names_month = {
        "ru": [
            "Январь",
            "Февраль",
            "Март",
            "Апрель",
            "Май",
            "Июнь",
            "Июль",
            "Август",
            "Сентябрь",
            "Октябрь",
            "Ноябрь",
            "Декабрь",
        ],
        "en": [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December",
        ],
    }

    return names_month[language_month][number_month - 1]


# ## Числовая строка.
#
# - Давайте теперь научимся преобразовывать строку чисел в структуру данных, с которой удобно работать.
# - Создайте функцию split_numbers(text), которая принимает строку целых чисел, разделённых пробелами, и возвращает кортеж этих чисел.
# - Примечание
# - Ваше решение должно содержать только функции.
# - В решении не должно быть вызовов требуемых функций.
# - Вы можете спросить: почему кортеж, а не список. Всё дело в безопасности. Кортежи неизменяемые коллекции и их безопаснее передавать в функцию или из неё.


def split_numbers(text_split: str) -> tuple[int, ...]:
    """Преобразует строку чисел в кортеж целых чисел."""
    return tuple(int(x_split) for x_split in text_split.split())


# ## Поиск гор.
#
# - Представьте, что вы смотрите на линию горизонта.
# - Перед вами — последовательность чисел, обозначающих высоты.
# - Иногда среди них встречаются «горы» — точки, которые выше своих ближайших соседей.
# - Напишите функцию find_mountains(heights), которая принимает список высот и возвращает кортеж номеров всех гор. Нумерация начинается с 1.
# - Считаем, что края списка окружены горами бесконечной высоты — поэтому сравниваются только внутренние точки.


def find_mountains(heights: list[int]) -> tuple[int, ...]:
    """Находит позиции вершин в списке высот."""
    mountains = []
    for i in range(1, len(heights) - 1):
        if heights[i] > heights[i - 1] and heights[i] > heights[i + 1]:
            mountains.append(i + 1)
    return tuple(mountains)


# ## Поиск гор 2.
#
# - Теперь давайте посмотрим на местность с высоты — словно вы летите на самолёте.
# - Перед вами — прямоугольная таблица с высотами.
# - Внутри этой сетки тоже могут встречаться «горы» — точки, которые выше всех своих соседей по 8 направлениям.
# - Создайте функцию find_mountains(data), которая принимает список списков чисел и возвращает кортеж пар номеров всех гор.
# - Нумерация начинается с 1 (по строкам и столбцам).
# - Края таблицы считаются окружёнными горами бесконечной высоты, поэтому в них гор быть не может.
# - Примечание
# - В решении не должно быть вызовов требуемых функций.


def find_mountains_2(data: list[list[int]]) -> tuple[tuple[int, int], ...]:
    """Находит координаты вершин в матрице высот."""
    mountains = []
    rows = len(data)
    cols = len(data[0])

    for i in range(1, rows - 1):
        for j_index in range(1, cols - 1):
            current = data[i][j_index]
            is_mountain = True

            for xi in [-1, 0, 1]:
                for xj in [-1, 0, 1]:
                    if xi == 0 and xj == 0:
                        continue
                    if data[i + xi][j_index + xj] >= current:
                        is_mountain = False
                        break
                if not is_mountain:
                    break
            if is_mountain:
                mountains.append((i + 1, j_index + 1))
    return tuple(mountains)


# ## Модернизация системы вывода.
#
# - Представьте, что вы создаёте «умную» систему вывода, которая не повторяет уже напечатанные строки.
# - Это удобно, когда важно не засорять лог или консоль дубликатами.
# - Создайте функцию modern_print(text), которая печатает переданную строку, только если она ещё не выводилась ранее.
# - Все уникальные строки должны запоминаться.
# - Примечание
# - В решении не должно быть вызовов требуемых функций.

# +
printed_texts: set[str] = set()


def modern_print(text_mod: str) -> None:
    """Печатает текст только если он не печатался ранее."""
    if text_mod not in printed_texts:
        print(text_mod)
        printed_texts.add(text_mod)


# -

# ## Шахматный «обед».
#
# - В шахматах конь двигается особым образом: буквой "Г".
# - Он может съесть фигуру, если та находится на расстоянии двух клеток по одной оси и одной — по другой.
# - Напишите функцию can_eat(horse, other), которая принимает:
# - координаты коня,
# - координаты другой фигуры (оба значения — кортежи из двух чисел), и возвращает True, если конь может атаковать фигуру, и False — если не может.
# - Примечание
# - Ваше решение должно содержать только функции.
# - В решении не должно быть вызовов требуемых функций.


def can_eat(horse_eat: tuple[int, int], other_eat: tuple[int, int]) -> bool:
    """Проверяет, может ли конь съесть фигуру за один ход."""
    (hx, hy), (ox, oy) = horse_eat, other_eat
    dx = abs(hx - ox)
    dy = abs(hy - oy)
    return (dx == 1 and dy == 2) or (dx == 2 and dy == 1)


# ## Словарная строка.
#
# - Теперь научимся превращать строки с данными в словари.
# - Это полезно, если вы получаете настройки из текстового файла или обрабатываете ввод от пользователя.
# - Создайте функцию get_dict(text), которая принимает строку вида: ключ1=значение1;ключ2=значение2;... и возвращает словарь с этими парами.
# - Тип ключей — всегда строка. Значения попробуйте привести к int или float, если это возможно.
# - Примечание
# - В решении не должно быть вызовов требуемых функций.


def get_dict(text: str) -> dict[str, int | float | str]:
    """Парсит строку в словарь с автоматическим определением типов."""
    result: dict[str, int | float | str] = {}
    pairs = text.split(";")

    for pair in pairs:
        if "=" in pair:
            key, value_str = pair.split("=", 1)
            key = key.strip()
            value_str = value_str.strip()

            try:
                value: int | float | str = int(value_str)
            except ValueError:
                try:
                    value = float(value_str)
                except ValueError:
                    value = value_str
            result[key] = value
    return result


# ## А роза упала на лапу Азора 7.0.
#
# - Создайте функцию is_palindrome(x), которая принимает одно значение (число, строку, кортеж или список) и возвращает True, если передан палиндром, и False — в противном случае.
# - Примечание
# - Ваше решение должно содержать только функции.
# - В решении не должно быть вызовов требуемых функций.


def is_palindrome(x_is: Union[list[str], tuple[str, ...], int, str]) -> bool:
    """Проверяет, является ли объект палиндромом."""
    if isinstance(x_is, int):
        s_is = str(x_is)
        return s_is == s_is[::-1]
    if isinstance(x_is, str):
        return x_is == x_is[::-1]
    return list(x_is) == list(reversed(x_is))


# ## Простая задача 5.0.
#
# - Простые числа — важное понятие в математике и программировании.
# - Они делятся только на 1 и на себя. Проверка числа на простоту используется в шифровании, аналитике и олимпиадных задачах.
# - Напишите функцию is_prime, которая принимает натуральное число, а возвращает булево значение: True — если переданное число простое, а иначе — False.
# - Примечание
# - Ваше решение должно содержать только функции.
# - В решении не должно быть вызовов требуемых функций.


def is_prime(n_prime: int) -> bool:
    """Проверяет, является ли число простым."""
    if n_prime < 2:
        return False
    if n_prime == 2:
        return True
    if n_prime % 2 == 0:
        return False
    i_prime = 3
    while i_prime * i_prime <= n_prime:
        if n_prime % i_prime == 0:
            return False
        i_prime += 2
    return True


# ## Слияние.
#
# - Теперь научимся объединять отсортированные коллекции в одну.
# - Это важный шаг в алгоритмах сортировки и при обработке данных.
# - Напишите функцию merge, которая принимает два отсортированных по возрастанию кортежа целых чисел, а возвращает один из всех переданных чисел.
# - Примечание
# - Ваше решение должно содержать только функции.
# - В решении не должно быть вызовов требуемых функций.

# +
T = TypeVar("T", int, float, str)


def merge(tuple_1: tuple[T, ...], tuple_2: tuple[T, ...]) -> tuple[T, ...]:
    """Объединяет два отсортированных кортежа в один отсортированный."""
    result_mer = []
    i_mer, j_mer = 0, 0
    while i_mer < len(tuple_1) and j_mer < len(tuple_2):
        if tuple_1[i_mer] <= tuple_2[j_mer]:
            result_mer.append(tuple_1[i_mer])
            i_mer += 1
        else:
            result_mer.append(tuple_2[j_mer])
            j_mer += 1
    while i_mer < len(tuple_1):
        result_mer.append(tuple_1[i_mer])
        i_mer += 1
    while j_mer < len(tuple_2):
        result_mer.append(tuple_2[j_mer])
        j_mer += 1
    return tuple(result_mer)


# -

# ## Обмен содержимым.
#
# - Иногда нужно поменять содержимое двух списков местами так, чтобы ссылки на них остались прежними.
# - То есть объекты остаются теми же, а данные — полностью меняются.
# - Создайте функцию swap(a, b), которая принимает два списка и меняет их содержимое местами.
# - Результат должен быть виден во всех переменных, которые ссылаются на эти списки.
# - Примечание
# - В решении не должно быть вызовов требуемых функций.

# +
_T = TypeVar("_T")


def swap(a_swap: list[_T], b_swap: list[_T]) -> None:
    """Меняет местами содержимое двух списков."""
    temp = a_swap[:]
    a_swap[:] = b_swap[:]
    b_swap[:] = temp


# -

# ## Цезарю — Цезарево.
#
# - В Древнем Риме использовалась особая система счисления. Чтобы попрактиковаться в сложении римских чисел, напишите функцию roman, которая принимает два натуральных числа a и b, а возвращает строку вида: РИМСКОЕ_А + РИМСКОЕ_B = РИМСКАЯ_СУММА
# - Примечание
# - В решении не должно быть вызовов требуемых функций.


# +
def to_roman(n_roman: int) -> str:
    """Конвертирует целое число в римскую запись."""
    val_roman = [
        (1000, "M"),
        (900, "CM"),
        (500, "D"),
        (400, "CD"),
        (100, "C"),
        (90, "XC"),
        (50, "L"),
        (40, "XL"),
        (10, "X"),
        (9, "IX"),
        (5, "V"),
        (4, "IV"),
        (1, "I"),
    ]
    result_roman = ""
    for num_roman, symbol_roman in val_roman:
        while n_roman >= num_roman:
            result_roman += symbol_roman
            n_roman -= num_roman
    return result_roman


def roman(a_rom: int, b_rom: int) -> str:
    """Возвращает строку с римскими числами и их суммой."""
    roman_a = to_roman(a_rom)
    roman_b = to_roman(b_rom)
    roman_sum = to_roman(a_rom + b_rom)
    return f"{roman_a} + {roman_b} = {roman_sum}"
