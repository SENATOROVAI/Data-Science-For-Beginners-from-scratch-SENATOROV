"""Строки, кортежи, списки.

В этом параграфе мы начнём знакомство с коллекциями — специальными типами данных, которые
позволяют хранить и обрабатывать несколько значений одновременно. Мы разберёмся, как
обращаться к элементам коллекций, как проходить по ним в цикле, использовать срезы и
встроенные методы. А ещё научимся отличать изменяемые коллекции от неизменяемых — это
важно для понимания, как работает память в Python. Рассмотрим упорядоченные коллекции,
индексацию, методы и функции для их обработки.
"""

# ### Азбука
# - Малыши начали учить алфавит. Воспитатель попросил их назвать слова, начинающиеся только с букв а, б или в.
# - Напишите программу, которая проверит, что все введённые слова соответствуют этим правилам.
# - Формат ввода
# - Вводится натуральное число N — количество слов, названных детьми.
# - В каждой из последующих N строк записано по одному слову строчными буквам.
# - Формат вывода
# - YES — если все слова начинаются с нужной буквы.
# - NO — если хотя бы одно слово начинается не с нужной буквы.

# +
import sys
from math import factorial


def abc() -> None:
    """abc."""
    number_abc: int = int(input())
    count_abc: int = 0
    for _ in range(number_abc):
        word_abc: str = input()
        if word_abc[0] == "а" or word_abc[0] == "б" or word_abc[0] == "в":
            count_abc += 1
    print("YES" if count_abc == number_abc else "NO")


if __name__ == "__main__":
    abc()


# -

# ### Кручу-верчу
# - Иногда в текстовых редакторах возникает необходимость повернуть строку — то есть сделать из горизонтальной записи вертикальную. В Python такая функция по-умолчанию отсутствует, но это не проблема: мы напишем её сами!
# - Напишите программу, которая преобразует введённую стоку из горизонтальной записи в вертикальную.
# - Формат ввода
# - Одна строка.
# - Формат вывода
# - Вертикальное представление введённой строки.


# +
def twisting_turning() -> None:
    """twisting_turning."""
    word: str = input()
    for _, char in enumerate(word):
        print(char)


if __name__ == "__main__":
    twisting_turning()


# -

# ### Анонс новости
# - Местная редакция заказала у вас систему для отображения заголовков. Чтобы лента была удобной, слишком длинные заголовки нужно сокращать и добавлять многоточие.
# - Напишите программу, которая сокращает заголовки до требуемой длины. Если заголовок длиннее, он должен быть усечён и завершён многоточием .... Если заголовок помещается в заданную длину — выводите его без изменений.
# - Формат ввода
# - Вводится натуральное число L — необходимая длина заголовка.
# - Вводится натуральное число N — количество заголовков, которые требуется сократить.
# - В каждой из последующих N строк записано по одному заголовку.
# - Формат вывода
# - Сокращённые заголовки.
# - Примечание
# - Многоточие учитывается при подсчёте длины заголовка.


# +
def news_announcement() -> None:
    """news_announcement."""
    words_news: int = int(input())
    count_news: int = int(input())
    for _ in range(count_news):
        text_news: str = input()
        if len(text_news) <= words_news:
            print(text_news)
        else:
            print(f"{text_news[:(words_news - 3)]}...")


if __name__ == "__main__":
    news_announcement()


# -

# ### Очистка данных
# - Работая с реальными текстовыми файлами и логами, почти всегда приходится сталкиваться с «грязными» данными: лишними символами, мусорными строками, ошибками форматирования. В этой задаче вы поможете местному провайдеру почистить отчёты: устраните системные ошибки и оставите только полезную информацию.
# - Напишите программу, которая обрабатывает лог-файл, состоящий из строк, и: удаляет две решётки ## в начале строки, если они есть; удаляет всю строку, если она заканчивается на @@@. Ввод продолжается, пока не встретится пустая строка.
# - Формат ввода
# - Вводятся строки отчёта. Признаком завершения ввода считается пустая строка.
# - Формат вывода
# - Очищенные данные.


# +
def data_cleaning() -> None:
    """data_cleaning."""
    while True:
        text_clean: str = input()
        if text_clean[:2] == "##" and text_clean[-3::] != "@@@":
            print(text_clean[2:])
        elif text_clean[:2] != "##" and text_clean[-3::] != "@@@":
            print(text_clean)
        if text_clean == "":
            break


if __name__ == "__main__":
    data_cleaning()


# -

# ### А роза упала на лапу Азора 4.0
# - Продолжаем исследовать симметричные строки — палиндромы. Палиндром — это строка, которая читается одинаково слева направо и справа налево. Например: анна, казак, топот. А вот мама — уже не палиндром.
# - Напишите программу, которая определяет, относится ли введённая строка к палиндромам.
# - Формат ввода
# - Вводится строка.
# - Формат вывода
# - Требуется вывести YES — если введенная строка является палиндромом, иначе – NO.


# +
def palindrome_4() -> None:
    """palindrome_4."""
    text_pal: str = input()
    if text_pal == text_pal[::-1]:
        print("YES")
    else:
        print("NO")


if __name__ == "__main__":
    palindrome_4()


# -

# ### Зайка — 6
# - Очередное семейное путешествие — и снова игра «Кто первым увидит зверушку за окном». Сегодня в фокусе внимания — зайки. Поможем ребятам подсчитать, сколько заек они увидели!
# - Напишите программу, которая по описаниям местности определяет, сколько раз встретилась зайка.
# - Формат ввода
# - В первой строке записано натуральное число N — количество выделенных придорожных местностей.
# - В каждой из N последующих строк записано описание придорожной местности.
# - Формат вывода
# - Количество заек.


# +
def banny_6() -> None:
    """banny_6."""
    count_banny: int = int(input())
    count_pet: int = 0
    for _ in range(count_banny):
        text_banny: str = input()
        cnt: int = text_banny.count("зайка")
        count_pet += cnt
    print(count_pet)


if __name__ == "__main__":
    banny_6()


# -

# ### А и Б сидели на трубе
# - Ввод данных от пользователя не всегда бывает удобным — особенно, если речь идёт о строках, в которых содержатся сразу несколько чисел. В этой задаче вы потренируетесь извлекать данные из строки и преобразовывать их для дальнейших вычислений. Ведь даже А и Б из детского стишка порой нуждаются в вычислениях!
# - Напишите программу, которая считывает два целых числа, введённые в одной строке через пробел, и выводит их сумму.
# - Формат ввода
# - Два целых числа, разделённые пробелом.
# - Формат вывода
# - Одно целое число — сумма переданных чисел.


# +
def a_b_sum() -> None:
    """a_b_sum."""
    first: str
    second: str
    first, second = input().split()
    print(int(first) + int(second))


if __name__ == "__main__":
    a_b_sum()


# -

# ### Зайка — 7
# - Поезд мчится вдоль берёзок, елочек и сосен, а дети за окном снова ищут любимых зверушек — заек! На этот раз — задача посложнее: нужно не только найти, но и точно указать, где именно в строке прячется первый заяц!
# - Напишите программу, которая для каждой строки описания местности: выводит позицию первого появления слова зайка (нумерация начинается с 1); если в строке нет зайки — выведите: Заек нет =(.
# - Формат ввода
# - В первой строке записано натуральное число N — количество выделенных придорожных местностей.
# - В каждой из N последующих строк записано описание придорожной местности.
# - Формат вывода
# - Для каждой строки нужно найти положение первого зайки.
# - Если в строке нет заек, то об этом нужно непременно сообщить.
# - Примечание
# - Для символов в строках используйте нумерацию с 1.


# +
def banny_7() -> None:
    """banny_7."""


count_ban: int = int(input())
for _ in range(count_ban):
    text_ban: str = input()
    position: int = text_ban.find("зайка")
    if position != -1:
        print(position + 1)
    else:
        print("Заек нет =(")


if __name__ == "__main__":
    banny_7()


# -

# ### Без комментариев
# - Комментарии — важная часть кода, особенно если вы хотите, чтобы другие поняли вашу логику. Но когда программа запускается, интерпретатор просто игнорирует комментарии — всё, что начинается с #. В этой задаче вы сами выступите в роли интерпретатора: научитесь очищать строки кода от комментариев!
# - Напишите программу, которая удаляет комментарии из кода. Если строка состоит только из комментария — её не нужно выводить вообще.
# - Формат ввода
# - Вводятся строки программы. Признаком остановки является пустая строка.
# - Формат вывода
# - Каждую строку нужно очистить от комментариев. А если комментарий — вся строка, то выводить её не надо.
# - Примечание
# - Символ # в данной задаче используется только для комментариев.


# +
def no_comments() -> None:
    """no_comments."""
    while True:
        line_com: str = input()
        if line_com == "":
            break
        if line_com.strip().startswith("#"):
            continue
        index_com: int = line_com.find("#")
        if index_com != -1:
            line_com = line_com[:index_com]
        line_com = line_com.rstrip()
        if line_com != "":
            print(line_com)


if __name__ == "__main__":
    no_comments()


# -

# ### Частотный анализ на минималках
# - Частотный анализ — это метод подсчёта, какие символы (или слова) чаще всего встречаются в тексте. Это важнейший инструмент взлома многих классических шифров — от шифра Цезаря и до шифровальной машины «Энигма».В этой задаче вы реализуете простейшую версию частотного анализа:
# выясните, какая буква встречается чаще других в тексте.
# - Напишите программу, которая читает строки до тех пор, пока не встретится строка 'ФИНИШ', и выводит наиболее часто встречающуюся букву (в нижнем регистре).
# - Формат ввода
# - Вводятся строки, пока не будет введена строка «ФИНИШ».
# - Формат вывода
# - Выводится один символ в нижнем регистре — наиболее часто встречающийся во введённой строке.
# - Примечания
# - Пробелы в анализе не участвуют. Если в результате анализа получено несколько ответов, следует вывести первый по алфавиту. У данной задачи множество "быстрых" способов решения, но в этом параграфе мы просим вас сосредоточиться на использовании строк и списков.


# +
def min_analysis() -> None:
    """min_analysis."""
    letters_anal: list[str] = []
    counts_anal: list[int] = []

    while True:
        row_anal: str = input()
        if row_anal == "ФИНИШ":
            break
        for char_anal in row_anal:
            letter_anal: str = char_anal.lower()
            if letter_anal == " ":
                continue
            if letter_anal in letters_anal:
                index_anal: int = letters_anal.index(letter_anal)
                counts_anal[index_anal] += 1
            else:
                letters_anal.append(letter_anal)
                counts_anal.append(1)
    max_anal_count: int = max(counts_anal) if counts_anal else 0
    max_anal_letters: list[str] = []
    for i_an, letter in enumerate(letters_anal):
        if counts_anal[i_an] == max_anal_count:
            max_anal_letters.append(letter)
    if max_anal_letters:
        max_anal_letters.sort()
        print(max_anal_letters[0])
    else:
        print("")


if __name__ == "__main__":
    min_analysis()


# -

# ### Найдётся всё
# - Теперь — к делу. Поиск информации — одна из самых важных задач в наше время. Предлагаем потренироваться в работе со списками строк, поиском подстроки, и игнорированием регистра. Создайте мини-поисковик, который по ключевому слову покажет подходящие заголовки страниц.
# - Формат ввода
# - Вводится натуральное число N — количество страниц, среди которых требуется произвести поиск.
# - В каждой из последующих N строк записаны заголовки страниц. В последней строке записан поисковый запрос.
# - Формат вывода
# - Вывести все заголовки страниц, в которых присутствует поисковый запрос (регистр не имеет значения). Порядок заголовков должен сохраниться.


# +
def everything() -> None:
    """everything."""
    every_count: int = int(input())
    every_list: list[str] = []
    every_name: str = ""
    for i_eve in range(every_count + 1):
        every_text: str = input()
        if i_eve < every_count:
            every_list.append(every_text)
        elif i_eve == every_count:
            every_name = every_text
    for every_string in every_list:
        if every_name.lower() in every_string.lower():
            print(every_string)


if __name__ == "__main__":
    everything()


# -

# ### Меню питания
# - В детском саду ежедневно подают новую кашу на завтрак. Каши чередуются в следующем порядке:
# - Манная;
# - Гречневая;
# - Пшённая;
# - Овсяная;
# - Рисовая.
# - Ваша задача — составить расписание каш на ближайшие дни, чтобы повара знали, что готовить.
# - Напишите программу, которая по числу дней N выводит, какие каши будут подаваться в ближайшие N дней.
# - Формат ввода
# - Вводится натуральное число N — количество дней.
# - Формат вывода
# - Вывести список каш в порядке подачи.


# +
def food_menu() -> None:
    """food_menu."""
    count_day_menu: int = int(input())
    my_list_menu: list[str] = ["Манная", "Гречневая", "Пшённая", "Овсяная", "Рисовая"]

    for i_food in range(1, count_day_menu + 1):
        word_index_menu: int = (i_food - 1) % len(my_list_menu)
        current_word_menu: str = my_list_menu[word_index_menu]
        print(current_word_menu)


if __name__ == "__main__":
    food_menu()


# -

# ### Массовое возведение в степень
# - Часто возникают трудности, когда нужно выполнить множество однообразных операций. В таких случаях люди желают упростить себе работу. Напишите программу, которая возводит в заданную степень все числа, что передали пользователи.
# - Формат ввода
# - Вводится натуральное число N — количество чисел.
# - В каждой из последующих N строк записано по одному числу.
# - В последней строке записано натуральное число P — степень, в которую требуется возвести числа.
# - Формат вывода
# - Последовательность чисел, являющихся ответом.


# +
def exponentiation() -> None:
    """exponentiation."""
    number_of_numbers: int = int(input())
    my_list: list[int] = []
    number_power: int = 0
    for i_expon in range(number_of_numbers + 1):
        numbers: int = int(input())
        if i_expon < number_of_numbers:
            my_list.append(numbers)
        elif i_expon == number_of_numbers:
            number_power = numbers
    for j_exp in my_list:
        print(j_exp**number_power)


if __name__ == "__main__":
    exponentiation()


# -

# ### Массовое возведение в степень 2.0
# - Иногда приходится выполнять однотипные действия над целой группой чисел — например, возвести каждое из них в заданную степень. Вручную это делать долго и утомительно, особенно если чисел много. Пора автоматизировать процесс!
# - Напишите программу, которая возводит в заданную степень все числа, переданные пользователем.
# - Формат ввода
# - В первой строке записана последовательность натуральных чисел, разделённых пробелами.Во второй строке записано натуральное число P — степень, в которую требуется возвести числа.
# - Формат вывода
# - Последовательность чисел, являющихся ответом. Числа вывести в одну строку через пробел.


# +
def exponentiation_2() -> None:
    """exponentiation_2."""
    number_of_numbers_exp: int = 2
    my_list_exp: list[int] = []
    number_power_exp: int = 0

    for i_exp in range(number_of_numbers_exp):
        numbers_exp: list[str] = input().split()
        if i_exp == 0:
            my_list_exp = [int(x) for x in numbers_exp]
        else:
            number_power_exp = int(numbers_exp[0])
    result_exp: list[str] = []
    for num in my_list_exp:
        numb_exp: int = num**number_power_exp
        result_exp.append(str(numb_exp))
    print(" ".join(result_exp))


if __name__ == "__main__":
    exponentiation_2()


# -

# ### НОД 3.0
# - Из местного НИИ снова обратились за помощью. Им снова нужно находить наибольший общий делитель (НОД) — теперь по целой строке чисел. Хорошо, что у нас есть опыт!
# - Напишите программу, которая находит НОД всех чисел, введённых в одной строке через пробел.
# - Формат ввода
# - В единственной строке записывается последовательность натуральных чисел, разделённых пробелами.
# - Формат вывода
# - Требуется вывести одно натуральное число — НОД всех данных чисел.
# - Примечание
# - Самый распространенный способ поиска НОД — Алгоритм Эвклида.


# +
def nod_3() -> None:
    """nod_3."""


numbers_list_nod: list[int] = list(map(int, input().split()))
if not numbers_list_nod:
    print(0)
else:
    current_gcd: int = numbers_list_nod[0]
    for i in range(1, len(numbers_list_nod)):
        numb_nod: int = numbers_list_nod[i]
        a_nod: int = current_gcd
        b_nod: int = numb_nod
        while b_nod:
            a_nod, b_nod = b_nod, a_nod % b_nod
        current_gcd = a_nod
        if current_gcd == 1:
            break
    print(current_gcd)


if __name__ == "__main__":
    nod_3()


# -

# ### Анонс новости 2.0
# - Вы снова работаете над лентой новостей для сайта. Теперь заголовки могут занимать несколько строк, но при этом всё равно нужно соблюдать лимит: если заголовок слишком длинный — он должен быть сокращён и завершён многоточием .... Эта задача поможет вам научиться учитывать длину строк, переносы и условия обрезки текста.
# - Напишите программу, которая по заданному количеству строк и максимально допустимой длине:выводит заголовок, при необходимости обрезая его; если заголовок слишком длинный — заменяет последние символы на ...; если строки заканчиваются слишком коротко, ... может перейти в предыдущую строку.
# - Формат ввода
# - Вводится натуральное число L — необходимая длина заголовка.
# - Вводится натуральное число N — количество строк в заголовке новости.
# - В каждой из последующих N строк записано по одной строке заголовка.
# - Формат вывода
# - Сокращённый заголовок.
# - Примечание
# - Многоточие учитывается при подсчёте длины заголовка. Символ перевода строки при подсчёте длины не учитывается.


# +
def news_announcement_2() -> None:
    """news_announcement_2."""
    max_length_an: int = int(input())
    lines_an: list[str] = []

    for _ in range(int(input())):
        lines_an.append(input())

    for line_an in lines_an:
        if max_length_an > 3:
            if len(line_an) >= max_length_an - 3:
                line_an = line_an[: max_length_an - 3] + "..."
            else:
                if max_length_an == 4:
                    line_an = line_an + "..."

            print(line_an)
            max_length_an -= len(line_an)


if __name__ == "__main__":
    news_announcement_2()


# -

# ### А роза упала на лапу Азора 5.0
# - Мы снова возвращаемся к загадочным палиндромам — на этот раз с небольшим усложнением.Теперь нужно определить, является ли строка палиндромом без учёта регистра и пробелов. То есть А роза упала на лапу Азора — это палиндром, а Мама мыла раму — уже нет.
# - Напишите программу, которая проверяет, является ли введённая строка палиндромом.
# - Формат ввода
# - Вводится строка.
# - Формат вывода
# - Если введённая строка относится к палиндрому, то вывести YES, а иначе — NO.
# - Примечание
# - При проверке не обращайте внимания на регистр и пробелы.


# +
def palindrome_5() -> None:
    """palindrome_5."""
    text_palindrome: str = input().lower().replace(" ", "")
    if text_palindrome == text_palindrome[::-1]:
        print("YES")
    else:
        print("NO")


if __name__ == "__main__":
    palindrome_5()


# -

# ### RLE
# - RLE (Run-Length Encoding) — это способ сокращённой записи повторяющихся символов. Вместо длинной группы одинаковых символов записывается сам символ и число его повторений. Например, 99999 превращается в 9 5 («девять пять раз»).
# - Напишите программу, которая получает строку из цифр и выводит её RLE-представление: последовательность пар «цифра — количество подряд идущих повторений».
# - Формат ввода
# - Строка цифр длиной не меньше 1.
# - Формат вывода
# - Пары: сама цифра и количество повторений цифры подряд во введённой строке, как описано в условии и показано в примере.


# +
def rle() -> None:
    """rle."""
    text_rle: str = input().strip()
    if not text_rle:
        sys.exit()
    reference_rle: str = text_rle[0]
    counter_rle: int = 1
    text_rle = text_rle[1:] + "_"

    result_rle: list[str] = []
    for digit in text_rle:
        if digit == reference_rle:
            counter_rle += 1
        else:
            result_rle.append(f"{reference_rle} {counter_rle}")
            reference_rle = digit
            counter_rle = 1
    print("\n".join(result_rle))


if __name__ == "__main__":
    rle()


# -

# ### Польский калькулятор
# Сейчас — вызов на логику: реализуем калькулятор на основе обратной польской нотации (ОПН). В ОПН нет скобок и приоритета операций — всё вычисляется строго слева направо, с помощью стека. Вы добавляете числа в стек, а когда встречаете оператор (+, -, *) — извлекаете два последних числа, применяете операцию и возвращаете результат обратно в стек.
# - Напишите программу, которая по введённому выражению в ОПН вычисляет результат.
# - Формат ввода
# - Вводится одна строка, содержащая разделённые пробелами целые числа и знаки операций +, -, *, которые вместе составляют корректное выражение в обратной польской нотации.
# - Формат вывода
# - Выводится одно целое число — результат вычисления выражения.


# +
def polish_calculator() -> None:
    """polish_calculator."""
    expression: list[str] = input().split()
    stack: list[int] = []
    for token in expression:
        if token in "+-*":
            b_pol: int = stack.pop()
            a_pol: int = stack.pop()
            result: int
            if token == "+":
                result = a_pol + b_pol
            elif token == "-":
                result = a_pol - b_pol
            elif token == "*":
                result = a_pol * b_pol
            stack.append(result)
        else:
            stack.append(int(token))
    print(stack[0])


if __name__ == "__main__":
    polish_calculator()


# -

# ### Польский калькулятор — 2
# - Напоследок последняя задача с ОПН. Операции, которые выполняются с одним значением, называются унарными, с двумя — бинарными, с тремя — тернарными.Давайте улучшим наш калькулятор, добавив поддержку следующих операций:
# - бинарные:
# - + (сложение),
# - - (вычитание),
# - * (умножение),
# - / (деление нацело; для отрицательных чисел работает по тем же правилам, что и в Python);
# - унарные:
# - ~ (унарный минус — меняет знак),
# - ! (факториал),
# - (#) (клонирование — вернуть в стек значение дважды);
# - тернарные:
# - @ (возвращает в стек те же три значения, но в ином порядке: второе, третье, первое).
# - Формат ввода
# - Вводится одна строка, содержащая разделённые пробелами целые числа и знаки операций. Вместе они составляют корректное выражение в обратной польской нотации, не содержащее деления на ноль и взятия факториала от отрицательного числа.
# - Формат вывода
# - Выводится одно целое число — результат вычисления выражения.


# +
def polish_calculator_2() -> None:
    """polish_calculator_2."""
    tokens: list[str] = input().split()
    stack: list[int] = []

    for token in tokens:
        if token == "+":
            right_operand = stack.pop()
            left_operand = stack.pop()
            stack.append(left_operand + right_operand)
            continue

        if token == "-":
            right_operand = stack.pop()
            left_operand = stack.pop()
            stack.append(left_operand - right_operand)
            continue

        if token == "*":
            right_operand = stack.pop()
            left_operand = stack.pop()
            stack.append(left_operand * right_operand)
            continue

        if token == "/":
            right_operand = stack.pop()
            left_operand = stack.pop()
            stack.append(left_operand // right_operand)
            continue

        if token == "~":
            operand = stack.pop()
            stack.append(-operand)
            continue

        if token == "!":
            operand = stack.pop()
            stack.append(factorial(operand))
            continue

        if token == "#":
            duplicate_value = stack.pop()
            stack.append(duplicate_value)
            stack.append(duplicate_value)
            continue

        if token == "@":
            third_value = stack.pop()
            second_value = stack.pop()
            first_value = stack.pop()
            stack.append(second_value)
            stack.append(third_value)
            stack.append(first_value)
            continue

        stack.append(int(token))

    print(stack[0])


polish_calculator_2()
