"""Рекурсия. Декораторы. Генераторы.

вы познакомитесь с продвинутыми приёмами работы с функциями. Мы разберём, как устроены
рекурсивные функции и чем они отличаются от привычных императивных решений. Вы научитесь
ускорять рекурсивные вычисления с помощью кеширования и декораторов, а также узнаете, как
писать функции, которые возвращают значения по мере необходимости, — с помощью генераторов
и оператора yield.
"""

# ## Рекурсивный сумматор.
#
# - Большинство задач этой главы ориентировано на отработку навыков по разработке рекурсивных функций.
# - Ваше решение будет использоваться как библиотека.
# - Напишите функцию recursive_sum, которая находит сумму всех позиционных аргументов.
# - Примечание
# - Ваше решение должно содержать только функции.
# - В решении не должно быть вызовов требуемых функций, за исключением рекурсивных.
# - Трассировка вызова рекурсивной функции в обработке ответа не учитывается и показана для примера.

from collections.abc import Generator, Iterator

# +
from types import FunctionType
from typing import Callable, Optional, ParamSpec, TypeVar


def recursive_sum(*args: int) -> int:
    """Рекурсивно суммирует целые числа."""
    if not args:
        return 0
    return recursive_sum(*args[:-1]) + args[-1]


# -

# ## Pекурсивный сумматор цифр.
#
# - Рекурсия – отличный способ избавиться от циклов, особенно от while. Давайте вспомним одну из наших старых задач и модернизируем её.
# - Напишите функцию recursive_digit_sum, которая находит сумму всех цифр натурального числа.
# - Примечание
# - Ваше решение должно содержать только функции.
# - В решении не должно быть вызовов требуемых функций, за исключением рекурсивных.
# - Трассировка вызова рекурсивной функции в обработке ответа не учитывается и показана для примера.


def recursive_digit_sum(number: int) -> int:
    """Рекурсивно суммирует цифры числа."""
    if number == 0:
        return 0
    return recursive_digit_sum(number // 10) + number % 10


# ## Многочлен N-ой степени.
#
# - Напишите функцию make_equation, которая по заданным коэффициентам строит строку, описывающую валидное с точки зрения Python выражение без использования оператора возведения в степень.
# - Многочлен второй степени с коэффициентами a, b и c, например, можно записать в виде:((a)∗x+b)∗x+c
# - Примечание
# - Ваше решение должно содержать только функции.
# - В решении не должно быть вызовов требуемых функций, за исключением рекурсивных.
# - Трассировка вызова рекурсивной функции в обработке ответа не учитывается и показана для примера.


def make_equation(*coefficients: int) -> str:
    """Строит полином по коэффициентам в виде строки."""
    if len(coefficients) == 1:
        return str(coefficients[0])
    return f"({make_equation(*coefficients[:-1])}) * x + {coefficients[-1]}"


# ## Декор результата.
#
# - Напишите декоратор answer, который преобразует функцию, принимающую неограниченное число позиционных и именованных параметров и возвращает её результат с припиской "Результат функции: <значение>".
# - Примечание
# - Ваше решение должно содержать только функции.
# - В решении не должно быть вызовов требуемых функций.


def answer(function: FunctionType) -> object:
    """Декоратор, добавляющий префикс к результату функции."""

    def new_function(*args: object, **kwargs: object) -> str:
        result = function(*args, **kwargs)
        return f"Результат функции: {result}"

    return new_function


# ## Накопление результата.
#
# - В некоторых случаях полезно накапливать результат, а затем получать его единым списком. Реализуйте декоратор result_accumulator, который модернизирует функцию с неопределенным количеством позиционных параметров следующим образом:
# - Добавляет именованный параметр method со значением по умолчанию accumulate;
# - При вызове функции с параметром method равным accumulate, результат сохраняется в очередь (для каждой функции в собственную), а функция ничего не возвращает;
# - При вызове функции с параметром method равным drop, возвращается все накопленные результаты, а очередь сбрасывается.
# - Примечание
# - Ваше решение должно содержать только функции.
# - В решении не должно быть вызовов требуемых функций.


def result_accumulator(function: FunctionType) -> object:
    """Копит результаты и отдаёт их списком при method='drop'."""
    results: list[object] = []

    def wrapper(*args: object, method: str = "accumulate") -> list[object] | None:
        """Добавляет результат; при 'drop' возвращает накопленное и очищает."""
        result: object = function(*args)
        results.append(result)
        if method == "drop":
            accumulated: list[object] = list(results)
            results.clear()
            return accumulated
        return None

    return wrapper


# ## Сортировка слиянием.
#
# - Мы уже реализовывали функцию merge, которая способна "слить" два отсортированных списка в один.
# - Чаще всего её применяют в рекурсивном алгоритме сортировки слиянием.
# - Напишите рекурсивную функцию merge_sort, которая производит сортировку списка.
# - Примечание
# - Ваше решение должно содержать только функции.
# - В решении не должно быть вызовов требуемых функций, за исключением рекурсивных.
# - Трассировка вызова рекурсивной функции в обработке ответа не учитывается и показана для примера.


# +
def merge_sort(arr: list[int]) -> list[int]:
    """Сортирует список с помощью алгоритма сортировки слиянием."""
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = arr[:mid]
    right = arr[mid:]
    left_sorted = merge_sort(left)
    right_sorted = merge_sort(right)
    return merge(left_sorted, right_sorted)


def merge(left: list[int], right: list[int]) -> list[int]:
    """Объединяет два отсортированных списка в один отсортированный."""
    result = []
    left_index = right_index = 0
    while left_index < len(left) and right_index < len(right):
        if left[left_index] <= right[right_index]:
            result.append(left[left_index])
            left_index += 1
        else:
            result.append(right[right_index])
            right_index += 1
    while left_index < len(left):
        result.append(left[left_index])
        left_index += 1
    while right_index < len(right):
        result.append(right[right_index])
        right_index += 1
    return result


# -

# ## Однотипность не порок.
#
# - Во многих задачах требуется контроль входных данных, в частности, несмотря на динамическую типизацию, их типов.
# - Разработайте декоратор same_type, который производит проверку переменного количества позиционных параметров. В случае получения не - одинаковых типов выводит сообщение "Обнаружены различные типы данных" и прерывает выполнение функции.
# - Примечание
# - Ваше решение должно содержать только функции.
# - В решении не должно быть вызовов требуемых функций.

# +
_P = ParamSpec("_P")
_R = TypeVar("_R")


def same_type(function: Callable[_P, _R]) -> Callable[_P, Optional[_R]]:
    """Проверяет, что все аргументы одного типа."""

    def wrapper(*args: _P.args, **kwargs: _P.kwargs) -> Optional[_R]:
        if len(args) > 1 and len(set(map(type, args))) > 1:
            print("Обнаружены различные типы данных")
            return None
        return function(*args, **kwargs)

    return wrapper


# -

# ## Генератор Фибоначчи.
#
# - Числа Фибоначчи весьма интересная последовательность и используется в различных математических задачах. В ней каждый следующий элемент равен сумме двух предыдущих. Математики начинают эту последовательность с двух единиц, но мы же с вами программисты, поэтому привыкли вести счет с нуля.
# - Напишите генератор fibonacci, который последовательно возвращает заданное количество чисел Фибоначчи по "правилам программистов".
# - Примечание
# - Ваше решение должно содержать только функции.
# - В решении не должно быть вызовов требуемых функций.


def fibonacci(n_fib: int) -> Generator[int, None, None]:
    """Генерирует последовательность Фибоначчи."""
    a_fib, b_fib = 0, 1
    for _ in range(n_fib):
        yield a_fib
        a_fib, b_fib = b_fib, a_fib + b_fib


# ## Циклический генератор.
#
# - Напишите генератор cycle, который принимает список и работает аналогично итератору itertools.cycle.
# - Примечание
# - Ваше решение должно содержать только функции.
# - В решении не должно быть вызовов требуемых функций.

# +
_Ti = TypeVar("_Ti")


def cycle(items: list[_Ti]) -> Iterator[_Ti]:
    """Бесконечно повторяет элементы списка."""
    if not items:
        return
    while True:
        yield from items


# -

# ## "Выпрямление" списка.
#
# - Весьма часто, данные, которые мы получаем из различных источников, не удовлетворяют нашим пожеланиям. Одна из частых проблем – излишняя вложенность списков.
# - Напишите функцию make_linear, которая принимает список списков и возвращает его "выпрямленное" представление.
# - Примечание
# - Ваше решение должно содержать только функции.
# - В решении не должно быть вызовов требуемых функций, за исключением рекурсивных.
# - Трассировка вызова рекурсивной функции в обработке ответа не учитывается и показана для примера.


def make_linear(nested_list: list[object]) -> list[object]:
    """Преобразует вложенные списки в плоский список."""
    result: list[object] = []
    for item in nested_list:
        if isinstance(item, list):
            result.extend(make_linear(item))
        else:
            result.append(item)
    return result
