"""2.2. Условный оператор.

В этом параграфе мы научимся управлять поведением программы: выполнять
одни действия в одних ситуациях и другие — в других. Вы узнаете, как
Python принимает решения с помощью условных конструкций, как работают
логические выражения, и как применять их на практике.
Мы также разберём новые конструкции вроде match-case и
полезные встроенные функции.
"""

# ## 1.Просто здравствуй, просто как дела
# - Ура, вы снова здесь! Это значит, что мы начинаем вторую часть вашей практики.
# - На этот раз вы будете тренировать навык работы с условным оператором if-else.
# - Вы уже знаете, как написать программу, которая знакомится с человеком и спрашивает его имя.
# - Теперь напишите программу, которая сначала познакомится с пользователем, а затем
# поинтересуется его настроением.
# - Формат ввода
# - В первой строке записано имя пользователя.
# - Во второй — ответ на вопрос: «хорошо» или «плохо».
# - Формат вывода
# - В первой строке должен быть вопрос «Как Вас зовут?»
# - Во второй строке — «Здравствуйте, %username%!»
# - В третьей строке — вопрос «Как дела?»
# - В четвёртой строке реакция на ответ пользователя:
# - если пользователь ответил «хорошо», следует вывести сообщение «Я за Вас рада!»;
# - если пользователь ответил «плохо», следует вывести сообщение «Всё наладится!».


# +
def simple_hi() -> None:
    """simple_hi."""
    print("Как Вас зовут?")
    name: str = input()
    print(f"Здравствуйте, {name}!")
    print("Как дела?")
    mood: str = input()
    if mood == "хорошо":
        print("Я за Вас рада!")
    elif mood == "плохо":
        print("Всё наладится!")


if __name__ == "__main__":
    simple_hi()


# -

# ## 2.Кто быстрее?
# - Продолжаем работать с условным оператором if-else.
# - В главной велогонке года участвуют более тысячи гонщиков, которые должны пройти трассу длиной 43872 метра. Задача — определить победителя.
# - Нам известны средние скорости двух фаворитов — Пети и Васи. Помогите узнать, кто из них пришёл к финишу первым.
# - Формат ввода
# - В первой строке записана средняя скорость Пети.
# - Во второй — Васи.
# - Формат вывода
# - Имя победителя гонки.
# - Примечание
# - Гарантируется, что победителем стал только один.


# +
def who_is_faster() -> None:
    """who_is_faster."""
    petr_speed: float = float(input())
    vasya_speed: float = float(input())

    if petr_speed > vasya_speed:
        print("Петя")
    else:
        print("Вася")


if __name__ == "__main__":
    who_is_faster()


# -

# ## 3.Кто быстрее на этот раз?
# - Давайте немного усложним задачу и поработаем с вложенными условными операторами if-else или оператором if-elif-else.
# - Три велогонщика снова хотят узнать, кто из них быстрее. Им предстоит пройти трассу длиной 43872 метра, и нам нужно определить, кто из них - пришёл к финишу первым.
# - Нам известны средние скорости трёх фаворитов — Пети, Васи и Толи. Кто из них финишировал первым?
# - Формат ввода
# - В первой строке записана средняя скорость Пети.
# - Во второй — Васи.
# - В третьей — Толи.
# - Формат вывода
# - Имя победителя гонки.
# - Примечание
# - Гарантируется, что победителем стал только один.


# +
def who_is_faster_now() -> None:
    """who_is_faster_now."""
    petr_speed: float = float(input())
    vasya_speed: float = float(input())
    tolya_speed: float = float(input())
    if petr_speed > vasya_speed > tolya_speed:
        print("Петя")
    elif vasya_speed > petr_speed > tolya_speed:
        print("Вася")
    else:
        print("Толя")


if __name__ == "__main__":
    who_is_faster_now()


# -

# ## 4.Список победителей
# - В этой задаче вы продолжите работать с операторами, но добавим к этому наивную сортировку данных.
# - Время подвести итоги гонки и объявить победителя!
# - Длина трассы — 43872 метра, и нам известны средние скорости трёх фаворитов: Пети, Васи и Толи.
# - Ваша задача — сравнить результаты гонщиков и вывести имя победителя.
# - Формат ввода
# - В первой строке записана средняя скорость Пети.
# - Во второй — Васи.
# - В третьей — Толи.
# - Формат вывода
# - Имена победителей в порядке занятых мест.


# +
def list_winners() -> None:
    """list_winners."""
    petr_speed: float = float(input())
    vasya_speed: float = float(input())
    tolya_speed: float = float(input())
    if petr_speed > vasya_speed > tolya_speed:
        print("1. Петя\n2. Вася\n3. Толя")
    elif petr_speed > tolya_speed > vasya_speed:
        print("1. Петя\n2. Толя\n3. Вася")
    elif vasya_speed > petr_speed > tolya_speed:
        print("1. Вася\n2. Петя\n3. Толя")
    elif vasya_speed > tolya_speed > petr_speed:
        print("1. Вася\n2. Толя\n3. Петя")
    elif tolya_speed > petr_speed > vasya_speed:
        print("1. Толя\n2. Петя\n3. Вася")
    else:
        print("1. Толя\n2. Вася\n3. Петя")


if __name__ == "__main__":
    list_winners()


# -

# ## 5.Яблоки
# - Как насчет небольшой головоломки с применением условного оператора?
# - У Пети было 7 яблок, а у Васи 6.
# - Затем Петя отдал 3 яблока Васе, а у Толи взял 2 яблока.
# - Вася попросил у Толи 5 яблок, но отдал Гене 2.
# - Затем Дима дал Пете N яблок, а Васе M.
# - Так у кого в итоге яблок больше — у Пети или Васи?
# - Формат ввода
# - В первой строке записано натуральное число N.Во второй — M.
# - Формат вывода
# - Имя ребёнка, у которого больше яблок.


# +
def apples() -> None:
    """apples."""
    petr_apple: int = 7
    vasya_apple: int = 6
    n_apple: int = int(input())
    m_apple: int = int(input())
    petr_apple -= 3
    vasya_apple += 3
    petr_apple += 2
    vasya_apple += 5
    vasya_apple -= 2
    petr_apple += n_apple
    vasya_apple += m_apple
    if petr_apple > vasya_apple:
        print("Петя")
    else:
        print("Вася")


if __name__ == "__main__":
    apples()


# -

# ## 6.Сила прокрастинации
# - Вася любит полениться. Особенно ему нравится, когда в году появляется такой лишний денёк, которого обычно не бывает.
# - Напишите программу, которая поможет Васе определить, удастся ли ему побездельничать в определённом году или нет.
# - Формат ввода
# - Одно число — год.
# - Формат вывода
# - Одно слово «YES» (удастся) или «NO» (не удастся).


# +
def power_of_procrastination() -> None:
    """power_of_procrastination."""
    year: int = int(input())
    if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
        print("YES")
    else:
        print("NO")


if __name__ == "__main__":
    power_of_procrastination()


# -

# ## 7.А роза упала на лапу Азора
# - Новый день - новое знание! А вы знали, что есть такое понятие как "палиндром"?
# - Палиндром - это число, слово, предложение и так далее, которое и слева-направо, и справа-налево читается одинаково.
# - А как быстро понять, является ли слово палиндромом? Написать программу для проверки этого! В этом нам снова поможет условный оператор.
# - Формат ввода
# - Одно четырёхзначное число
# - Формат вывода
# - YES если число является палиндромом, иначе — NO.


# +
def polindrom_numb() -> None:
    """polindrom_numb."""
    polindrom: int = int(input())
    num_1: int = polindrom // 1000
    num_2: int = (polindrom // 100) % 10
    num_3: int = (polindrom // 10) % 10
    num_4: int = polindrom % 10
    if num_1 == num_4 and num_2 == num_3:
        print("YES")
    else:
        print("NO")


if __name__ == "__main__":
    polindrom_numb()


# -

# ## 8.Зайка — 1
# - В долгих поездках дети могут заскучать, поэтому родители развлекают их различными играми. Одна из таких игр — искать зверушек в придорожной растительности.
# - Давайте сыграем! С помощью условного оператора if-else и оператора in проверим, не спрятался ли зайка в введённом предложении
# - Формат ввода
# - Строка описывающая придорожную местность.
# - Формат вывода
# - YES — если в этой местности есть зайка, иначе — NO.


# +
def search_hare() -> None:
    """search_hare."""
    text: str = input()
    if "зайка" in text:
        print("YES")
    else:
        print("NO")


if __name__ == "__main__":
    search_hare()


# -

# ## 9.Первому игроку приготовиться
# - Кто пойдёт первым? В настольных играх очередность часто определяется жребием, но мы будем использовать порядок букв!
# - Давайте сравним имена игроков лексикографически и с помощью условных операторов определим, кто начнёт игру.
# - Формат ввода
# - Три имени игроков, каждое из которых записано с новой строки.
# - Формат вывода
# - Имя игрока, который будет ходить первым.


# +
def first_player() -> None:
    """first_player."""
    name_1: str = input()
    name_2: str = input()
    name_3: str = input()
    if name_1 < name_2 and name_1 < name_3:
        print(name_1)
    elif name_2 < name_1 and name_2 < name_3:
        print(name_2)
    else:
        print(name_3)


if __name__ == "__main__":
    first_player()


# -

# ## 10.Лучшая защита — шифрование
# - Коля решил зашифровать свои пароли, чтобы Аня не смогла их подсмотреть в блокноте. Для этого он берёт изначальный пароль — трёхзначное число — и превращает его в новое, следуя таким правилам:
# - Сначала находит сумму двух младших цифр (десятков и единиц).
# - Затем находит сумму двух старших цифр (сотен и десятков).
# - Эти суммы записываются в порядке не возрастания, образуя зашифрованное число.
# - Помогите реализовать алгоритм шифрования, используя базовое применение условного оператора if-else.
# - Формат ввода
# - Одно трёхзначное число
# - Формат вывода
# - Результат шифрования


# +
def encryption_protection() -> None:
    """encryption_protection."""
    code: int = int(input())
    junior_numb: int = (code // 10) % 10 + (code % 10)
    senior_numb: int = (code // 10) % 10 + (code // 100)
    if junior_numb > senior_numb:
        print(str(junior_numb) + str(senior_numb))
    else:
        print(str(senior_numb) + str(junior_numb))


if __name__ == "__main__":
    encryption_protection()


# -

# ## 11.Красота спасёт мир
# - Согласно одному древнему поверью, трёхзначное число считается красивым, если сумма его минимальной и максимальной цифр равна оставшейся цифре умноженной на 2.
# - Напишите программу, которая проверяет, является ли число красивым.
# - Формат ввода
# - Одно трёхзначное число
# - Формат вывода
# - YES — если число красивое, иначе — NO


# +
def beauty_will_save_to_world() -> None:
    """beauty_will_save_to_world."""
    local_numb: int = int(input())
    local_numb_1: int = local_numb // 100
    local_numb_2: int = (local_numb // 10) % 10
    local_numb_3: int = local_numb % 10
    min_numb: int = min(local_numb_1, local_numb_2, local_numb_3)
    max_numb: int = max(local_numb_1, local_numb_2, local_numb_3)
    mid_numb: int = (local_numb_1 + local_numb_2 + local_numb_3) - min_numb - max_numb
    if min_numb + max_numb == 2 * mid_numb:
        print("YES")
    else:
        print("NO")


if __name__ == "__main__":
    beauty_will_save_to_world()


# -

# ## 12.Музыкальный инструмент
# - Вася обожает треугольники и решил попробовать сделать один самостоятельно.
# - У него есть несколько алюминиевых трубочек разной длины, и он хочет узнать, можно ли из них собрать треугольник.
# - Помогите Васе определить, можно ли из трёх данных отрезков создать треугольник.
# - Формат ввода
# - Три числа — длины трубочек, каждое с новой строки.
# - Формат вывода
# - YES — если Васе удастся создать музыкальный треугольник, иначе — NO


# +
def musical_instrument() -> None:
    """musical_instrument."""
    side_1: int = int(input())
    side_2: int = int(input())
    side_3: int = int(input())
    sum_1 = side_1 + side_2
    sum_2 = side_1 + side_3
    sum_3 = side_2 + side_3
    if sum_1 > side_3 and sum_2 > side_2 and sum_3 > side_1:
        print("YES")
    else:
        print("NO")


if __name__ == "__main__":
    musical_instrument()


# -

# ## 13.Властелин Чисел: Братство общей цифры
# - Во времена магии и драконов ходили легенды о числах, обладающих великой силой, способной изменить мир.
# - Три числа были даны эльфам, семь — гномам, а девять достались человеческому роду.
# - Но все они были обмануты... Потому что существовало ещё одно число. В стране Нумия, на бумаге из тёмного папируса, властелин Зерон тайно записал Единую Цифру, подчиняющую себе все великие числа.
# - Давайте выясним, что это за цифра!
# - Формат ввода
# - В первой строке записано двузначное число одного из эльфов.
# - Во второй строке — Гномов.
# - В третьей — Людей.
# - Формат вывода
# - Одна цифра — общая у всех трёх чисел в одинаковой позиции


# +
def brotherhood_of_numbers() -> None:
    """brotherhood_of_numbers."""
    num_1: int = int(input())
    num_2: int = int(input())
    num_3: int = int(input())

    if num_1 % 10 == num_2 % 10 == num_3 % 10:
        print(num_1 % 10)
    elif num_1 // 10 == num_2 // 10 == num_3 // 10:
        print(num_1 // 10)


if __name__ == "__main__":
    brotherhood_of_numbers()


# -

# ## 14.Властелин Чисел: Две Башни
# - Во времена, когда люди верили в магическую силу чисел, волшебник Пифуман предал все народы и встал на сторону Зерона.
# - Теперь, чтобы проникнуть в башни обоих злодеев одновременно, нужно разделить силу числа, которое защищало нас в дороге.
# - Для этого возьмём трёхзначное число и составим из него минимальное и максимальное возможные двухзначные числа. Каждая цифра может использоваться не более того количества раз, сколько раз она встречается во входном числе.
# - Формат ввода
# - Одно трёхзначное число.
# - Формат вывода
# - Два защитных числа для каждого отряда, записанные через пробел.


# +
def two_towers() -> None:
    """two_towers."""
    num = int(input().strip())
    digits = [num // 100, (num // 10) % 10, num % 10]
    digits_sorted = sorted(digits)
    min_digits = digits_sorted.copy()
    max_digits = digits_sorted.copy()

    min_first = None
    for dig in min_digits:
        if dig != 0:
            min_first = dig
            break

    if min_first is None:
        min_first = 0

    min_temp = min_digits.copy()
    min_temp.remove(min_first)

    min_second = min_temp[0]
    min_number = min_first * 10 + min_second

    max_first = max_digits[-1]

    max_temp = max_digits.copy()
    max_temp.remove(max_first)

    max_second = max_temp[-1]
    max_number = max_first * 10 + max_second

    print(f"{min_number} {max_number}")


if __name__ == "__main__":
    two_towers()


# -

# ## 15.Властелин Чисел: Возвращение Цезаря
# - До победы над злом остался последний шаг — разрушить логово Зерона.
# - Для этого нам нужно создать трёхзначное магическое число, которое будет сильнее двух защитных чисел Зерона.
# - Как его составить?
# - Первая цифра — максимальная из всех защитных чисел.
# - Последняя цифра — минимальная.
# - Средняя цифра — сумма оставшихся цифр без учёта переноса разряда.
# - Соберите это магическое число и помогите одолеть зло!
# - Формат ввода
# - В двух строках записаны защитные числа Зерона.
# - Формат вывода
# - Одно трёхзначное число, которое приведёт к победе.


# +
def caesar_return() -> None:
    """Caesar_return."""
    num_1, num_2 = int(input()), int(input())
    digits: list[int] = [num_1 // 10, num_1 % 10, num_2 // 10, num_2 % 10]
    digits.sort()
    max_num, min_num = digits[-1], digits[0]
    mid_num: int = (digits[1] + digits[2]) % 10
    print(f"{max_num}{mid_num}{min_num}")


if __name__ == "__main__":
    caesar_return()


# -

# ## 16.Легенды велогонок возвращаются: кто быстрее?
# - В новом сезоне за первенство в велогонках снова сражаются сильнейшие. Протяжённость финальной трассы — 43872м, и все хотят узнать, кто первым пересечёт финишную черту.
# - Нам известны средние скорости трёх претендентов — Пети, Васи и Толи. Кто станет победителем?
# - Формат ввода
# - В первой строке записана средняя скорость Пети.
# - Во второй — Васи.
# - В третьей — Толи.
# - Формат вывода
# - Красивый пьедестал (ширина ступеней 8 символов).


# +
def cycling_legends() -> None:
    """cycling_legends."""
    petr: int = int(input())
    vasya: int = int(input())
    tolya: int = int(input())

    number_1: str
    number_2: str
    number_3: str

    if petr > vasya > tolya:
        number_1 = "Петя"
        number_2 = "Вася"
        number_3 = "Толя"
    elif petr > tolya > vasya:
        number_1 = "Петя"
        number_2 = "Толя"
        number_3 = "Вася"
    elif vasya > petr > tolya:
        number_1 = "Вася"
        number_2 = "Петя"
        number_3 = "Толя"
    elif vasya > tolya > petr:
        number_1 = "Вася"
        number_2 = "Толя"
        number_3 = "Петя"
    elif tolya > petr > vasya:
        number_1 = "Толя"
        number_2 = "Петя"
        number_3 = "Вася"
    else:
        number_1 = "Толя"
        number_2 = "Вася"
        number_3 = "Петя"

    print(f"{' ' * 8}{number_1:^8}{' ' * 8}")
    print(f"{number_2:^8}{' ' * 8}")
    print(f"{' ' * 16}{number_3:^8}")
    print(f"{'II':^8}{'I':^8}{'III':^8}")


if __name__ == "__main__":
    cycling_legends()


# -

# ## 17.Корень зла
# - Знаете ли вы, что Python изначально создавался для решения математических задач? Давайте воспользуемся его возможностями и найдём корни уравнения, используя составные условные операции.
# - Формат ввода
# - Вводится 3 вещественных числа a, b, c — коэффициенты уравнения вида: ax**2 + bx + c = 0
# - Формат вывода
# - Если у уравнения нет решений — следует вывести «No solution».
# - Если корней конечное число — их нужно вывести через пробел в порядке возрастания с точностью до сотых.
# - Если корней неограниченное число — следует вывести «Infinite solutions».
# - Примечание
# - Обратите внимание: ограничения на значения коэффициентов отсутствуют.
#
#


# +
def root_of_evil() -> None:
    """root_of_evil."""


a_num: float = float(input())
b_num: float = float(input())
c_num: float = float(input())

if a_num == 0:
    if b_num == 0:
        if c_num == 0:
            print("Infinite solutions")
        else:
            print("No solution")
    else:
        root: float = -c_num / b_num
        print(f"{root:.2f}")
else:
    discriminant: float = b_num**2 - 4 * a_num * c_num
    if discriminant > 0:
        root_1: float = (-b_num + discriminant**0.5) / (2 * a_num)
        root_2: float = (-b_num - discriminant**0.5) / (2 * a_num)
        if root_1 > root_2:
            root_1, root_2 = root_2, root_1
        print(f"{root_1:.2f} {root_2:.2f}")
    elif discriminant == 0:
        root = -b_num / (2 * a_num)
        print(f"{root:.2f}")
    else:
        print("No solution")


if __name__ == "__main__":
    root_of_evil()


# -

# ## 18.Территория зла
# - В давние времена верили, что если местность имеет форму треугольника, то в ней может скрываться страшное зло.
# - При этом риск столкнуться с ним зависел от формы треугольника:
# - Остроугольный — вероятность встречи со злом крайне мала.
# - Тупоугольный — опасность велика.
# - Прямоугольный — вероятность 100%!
# - Напишите программу, которая определяет вероятность встретить зло по длинам сторон треугольника. Воспользуйтесь для этого составными условными операциями.
# - Формат ввода
# - Три числа — длины сторон треугольной местности.
# - Формат вывода
# - Вероятность встретить зло согласно поверью:
# - крайне мала;
# - велика;
# - 100%.


# +
def territory_of_evil() -> None:
    """territory_of_evil."""
    a_numb: float = float(input())
    b_numb: float = float(input())
    c_numb: float = float(input())
    max_side: float = max(a_numb, b_numb, c_numb)
    sum_sq: float = a_numb**2 + b_numb**2 + c_numb**2 - max_side**2
    if sum_sq == max_side**2:
        print("100%")
    elif sum_sq < max_side**2:
        print("велика")
    else:
        print("крайне мала")


if __name__ == "__main__":
    territory_of_evil()


# -

# ## 19.Автоматизация безопасности
# - Группа исследователей готовится к высадке на остров идеальной формы, но спутниковая разведка обнаружила на нём зону зыбучих песков.
# - Чтобы обеспечить безопасность экспедиции, разработана система оповещения, которая предупреждает об опасности в зависимости от координат исследователя.
# - Для снижения расходов было решено создать программное обеспечение, которое автоматически определит, безопасна ли точка местонахождения исследователя.
#
# ![image.png](attachment:image.png)
#
# - Напишите программу, которая по заданным координатам проверит, находится ли исследователь в зоне опасности, учитывая несколько условий одновременно.
# - Формат ввода
# - Два рациональных числа — координаты исследователя.
# - Формат вывода
# - Одно из сообщений:
# - Опасность! Покиньте зону как можно скорее!
# - Зона безопасна. Продолжайте работу.
# - Вы вышли в море и рискуете быть съеденным акулой!


# +
def security_automation() -> None:
    """security_automation."""
    x_numb = float(input())
    y_numb = float(input())

    distance_from_origin: float = (x_numb**2 + y_numb**2) ** 0.5

    if distance_from_origin > 10:
        print("Вы вышли в море и рискуете быть съеденным акулой!")
    elif x_numb > 0 and y_numb > 0 and distance_from_origin <= 5:
        print("Опасность! Покиньте зону как можно скорее!")
    elif (-4) <= x_numb < 0 <= y_numb <= 5:
        print("Опасность! Покиньте зону как можно скорее!")
    elif (
        (-7) <= x_numb < (-4) and 0 <= y_numb <= 5 and (5 * x_numb - 3 * y_numb) > (-35)
    ):
        print("Опасность! Покиньте зону как можно скорее!")
    elif (0.25 * x_numb**2 + 0.5 * x_numb - 9) <= y_numb <= 0:
        print("Опасность! Покиньте зону как можно скорее!")
    else:
        print("Зона безопасна. Продолжайте работу.")


if __name__ == "__main__":
    security_automation()


# -

# ## 20.Зайка — 2
# - По пути домой родители снова решили сыграть с детьми в поиск зверушек. Но на этот раз задача сложнее — нужно не просто найти зайку, а выбрать правильную строку по определённым условиям.
# - Вам предстоит проверить три строки, найти среди них ту, где встречается слово "зайка", и вывести её вместе с её длиной. Если таких строк несколько, выберите наименьшую в алфавитном порядке.
# - Для этого используйте составные условные операции, чтобы одновременно учесть несколько условий.
# - Формат ввода
# - Три строки описывающих придорожную местность.
# - Формат вывода
# - Строка в которой есть зайка, а затем её длина.
# - Если таких строк несколько, выбрать ту, что меньше всех лексикографически.


# +
def search_hare_2() -> None:
    """search_hare_2."""
    string_1: str = input()
    string_2: str = input()
    string_3: str = input()
    result: str | None = None

    if "зайка" in string_1:
        if result is None or string_1 < result:
            result = string_1
    if "зайка" in string_2:
        if result is None or string_2 < result:
            result = string_2
    if "зайка" in string_3:
        if result is None or string_3 < result:
            result = string_3

    print(f"{result} {len(result) if result is not None else 0}")


if __name__ == "__main__":
    search_hare_2()
