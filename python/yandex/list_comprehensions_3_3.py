"""Списочные выражения. Модель памяти для типов языка Python.

В этом параграфе вы научитесь компактно создавать и фильтровать списки с помощью списочных
выражений, узнаете, как работают генераторы и в чём их преимущество по сравнению со
списками. А ещё разберётесь, как Python хранит переменные в памяти, чем изменяемые объекты
отличаются от неизменяемых — и почему это важно при написании кода.
"""

# ## Список квадратов.
#
# - Это первая задача в блоке, и она поможет освоиться с базовой конструкцией списочных выражений в Python. Такие выражения позволяют лаконично и эффективно создавать списки по заданному правилу.
# - Вашему решению будут даны две переменные a и b.
# - Напишите одно списочное выражение, которое формирует список квадратов всех целых чисел от [a,b] включительно.
# - Примечание
# - В решении не должно быть ничего, кроме списочного выражения.


def list_of_squares(a_square: int, b_square: int) -> list[int]:
    """list_of_squares."""
    return [x_square**2 for x_square in range(a_square, b_square + 1)]


# ## Список квадратов 2.
#
# - В этой задаче мы продолжаем работать со списочными выражениями, но теперь усложним логику: список квадратов должен строиться вне зависимости от порядка значений a и b. Если a < b, счёт идёт вперёд. Если a > b, счёт идёт назад. Результат — один список, содержащий квадраты всех чисел от a до b включительно, в соответствующем порядке. Вашему решению даны переменные a и b. Сформируйте список квадратов всех целых чисел от a до b включительно — в прямом или обратном порядке, в зависимости от того, какое значение больше.
# - Примечание
# - В решении не должно быть ничего, кроме списочного выражения.


def list_of_squares_2(a_sqr: int, b_sqr: int) -> list[int]:
    """list_of_squares_2."""
    return [
        x_sqr**2
        for x_sqr in (
            range(a_sqr, b_sqr + 1) if a_sqr <= b_sqr else range(a_sqr, b_sqr - 1, -1)
        )
    ]


# ## Основы фильтрации.
#
# - Переходим от построения списков к фильтрации значений. Теперь ваша цель — выбрать из диапазона только те числа, которые делятся на заданное значение без остатка. Вашему решению даны три переменные: a, b и d. Сформируйте список всех чисел, кратных d, лежащих в диапазоне от a до b включительно. С помощью одного списочного выражения постройте список всех чисел от a до b, которые делятся на d без остатка.
# - Примечание
# - В решении не должно быть ничего, кроме списочного выражения.


def filtering_basics(a_bas: int, b_bas: int, d_bas: int) -> list[int]:
    """filtering_basics."""
    return [
        i
        for i in (
            range(a_bas, b_bas + 1) if a_bas <= b_bas else range(a_bas, b_bas - 1, -1)
        )
        if i % d_bas == 0
    ]


# ## Множество нечетных чисел.
#
# - Продолжаем практиковаться с генераторами множеств и фильтрацией данных. Вашему решению предоставлен список numbers, содержащий натуральные числа. Нужно выбрать из него только нечётные числа — и сохранить их в множестве, чтобы исключить повторы. Сформируйте одно выражение, которое создаёт множество всех нечётных чисел из списка numbers.
# - Примечание
# - В решении не должно быть ничего, кроме выражения.


def odd(numb_odd: list[int]) -> set[int]:
    """odd."""
    return {i for i in numb_odd if i % 2 == 1}


# ## Множество всех полных квадратов.
#
# - Полный квадрат — это натуральное число, являющееся квадратом другого натурального числа.
# - Например:
# - 4 — это 2 ** 2,
# - 49 — это 7 ** 2.
# - Ваша задача — из заданного списка numbers отобрать только полные квадраты и собрать их в множество (без повторов).
# - Вашему решению будет предоставлен список numbers, содержащий натуральные числа. Сформируйте одно выражение, которое создаёт множество всех полных квадратов из списка.
# - Примечание
# - В решении не должно быть ничего, кроме выражения.


def set_all_squares(numbers_sqr: list[int]) -> set[int]:
    """set_all_squares."""
    return {numb for numb in numbers_sqr if numb == int(numb**0.5) ** 2}


# ## Длины всех слов.
#
# - Теперь переходим к следующему шагу: учимся извлекать информацию из строк.
# - В этой задаче нужно посчитать длину каждого слова в строке.
# - Вашему решению будет предоставлена строка sentence, в которой слова разделены пробелами.
# - Напишите списочное выражение, которое создаёт список длин этих слов.
# - Примечание
# - В решении не должно быть ничего, кроме списочного выражения.


def lengths_all_words(sentence: str) -> list[int]:
    """lengths_all_words."""
    return [len(word) for word in sentence.split()]


# ## Цифровая выжимка.
#
# - На этот раз вам предстоит найти все цифры в строке.
# - Вашему решению будет предоставлена переменная text — строка, которая может содержать любые символы.
# - Нужно извлечь все цифры и собрать их в одну строку, сохранив порядок появления.
# - Примечание
# - В решении не должно быть ничего, кроме списочного выражения.


def digital_extract(text_dig: str) -> str:
    """digital_extract."""
    return "".join(let for let in text_dig if let.isdigit())


# ## Аббревиатура.
#
# - На этот раз нужно сократить длинную фразу до аббревиатуры, как делают в названиях компаний, университетов или государств.
# - Вам дана строка string, содержащая слова, разделённые пробелами.
# - Нужно составить строку из первых букв всех слов, в верхнем регистре, без пробелов.
# - Примечание
# - В решении не должно быть ничего, кроме выражения.


def abbreviation(string_abb: str) -> str:
    """abbreviation."""
    return "".join([i[0].upper() for i in string_abb.split()])


# ## Преобразование в строку.
#
# - Допустим, у вас есть список натуральных чисел, возможно с повторениями.
# - Ваша задача — превратить его в строку, в которой будут только уникальные числа, отсортированные по возрастанию, разделённые через дефис с пробелами (' - ').
# - Вашему решению предоставлен список натуральных чисел numbers.
# - Сформируйте строку по описанным правилам.
# - Примечание
# - В решении не должно быть ничего, кроме выражения.


def convert_to_string(numb_convert: list[int]) -> str:
    """convert_to_string."""
    return " - ".join(map(str, sorted(set(numb_convert))))


# ## Огласите список.
#
# - Иногда при анализе текста важно уметь выделять слова с определёнными характеристиками — например, по количеству гласных. В этой задаче мы потренируемся именно в такой фильтрации: вы будете искать слова, в которых не менее трёх гласных, независимо от языка или регистра.
# - Вашему решению предоставлена строка words.
# - Напишите выражение, которое создаёт список слов, в которых не менее трёх гласных букв (в любом регистре).
# - Примечание
# - В решении не должно быть ничего, кроме выражения.
# - В русском языке гласными являются: аяуюоёэеиы
# - В английском: aeiouy


def announce_list(words_list: str) -> list[str]:
    """announce_list."""
    return [
        word_list
        for word_list in words_list.split()
        if sum(1 for letter in word_list.lower() if letter in "аеёиоуыэюяaeiouy") >= 3
    ]


# ## Выявление уникальности.
#
# - Если хочется — сделайте небольшой перерыв, а потом возвращайтесь — дальше будет не менее интересно.
# - Когда вы работаете с данными, важно уметь выделять уникальные значения — те, что появляются ровно один раз.
# - Вашему решению предоставлен список numbers.
# - Напишите выражение, которое создаёт множество всех чисел, встречающихся в списке ровно один раз.
# - Примечание
# - В решении не должно быть ничего, кроме выражения.


def identifying_uniqueness(numbers_ind: list[int]) -> set[int]:
    """identifying_uniqueness."""
    return {i for i in numbers_ind if numbers_ind.count(i) == 1}


# ## Максимальное произведение.
#
# - Вашему решению предоставлено множество numbers.
# - Напишите одно выражение, которое находит максимальное произведение двух различных чисел из этого множества.


def maximum_product(numb_max: list[int]) -> int:
    """maximum_product."""
    return max(
        first * second for first in numb_max for second in numb_max if first != second
    )


# ## Словарный минимум.
#
# - Вашему решению предоставлен словарь data, в котором ключами являются слова, а значениями списки чисел.
# - Напишите одно выражение, которое находит ключ с наименьшей суммой значений.
# - Если таких несколько — выберите лексикографически наименьший (т.е. тот, что раньше по алфавиту).


def minimum_vocabulary(data_voc: dict[str, list[int]]) -> str:
    """minimum_vocabulary."""
    return min(
        (sum(numbers_voc), word_voc) for word_voc, numbers_voc in data_voc.items()
    )[1]


# ## Поиск ошибок.
#
# - Иногда в данных встречаются ошибки — например, повторы там, где их быть не должно.
# - Научимся быстро находить такие случаи при помощи словарей и выражений.
# - Вашему решению предоставлен словарь data, в котором ключами являются слова, а значениями списки чисел.
# - Напишите выражение для создания множества ключей, среди значений которых есть повторы.


def finding_errors(data_err: dict[str, list[int]]) -> set[str]:
    """finding_errors."""
    return {
        word_err
        for word_err, numbers_err in data_err.items()
        if len(numbers_err) != len(set(numbers_err))
    }


# ## Буквенная статистика.
#
# - В этой задаче вы потренируетесь извлекать статистику из текстовых данных. А именно — подсчитывать частоту употребления каждой буквы в строке. Это навык, который пригодится во многих прикладных задачах, от анализа документов до построения индексов поиска.
# - Вашему решению будет предоставлена строка text.
# - Напишите выражение для генерации словаря, который содержит информацию о частоте употребления букв в заданной строке.
# - При анализе не учитывайте регистр, а ключами словаря сделайте использованные в строке буквы в нижнем регистре.


def letter_statistics(text_stat: str) -> dict[str, int]:
    """letter_statistics."""
    return {
        letter: text_stat.lower().count(letter)
        for letter in set(text_stat.lower())
        if letter.isalpha()
    }


# ## RLE наоборот.
#
# - Формат RLE (Run-Length Encoding) — это способ сжатия данных, при котором последовательности одинаковых символов заменяются на пару: символ + количество повторений. В этой задаче вам нужно сделать обратное преобразование: по списку пар символов и количества их повторений восстановить исходную строку.
# - Вашему решению будет предоставлен список кортежей rle с символами и количеством их повторений.
# - Напишите выражение для генерации строки, из которой был получен данный список.
# - Примечание
# - В решении не должно быть ничего, кроме выражения.


def vice_versa(rle: list[tuple[str, int]]) -> str:
    """vice_versa."""
    return "".join(char * count for char, count in rle)


# ## Таблица умножения 2.0.
#
# - На этом этапе мы потренируемся в вложенных списочных выражениях и сгенерируем настоящую таблицу умножения.
# - Вашему решению будет предоставлена единственная переменная n — необходимый размер таблицы. Постройте список из n списков, каждый из которых содержит произведения чисел от 1 до n на текущее значение строки.
# - Примечание
# - В решении не должно быть ничего, кроме списочного выражения.


def multiplication_table_2(n_mul: int) -> list[list[int]]:
    """multiplication_table_2."""
    return [
        [i_mul * j_mil for j_mil in range(1, n_mul + 1)]
        for i_mul in range(1, n_mul + 1)
    ]


# Делители.
#
# - В этой задаче мы потренируем вложенные списочные выражения и создание словаря с вычисляемыми значениями.
# - Нужно будет для каждого числа найти список всех его делителей — от 1 до самого числа.
# - Вашему решению будет предоставлено множество numbers.
# - Напишите выражение для генерации словаря содержащего информацию о делителях каждого из заданных чисел.
# - Примечание
# - В решении не должно быть ничего, кроме выражения.


def dividers(numb_div: list[int]) -> dict[int, list[int]]:
    """dividers."""
    return {
        num_div: [i_div for i_div in range(1, num_div + 1) if num_div % i_div == 0]
        for num_div in numb_div
    }


# ## Простое множество.
#
# - А сейчас — проверим, умеете ли вы находить простые числа с помощью выражений на Python.
# - В этой задаче предстоит применить вложенное выражение с условием, чтобы отфильтровать все простые числа из множества.
# - Вашему решению будет предоставлено множество numbers.
# - Продумайте выражение для генерации множества содержащего все простые числа из заданных.
# - Примечание
# - В решении не должно быть ничего, кроме выражения.


def simple_set(numb_simple: list[int]) -> set[int]:
    """simple_set."""
    return {
        num
        for num in numb_simple
        if num > 1 and all(num % i != 0 for i in range(2, int(num**0.5) + 1))
    }


# ## Обобщение.
#
# - В этом задании вы проанализируете текст и определите пары слов, которые имеют не менее трёх общих букв. Важно: порядок слов в паре не имеет значения, а повторяющиеся буквы не считаются несколько раз.
# - Вашему решению будет предоставлена переменная text.
# - Напишите выражение для генерации множества, содержащего все кортежи пар слов, имеющих более двух общих букв без учёта повторений.
# - Пары с разным порядком слов следует считать одной и той же и включать в результат только в одном (лексикографически упорядоченном) виде.
# - Примечание
# - В решении не должно быть ничего, кроме выражения.
# - Все слова в тексте различны.


def generalization(text_gen: str) -> set[tuple[str, str]]:
    """generalization."""
    return {
        (word_1, word_2)
        for word_1 in text_gen.split()
        for word_2 in text_gen.split()
        if word_1 < word_2 and len(set(word_1) & set(word_2)) > 2
    }
