"""Множества, словари.

В этом параграфе мы продолжим изучать коллекции — но теперь познакомимся с
неупорядоченными типами данных. Вы узнаете, как работают множества (set) и словари (dict),
чем они отличаются от списков и в каких задачах используются. Научитесь проверять,
содержится ли элемент в множестве, находить пересечения и разности, а также хранить и
быстро получать значения по ключам. Мы разберёмся, как создавать множества и словари,
выполнять над ними операции, использовать их методы и применять в реальных примерах.
"""

# ## Символическая выжимка.
#
# - Во многих промышленных задачах требуется понять, из каких символов состоят данные, и избавиться от повторений.
# - Напишите программу, которая по введённой строке выводит все её уникальные символы — без повторений.
# - Формат ввода
# - Вводится одна строка.
# - Формат вывода
# - Требуется вывести все символы этой строки без повторений.
# - Порядок вывода не имеет значения.


# +
def symbolic_summary() -> None:
    """symbolic_summary."""
    data: set[str] = set(input())
    print(*data, sep="")


if __name__ == "__main__":
    symbolic_summary()


# -

# ## Символическая разница.
#
# - Теперь нас интересует пересечение данных: какие символы одинаковы в двух разных строках?
# - Такую задачу можно встретить в анализе логов, данных с датчиков или при обработке пользовательского ввода.
# - Напишите программу, которая находит общие символы в двух введённых строках.
# - Символы не должны повторяться в выводе.
# - Формат ввода
# - Вводится две строки.
# - Формат вывода
# - Требуется вывести все общие символы этих строк без повторений.
# - Порядок вывода не имеет значения.


# +
def symbolic_difference() -> None:
    """symbolic_difference."""
    data_1: set[str] = set(input())
    data_2: set[str] = set(input())
    intersection_word: set[str] = data_1 & data_2
    print(*intersection_word, sep="")


if __name__ == "__main__":
    symbolic_difference()


# -

# ## Зайка — 8.
#
# - Мы снова наблюдаем за движением поезда — и продолжаем собирать все объекты, которые попадаются в поле зрения.
# - Теперь ваша задача — собрать единый список всех увиденных объектов, независимо от того, в каких именно строках они встречались.
# - Формат ввода
# - В первой строке записано натуральное число N — количество выделенных придорожных местностей.
# - В каждой из N последующих строк записано описание придорожной местности.
# - Формат вывода
# - Вывести все найденные объекты в придорожных местностях.


# +
def bunny_8() -> None:
    """bunny_8."""
    count_plase: int = int(input())
    object_b: set[str] = set()
    for _ in range(count_plase):
        name_place: list[str] = input().split()
        object_b.update(name_place)
    sorted_object: list[str] = sorted(object_b)
    for obj in sorted_object:
        print(obj)


if __name__ == "__main__":
    bunny_8()


# -

# ## Кашееды.
#
# - В детском саду завели "кашевую статистику". Каждый ребёнок любит манную, овсяную или обе каши.Воспитателю важно быстро узнать, сколько детей обожают и ту, и другую кашу.
# - Напишите программу, которая определит, сколько учеников любят обе каши.
# - Формат ввода
# - В первых двух строках указывается количество детей, любящих манную и овсяную каши (N и M).
# - Затем идут N строк — фамилии детей, которые любят манную кашу, и M строк с фамилиями детей, любящих овсяную кашу.
# - Гарантируется, что в группе нет однофамильцев.
# - Формат вывода
# - Количество учеников, которые любят обе каши.
# - Если таких не окажется, в строке вывода нужно написать «Таких нет».


# +
def casheweds() -> None:
    """casheweds."""
    group_1: int = int(input())
    group_2: int = int(input())
    result_group_1: set[str] = set()
    result_group_2: set[str] = set()
    for _ in range(group_1):
        result_group_1.update(input().split())
    for _ in range(group_2):
        result_group_2.update(input().split())
    common_names: set[str] = result_group_1 & result_group_2
    if common_names:
        print(len(common_names))
    else:
        print("Таких нет")


if __name__ == "__main__":
    casheweds()


# -

# ## Кашееды — 2.
#
# - После статистики по «любителям обеих каш» воспитателю захотелось знать другое: сколько детей любят только одну кашу — либо манную, либо овсяную, но не обе сразу.Это поможет спланировать меню так, чтобы угодить каждому!
# - Формат ввода
# - В первых двух строках указывается количество детей, любящих манную и овсяную каши (N и M).
# - Затем идут N+M строк — перемешанные фамилии детей.
# - Гарантируется, что в группе нет однофамильцев.
# - Формат вывода
# - Количество учеников, которые любят только одну кашу.
# - Если таких не окажется, в строке вывода нужно написать «Таких нет».


# +
def casheweds_2() -> None:
    """casheweds_2."""
    n_cash: int = int(input())
    m_cash: int = int(input())
    name_count: dict[str, int] = {}
    for _ in range(n_cash + m_cash):
        name: str = input().strip()
        name_count[name] = name_count.get(name, 0) + 1
    count_only_one: int = 0
    for count in name_count.values():
        if count == 1:
            count_only_one += 1
    if count_only_one > 0:
        print(count_only_one)
    else:
        print("Таких нет")


if __name__ == "__main__":
    casheweds_2()


# -

# ## Кашееды — 3.
#
# - Мы уже посчитали, сколько детей любят только одну кашу. Теперь давайте выясним, кто именно это делает — и выведем их по алфавиту. Это поможет воспитателю персонально поблагодарить каждого за преданность любимому блюду.
# -  программу, которая позволит воспитателю узнать, какие дети любят только одну кашу.
# - Формат ввода
# - В первых двух строках указывается количество детей, любящих манную и овсяную каши (N и M).
# - Затем идут N+M строк — перемешанные фамилии детей.
# - Гарантируется, что в группе нет однофамильцев.
# - Формат вывода
# - В алфавитном порядке фамилии учеников, которые любят только одну кашу.
# - Если таких не окажется, в строке вывода нужно написать «Таких нет».


# +
def casheweds_3() -> None:
    """casheweds_3."""
    nc_cash: int = int(input())
    mc_cash: int = int(input())
    name_count: dict[str, int] = {}
    for _ in range(nc_cash + mc_cash):
        name: str = input().strip()
        name_count[name] = name_count.get(name, 0) + 1
    only_one_porridge: list[str] = sorted(
        [name for name, count in name_count.items() if count == 1]
    )
    if only_one_porridge:
        for name in only_one_porridge:
            print(name)
    else:
        print("Таких нет")


if __name__ == "__main__":
    casheweds_3()


# -

# ## Азбука Морзе.
#
# - Напишите программу, которая по введённому английскому тексту кодирует каждое слово в азбуке Морзе.Каждая буква заменяется на последовательность точек и тире. В качестве тире используйте обычный дефис: -, а в качестве точки — точку .. Например, буква g превратится в трёхсимвольную строку --.. Между закодированными буквами ставится ровно один пробел. Например, слово Help превратится в .... . .-.. .--..
# Обратите внимание, что строчные и заглавные буквы кодируются одинаково.
# - Формат ввода
# - Весь текст записан в единственной строке. Текст состоит из английских букв и пробелов, других символов в тексте нет.
# - В тексте не может быть двух или более пробелов подряд.
# - Формат вывода
# - Выведите каждое слово исходного текста, закодированное азбукой Морзе, на отдельной строке.
# - Количество строк в ответе должно совпадать с количеством слов в исходном тексте.


# +
def morse_code() -> None:
    """morse_code."""
    text: list[str] = input().split()
    words_pass: dict[str, str] = {
        "A": ".-",
        "B": "-...",
        "C": "-.-.",
        "D": "-..",
        "E": ".",
        "F": "..-.",
        "G": "--.",
        "H": "....",
        "I": "..",
        "J": ".---",
        "K": "-.-",
        "L": ".-..",
        "M": "--",
        "N": "-.",
        "O": "---",
        "P": ".--.",
        "Q": "--.-",
        "R": ".-.",
        "S": "...",
        "T": "-",
        "U": "..-",
        "V": "...-",
        "W": ".--",
        "X": "-..-",
        "Y": "-.--",
        "Z": "--..",
        "0": "-----",
        "1": ".----",
        "2": "..---",
        "3": "...--",
        "4": "....-",
        "5": ".....",
        "6": "-....",
        "7": "--...",
        "8": "---..",
        "9": "----.",
    }
    for word in text:
        morse_word: list[str] = []
        for char in word:
            upper_char: str = char.upper()
            if upper_char in words_pass:
                morse_word.append(words_pass[upper_char])
        print(" ".join(morse_word))


if __name__ == "__main__":
    morse_code()


# -

# ## Кашееды — 4.
#
# - Каждый воспитанник детского сада может любить одну или несколько каш. Воспитателю нужно быстро получить список фамилий тех, кто любит определённый вид каши.
# - Напишите программу, которая по списку учеников и их любимых каш определяет, кто именно любит заданную кашу.
# - Формат ввода
# - В первой строке задаётся количество детей в группе (N).
# - В следующих N строках записана фамилия ребенка и список его любимых каш.
# - В последней строке записана каша, информацию о которой хочет получить воспитатель.
# - Формат вывода
# - Фамилии учеников, которые любят заданную кашу, в алфавитном порядке.
# - Если таких не окажется, в строке вывода нужно написать «Таких нет».


# +
def casheweds_4() -> None:
    """casheweds_4."""
    count_children: int = int(input())
    children_porridge: dict[str, set[str]] = {}
    for _ in range(count_children):
        par: list[str] = input().split()
        surname: str = par[0]
        porriges: set[str] = set(par[1:])
        children_porridge[surname] = porriges
    target_porridge: str = input().strip()
    loving_porridge: list[str] = []
    for surname, porriges in children_porridge.items():
        if target_porridge in porriges:
            loving_porridge.append(surname)
    loving_porridge.sort()
    if loving_porridge:
        for surname in loving_porridge:
            print(surname)
    else:
        print("Таких нет")


if __name__ == "__main__":
    casheweds_4()


# -

# ## Зайка — 9.
#
# - Поможем детям подсчитать, сколько животных и деревьев каждого вида встречается за окном поезда.
# - Напишите программу, которая по текстовому описанию местности подсчитывает, сколько раз каждое слово встречается во входных данных.
# - Формат ввода
# - В каждой строке записано описание придорожной местности.
# - Конец ввода обозначается пустой строкой.
# - Формат вывода
# - Список увиденного и их количество.
# - Порядок вывода не имеет значения.


# +
def bunny_9() -> None:
    """bunny_9."""
    counter: dict[str, int] = {}
    while True:
        line_bu: str = input().strip()
        if line_bu == "":
            break
        words: list[str] = line_bu.split()
        for word in words:
            if word not in counter:
                counter[word] = 1
            else:
                counter[word] += 1
    for description, count in counter.items():
        print(f"{description} {count}")


if __name__ == "__main__":
    bunny_9()


# -

# ## Транслитерация.
#
# - Для международных документов русский текст преобразуется с использованием латинского алфавита. ГОСТ Р 52535.1-2006 задаёт правила   идентификационных карт.
# - Ниже приведена таблица замен:
# - А — A
# - Б — B
# - В — V
# - Г — G
# - Д — D
# - Е — E
# - Ё — E
# - Ж — ZH
# - З — Z
# - И — I
# - Й — I
# - К — K
# - Л — L
# - М — M
# - Н — N
# - О — O
# - П — P
# - Р — R
# - С — S
# - Т — T
# - У — U
# - Ф — F
# - Х — KH
# - Ц — TC
# - Ч — CH
# - Ш — SH
# - Щ — SHCH
# - Ы — Y
# - Э — E
# - Ю — IU
# - Я — IA
# - Давайте транслитерируем русский текст.
# - Букву «ё» транслитерируйте как «e», «й» как «и», а «ъ» и «ь» (и их заглавные версии «Ъ» и «Ь») должны исчезнуть из текста. Строчные буквы заменяются на строчные, заглавные заменяются на заглавные. Если заглавная буква превращается при транслитерации в несколько букв, то заглавной должна остаться только первая из них (например, «Ц» → «Tc»). Все некириллические символы должны остаться на месте.
# - Формат ввода
# - В единственной строке задан русский текст. Текст может состоять из любых символов. Вам необходимо транслитерировать только русские буквы, а остальные оставить на месте. Гарантируется, что нет слов, состоящих только из букв «ъ» и «ь».


# +
def transliteration() -> None:
    """transliteration."""
    translit_dict: dict[str, str] = {
        "А": "A",
        "Б": "B",
        "В": "V",
        "Г": "G",
        "Д": "D",
        "Е": "E",
        "Ё": "E",
        "Ж": "Zh",
        "З": "Z",
        "И": "I",
        "Й": "I",
        "К": "K",
        "Л": "L",
        "М": "M",
        "Н": "N",
        "О": "O",
        "П": "P",
        "Р": "R",
        "С": "S",
        "Т": "T",
        "У": "U",
        "Ф": "F",
        "Х": "Kh",
        "Ц": "Tc",
        "Ч": "Ch",
        "Ш": "Sh",
        "Щ": "Shch",
        "Ы": "Y",
        "Э": "E",
        "Ю": "Iu",
        "Я": "Ia",
        "а": "a",
        "б": "b",
        "в": "v",
        "г": "g",
        "д": "d",
        "е": "e",
        "ё": "e",
        "ж": "zh",
        "з": "z",
        "и": "i",
        "й": "i",
        "к": "k",
        "л": "l",
        "м": "m",
        "н": "n",
        "о": "o",
        "п": "p",
        "р": "r",
        "с": "s",
        "т": "t",
        "у": "u",
        "ф": "f",
        "х": "kh",
        "ц": "tc",
        "ч": "ch",
        "ш": "sh",
        "щ": "shch",
        "ы": "y",
        "э": "e",
        "ю": "iu",
        "я": "ia",
    }

    with open("cyrillic.txt", encoding="utf-8") as file:
        text: str = file.read()

    result_trans: list[str] = []
    for char in text:
        if char in translit_dict:
            replacement: str = translit_dict[char]
            if char.isupper() and len(replacement) > 1:
                replacement = replacement[0].upper() + replacement[1:].lower()
            result_trans.append(replacement)
        elif char in ["Ъ", "Ь", "ъ", "ь"]:
            continue
        else:
            result_trans.append(char)
    with open("transliteration.txt", "w", encoding="utf-8") as output_file:
        output_file.write("".join(result_trans))


if __name__ == "__main__":
    transliteration()


# -

# ## Однофамильцы.
#
# - Начальник кадровой службы хочет выяснить, сколько мужчин-однофамильцев работает в организации. У него есть список фамилий, и на его основании требуется определить количество сотрудников, чьи фамилии совпадают хотя бы с одной другой.
# - Напишите программу, которая по списку фамилий сотрудников подсчитывает общее число однофамильцев — то есть людей, чья фамилия в списке встречается более одного раза.
# - Формат ввода
# - В первой строке указывается количество мужчин — сотрудников организации (N).
# - Затем идут N строк с фамилиями этих сотрудников в произвольном порядке.
# - Формат вывода
# - Количество однофамильцев в организации.


# +
def namesakes() -> None:
    """namesakes."""
    coll_surname: int = int(input())
    counter: dict[str, int] = {}
    for _ in range(coll_surname):
        surname: str = input().strip()
        if surname in counter:
            counter[surname] += 1
        else:
            counter[surname] = 1
    total_namesakes: int = 0
    for count in counter.values():
        if count > 1:
            total_namesakes += count
    print(total_namesakes)


if __name__ == "__main__":
    namesakes()


# -

# ## Однофамильцы — 2.
#
# - Вновь поможем сотруднику отдела кадров выяснить, сколько мужчин-однофамильцев работает в организации — теперь с более подробным отчётом.
# - Напишите программу, которая по списку фамилий сотрудников выводит список всех однофамильцев (тех, чьи фамилии встречаются более одного раза), а также количество их повторений.
# - Формат ввода
# - В первой строке указывается количество мужчин — сотрудников организации (N).
# - Затем идут N строк с фамилиями этих сотрудников в произвольном порядке.
# - Формат вывода
# - Список однофамильцев в организации с указанием их количества в алфавитном порядке. Если таковых нет — вывести «Однофамильцев нет».


# +
def namesakes_2() -> None:
    """namesakes_2."""
    coll_surname: int = int(input())
    counter: dict[str, int] = {}
    for _ in range(coll_surname):
        surname: str = input().strip()
        if surname in counter:
            counter[surname] += 1
        else:
            counter[surname] = 1
    namesakes_lst: list[tuple[str, int]] = []
    for surname, count in counter.items():
        if count > 1:
            namesakes_lst.append((surname, count))
    namesakes_lst.sort()
    if namesakes_lst:
        for surname, count in namesakes_lst:
            print(f"{surname} - {count}")
    else:
        print("Однофамильцев нет")


if __name__ == "__main__":
    namesakes_2()


# -

# ## Дайте чего-нибудь новенького!
#
# - Главный повар детского сада готовит меню на праздник и хочет выбрать блюда, которые ни разу не подавались на этой неделе.
# - В его распоряжении есть список блюд:
#
# - которые можно приготовить в столовой сегодня;
# - которые были приготовлены в каждый из дней недели.
#
# - Напишите программу, которая по списку доступных сегодня блюд и истории приготовления на неделе определяет, что из этого можно приготовить нового.
# - Формат ввода
# - Число блюд (N), которые можно приготовить в столовой. N строк с названиями блюд.
# - Число дней (M), о которых имеется информация. M блоков строк для каждого из списков.
# - В первой строке каждого блока записано число блюд в заданный день, затем перечисляются эти блюда.
# - Формат вывода
# - Список блюд, которые ещё не готовились на этой неделе в алфавитном порядке.
# - Если все возможные блюда уже были приготовлены, следует вывести «Готовить нечего».


# +
def give_me_something_new() -> None:
    """give_me_something_new."""
    n_give: int = int(input())
    all_dishes: set[str] = set()
    for _ in range(n_give):
        dish: str = input().strip()
        all_dishes.add(dish)
    number_days: int = int(input())
    cooked_dishes: set[str] = set()
    for _ in range(number_days):
        k_give: int = int(input())
        for _ in range(k_give):
            dish_2: str = input().strip()
            cooked_dishes.add(dish_2)
    not_cooked: set[str] = all_dishes - cooked_dishes
    sot_result: list[str] = sorted(not_cooked)
    if sot_result:
        for dish in sot_result:
            print(dish)
    else:
        print("Готовить нечего")


if __name__ == "__main__":
    give_me_something_new()


# -

# ## Это будет шедевр!
#
# - Главный повар детского сада хочет быстрее определять, какие блюда можно приготовить на обед. У него есть список доступных продуктов и список рецептов.
# - Напишите программу, которая по списку имеющихся продуктов и рецептам определяет, какие блюда можно приготовить.
# - Формат ввода
# - Число продуктов (N), которые имеются в наличии. N строк с названиями продуктов.
# - Число рецептов (M), о которых имеется информация.M блоков строк для каждого из рецептов.
# - В первой строке каждого блока записано название блюда.
# - Во второй — число ингредиентов.
# - Затем перечисляются сами ингредиенты, требуемые для приготовления блюда.
# - Формат вывода
# - Список блюд, которые можно приготовить в алфавитном порядке.
# - Если ни одно из блюд нельзя приготовить, следует вывести «Готовить нечего».


# +
def masterpiece() -> None:
    """masterpiece."""
    num_product: int = int(input())
    all_product: set[str] = set()
    for _ in range(num_product):
        product: str = input().strip()
        all_product.add(product)
    number_recipes: int = int(input())
    cooked_dishes: list[str] = []
    for _ in range(number_recipes):
        name_dish: str = input().strip()
        number_ingred: int = int(input())
        ingredients: set[str] = set()
        for _ in range(number_ingred):
            ingredient: str = input().strip()
            ingredients.add(ingredient)
        if ingredients <= all_product:
            cooked_dishes.append(name_dish)
    cooked_dishes.sort()
    if cooked_dishes:
        for dish in cooked_dishes:
            print(dish)
    else:
        print("Готовить нечего")


if __name__ == "__main__":
    masterpiece()


# -

# ## Двоичная статистика!
#
# - У программистов особые отношения с двоичной системой счисления — ведь именно в ней работает вся цифровая техника. Продолжим тренировки в статистической обработке данных и научимся анализировать числа с позиции их представления в двоичной системе.
# - Напишите программу, которая по списку целых чисел определяет:
# - количество разрядов;
# - количество единиц;
# - количество нулей.
# - Формат ввода
# - Вводится последовательность чисел, записанных через пробел.
# - Формат вывода
# - Вывести список словарей с требуемой статистикой.
# - Примечание
# - Вывод в примерах отформатирован только для визуальной наглядности.
# - Все пробельные символы при проверке игнорируются.
# - Порядок словарей обязан совпадать с порядком переданных чисел.
# - Порядок ключей в словаре не имеет значения.


# +
def binary_statistics() -> None:
    """binary_statistics."""
    numbers: list[str] = input().split()
    result_bin: list[dict[str, int]] = []
    for num in numbers:
        binary_str: str = bin(int(num))[2:]
        digits: int = len(binary_str)
        units: int = binary_str.count("1")
        zeros: int = binary_str.count("0")
        stats: dict[str, int] = {"digits": digits, "units": units, "zeros": zeros}
        result_bin.append(stats)
    print("[")
    for i, stats in enumerate(result_bin):
        print("    {")
        print(f'        "digits": {stats["digits"]},')
        print(f'        "units": {stats["units"]},')
        print(f'        "zeros": {stats["zeros"]}')
        if i < len(result_bin) - 1:
            print("    },")
        else:
            print("    }")
    print("]")


if __name__ == "__main__":
    binary_statistics()


# -

# ## Зайка — 10.
#
# - Дети в поезде снова играют в любимую игру — считать зверей за окном. На этот раз их заинтересовало, что находится рядом с зайками. Поможем им разобраться!
# - Напишите программу, которая по описанию придорожной местности находит все объекты, стоящие рядом с зайками — слева или справа от слова зайка.
# - Формат ввода
# - В каждой записано описание придорожной местности.
# - Конец ввода обозначается пустой строкой.
# - Формат вывода
# - Определите список увиденного рядом с зайками без повторений.
# - Порядок вывода не имеет значения.
# - Примечание
# - Считается, что объект находится рядом, если он записан справа или слева от требуемого.


# +
def bunny_10() -> None:
    """bunny_10."""
    objects: set[str] = set()
    while True:
        line_string: str = input().strip()
        if line_string == "":
            break
        words: list[str] = line_string.split()
        for i, word in enumerate(words):
            if word == "зайка":
                if i > 0:
                    objects.add(words[i - 1])
                if i < len(words) - 1:
                    objects.add(words[i + 1])
    if objects:
        for obj in sorted(objects):
            print(obj)
    else:
        print("")


if __name__ == "__main__":
    bunny_10()


# -

# ## Друзья друзей.
#
# - Теория шести рукопожатий гласит, что любые два человека на планете могут быть связаны друг с другом через максимум шесть знакомых. Но мы не будем идти так далеко — давайте ограничимся двумя уровнями знакомства.
# - Напишите программу, которая по списку пар друзей для каждого человека определяет список его друзей второго уровня — то есть друзей его друзей, исключая его самого и его непосредственных друзей.
# - Формат ввода
# - В каждой строке записывается два имени.
# - Окончанием ввода служит пустая строка.
# - Формат вывода
# - Выведите список всех людей и их «друзей 2-го уровня» в формате «Человек: Друг1, Друг2, ...».
# - Список людей и друзей в каждой строке требуется вывести в алфавитном порядке без повторений.


# +
def friends_of_friends() -> None:
    """friends_of_friends."""


friends: dict[str, set[str]] = {}
while True:
    line: str = input().strip()
    if line == "":
        break
    person1: str
    person2: str
    person1, person2 = line.split()
    if person1 not in friends:
        friends[person1] = set()
    if person2 not in friends:
        friends[person2] = set()
    friends[person1].add(person2)
    friends[person2].add(person1)
sorted_people = sorted(friends.keys())
for person in sorted_people:
    second_level: set[str] = set()
    for friend in friends[person]:
        second_level.update(friends[friend])
    second_level.discard(person)
    for friend in friends[person]:
        second_level.discard(friend)
    sorted_second_level: list[str] = sorted(second_level)
    if sorted_second_level:
        result: str = ", ".join(sorted_second_level)
        print(f"{person}: {result}")
    else:
        print(f"{person}: ")


if __name__ == "__main__":
    friends_of_friends()


# -

# ## Карта сокровищ.
#
# -  На пиратской карте отмечено множество точек, в которых, по слухам, зарыты сокровища. Каждая точка задана координатами (xi,yi) в километрах. Капитан Крюк хочет собрать как можно больше кладов за один маршрут. Однако есть ограничение: между двумя соседними точками маршрута можно перемещаться только в том случае, если координаты этих точек различаются только последней цифрой — как по оси x, так и по оси y.
# - Например:
# - Из точки (15, 10) можно попасть в (18, 16) — координаты отличаются только последней цифрой (5 → 8 и 0 → 6). Но из (14, 68) в (19, 71) попасть нельзя, потому что десятки и сотни отличаются. Также нельзя попасть из (5, 12) в (13, 14), так как 5 и 13 различаются не только в последнем разряде. Напишите программу, которая по списку координат точек определяет, какое максимальное количество точек может входить в маршрут Капитана Крюка, построенный по описанному правилу.
# - Формат ввода
# - В первой строке указано число N(1≤N≤10**5) — количество точек, отмеченных на карте сокровищ.
# - В следующих N строках содержатся пары координат: xi и yi — координаты i-ой точки.
# - Координаты — целые числа не меньше нуля и не больше 10**9.
# - Гарантируется, что совпадающих точек в списке нет.
# - Формат вывода
# - Выведите одно число — максимальное количество точек, которое Капитан Крюк сможет посетить по маршруту, построенному по описанным правилам.


# +
def treasure_map() -> None:
    """treasure_map."""
    n_map: int = int(input())
    groups: dict[tuple[int, int], int] = {}
    for _ in range(n_map):
        x_map, y_map = map(int, input().split())
        group_x: int = x_map // 10
        group_y: int = y_map // 10
        group_key: tuple[int, int] = (group_x, group_y)
        if group_key not in groups:
            groups[group_key] = 0
        groups[group_key] += 1
    max_count: int = 0
    for count in groups.values():
        max_count = max(max_count, count)
    print(max_count)


if __name__ == "__main__":
    treasure_map()


# -

# ## Частная собственность.
#
# - Ребята приносят игрушки в детский сад и играют все вместе. Сегодня они решили выяснить, игрушки какого типа принадлежат только одному из детей.
# - Напишите программу, которая по списку детей и их игрушек определяет список игрушек, которые есть только у одного ребёнка. Выведите их в алфавитном порядке.
# - Формат ввода
# - В первой строке задается количество детей в группе (N).
# - В каждой из следующих N строк записано имя ребенка и его игрушки в формате:
# - Имя: игрушка1, игрушка2, ....
# - Формат вывода
# - Список игрушек, которые есть только у одного из детей в алфавитном порядке.


# +
def private_property() -> None:
    """private_property."""
    n_private: int = int(input())
    toy_to_children: dict[str, set[str]] = {}
    for _ in range(n_private):
        line_str: str = input().strip()
        parts: list[str] = line_str.split(": ")
        name: str = parts[0]
        toys: list[str] = parts[1].split(", ")
        for toy in toys:
            toy = toy.strip()
            if toy not in toy_to_children:
                toy_to_children[toy] = set()
            toy_to_children[toy].add(name)
    unique_toys: list[str] = []
    for toy, children in toy_to_children.items():
        if len(children) == 1:
            unique_toys.append(toy)
    unique_toys.sort()
    for toy in unique_toys:
        print(toy)


if __name__ == "__main__":
    private_property()


# -

# ## Простая задача 4.0.
#
# - Вы проделали отличную работу и дошли до конца — впереди последняя, двадцатая задача. Она не простая, но вы уже вооружены знаниями о множествах, словарях и алгоритмах.
# - Напомним, что взаимно простыми называются числа, которые не имеют общих делителей, кроме 1.
# - Напишите программу, которая:
# - получает список чисел, разделённых точкой с запятой и пробелом;
# - для каждого числа определяет, с какими другими числами оно взаимно просто;
# - выводит результат в порядке возрастания чисел без повторений;
# - если для числа не найдено ни одного взаимно простого числа — его не нужно выводить вовсе.
# - Формат ввода
# - Задана последовательность чисел записанных через точку с запятой (;) и пробел.
# - Формат вывода
# - Список чисел с указанием взаимно простых ему среди переданных.
# - Все числа должны быть выведены в порядке возрастания без повторений.
# - Строки следует отформатировать по правилу: число - взаимно простое 1, взаимно простое 2, ...
# - Если для числа не было найдено ни одного взаимно простого, то и выводить его не требуется.


def simple_task_4() -> None:
    """simple_task_4."""
    input_string: str = input().strip()
    if input_string.endswith("."):
        input_string = input_string[:-1]
    numbers: list[int] = list(map(int, input_string.split("; ")))
    unique_numers: list[int] = sorted(set(numbers))
    coprime_dict: dict[int, list[int]] = {}
    for i_simple, a_simple in enumerate(unique_numers):
        for j_simple in range(i_simple + 1, len(unique_numers)):
            b_simple: int = unique_numers[j_simple]
            num_1: int = a_simple
            num_2: int = b_simple
            while num_2 != 0:
                num_1, num_2 = num_2, num_1 % num_2

            if num_1 == 1:
                if a_simple not in coprime_dict:
                    coprime_dict[a_simple] = []
                coprime_dict[a_simple].append(b_simple)
                if b_simple not in coprime_dict:
                    coprime_dict[b_simple] = []
                coprime_dict[b_simple].append(a_simple)

    for num, coprime_list in coprime_dict.items():
        coprime_list.sort()
    for num, coprime_list in sorted(coprime_dict.items()):
        result_string: str = ", ".join(map(str, coprime_list))
        print(f"{num} - {result_string}")
