"""Модули math и numpy.

В этом параграфе вы познакомитесь с двумя важными библиотеками, которые помогут вам решать
математические задачи в Python быстро и эффективно. Вы узнаете, какие функции
предоставляет стандартный модуль math и почему модуль numpy считается основой для научных
вычислений на Python. Разберётесь, как создавать и использовать массивы, выполнять
операции над ними, и оцените, насколько numpy быстрее стандартных средств языка.
"""

# ## Математика — круто, но это не точно.
#
# - Давайте вспомним начало нашего задачника, когда всё было просто: мы не использовали ни циклы, ни коллекции, ни объектно-ориентированное программирование. Перед нами были только входные данные и требовалось предоставить результат.
# - Напишите программу, которая вычисляет значение функции:
#
# ![image.png](attachment:image.png)
#
# - Формат ввода
# - Вводится действительное число x
# - Формат вывода
# - Одно число — значение функции в заданной точке.

# +
import math
import sys

import numpy as np

# mypy: ignore-errors
x_: float = float(input())

ansver1: float = math.log(math.pow(x_, 3 / 16), 32)
ansver2: float = math.pow(x_, math.cos((math.pi * x_) / (2 * math.e)))
ansver3: float = math.pow(math.sin(x_ / math.pi), 2)

numb_ansver: float = ansver1 + ansver2 - ansver3
print(numb_ansver)
# -

# ## Потоковый НОД.
#
# - Напишите программу, находящую наибольшие общие делители для всех переданных в стандартный поток последовательностей чисел.
# - Формат ввода
# - Вводятся строки чисел, разделённых пробелами.
# - Формат вывода
# - Последовательность чисел — наибольшие общие делители всех последовательностей.

for row in sys.stdin:
    res: list[int] = list(map(int, row.split()))
    if len(res) == 0:
        continue
    result_: int
    if len(res) == 1:
        result_ = res[0]
    else:
        result_ = res[0]
        for num in res[1:]:
            result_ = math.gcd(result_, num)
    print(result_)

# ## Есть варианты?
#
# - Вася пришёл на образовательный семинар и обнаружил, что зрителей на мероприятии — N, а количество мест — M.
# - Помогите Васе определить вероятность того, что он попадёт на семинар.
# - Формат ввода
# - Два числа N и M.
# - Формат вывода
# - Два числа — количество вариантов, в которых Вася попадает на семинар и количество всех вариантов групп на семинаре.

# +
plase_1: int
plase_2: int
plase_1, plase_2 = map(int, input().split())

favorable: int = math.comb(plase_1 - 1, plase_2 - 1)
total: int = math.comb(plase_1, plase_2)

print(favorable, total)
# -

# ## Среднее не арифметическое.
#
# - Средним геометрическим нескольких положительных вещественных чисел называют такое число, которым можно заменить каждое из этих чисел так, чтобы их произведение не изменилось.
# - Формат ввода
# - Вводится последовательность рациональных чисел, разделённых пробелами.
# - Формат вывода
# - Одно число — среднее геометрическое переданных чисел.

number: list[float] = list(map(float, input().split()))
n_: int = len(number)
result: float = math.prod(number) ** (1 / n_)
print(result)

# ## Шаг навстречу.
#
# - Два выдуманных человечка Дека и Поля, пользуются каждый своей системой координат. Деке нравится представлять себя в декартовом пространстве, а Поле — в полярном.
# - Напишите программу, определяющую кротчайшее расстояние, которое нужно пройти Деке и Поле, чтобы встретиться.
# - Формат ввода
# - В первой строке записаны координаты Деки: два рациональных числа — x и y
# - Во второй строке записаны координаты Поли: два рациональных числа — ρ и ϕ
# - Формат вывода
# - Одно число — расстояние между Декой и Полей.
# - Примечание
# - Дека и Поля живут на одной плоскости с общим центром.
# - ϕ — измеряется в радианах.

# +
fx_1: float
fx_2: float
fx_1, fx_2 = map(float, input().split())

pol_1: float
pol_2: float
pol_1, pol_2 = map(float, input().split())

px_1: float = pol_1 * math.cos(pol_2)
px_2: float = pol_1 * math.sin(pol_2)

distance: float = math.sqrt((px_1 - fx_1) ** 2 + (px_2 - fx_2) ** 2)
print(distance)


# -

# ## Матрица умножения.
#
# - Напишите функцию multiplication_matrix, которая принимает размер матрицы (N) и возвращает массив описывающий таблицу умножения N на N.
# - Примечание
# - Ваше решение должно содержать только функции.
# - В решении не должно быть вызовов требуемых функций.


def multiplication_matrix(n_2: int) -> np.ndarray:
    """Функция создает матрицу умножения чисел от 1 до n."""
    numbers: np.ndarray = np.arange(1, n_2 + 1)
    matrix_table: np.ndarray = np.outer(numbers, numbers)
    return matrix_table


# ## Шахматная подготовка.
#
# - Представьте, что вы пишете компьютерную игру «Шахматы». Вам надо смоделировать шахматную доску, которая представляет собой матрицу. Чёрная клетка представляется нулём, а белая — единицей. Если смотреть на доску сверху, то левая верхняя клетка — белая.
# - Напишите функцию make_board, которая принимает размер шахматной доски, и возвращает матрицу, моделирующую заданную доску.
# - Установите тип элементов матрицы int8.
# - Примечание
# - Ваше решение должно содержать только функции.
# - В решении не должно быть вызовов требуемых функций.


def make_board(n_3: int) -> np.ndarray:
    """Создает шахматную доску n×n."""
    num_: np.ndarray = np.zeros((n_3, n_3), dtype=np.int8)
    num_[::2, ::2] = 1
    num_[1::2, 1::2] = 1
    return num_


# ## Числовая змейка 3.0.
#
# - Когда-то вы помогали детсадовцам с различными змейками. Давайте реализуем её на основе массивов.
# - Напишите функцию snake, которая принимает ширину (M) и высоту (N) змейки, а также именованный параметр direction.
# -  Параметр direction могут принимать значения:
# - H — горизонтальная змейка, используется по умолчанию;
# - V — вертикальная змейка.
# - Функция должна вернуть матрицу, представляющую змейку, с ячейками типа int16.
# - Примечание
# - Ваше решение должно содержать только функции.
# - В решении не должно быть вызовов требуемых функций.


def snake(m_snake: int, n_snake: int, direction: str = "H") -> np.ndarray:
    """Создает матрицу-змейку заполненную числами по порядку."""
    matrix: np.ndarray = np.zeros((n_snake, m_snake), dtype=np.int16)

    if direction == "H":
        for i in range(n_snake):
            start: int = i * m_snake + 1
            if i % 2 == 0:
                matrix[i] = np.arange(start, start + m_snake)
            else:
                matrix[i] = np.arange(start + m_snake - 1, start - 1, -1)
    elif direction == "V":
        for j_ in range(m_snake):
            if j_ % 2 == 0:
                matrix[:, j_] = np.arange(j_ * n_snake + 1, (j_ + 1) * n_snake + 1)
            else:
                matrix[:, j_] = np.arange((j_ + 1) * n_snake, j_ * n_snake, -1)
    return matrix


# ## Вращение.
#
# - Напишите функцию rotate, принимающую двумерную матрицу и один из углов поворота: 90°, 180°, 270° и 360°.
# - Функция должна вернуть новую матрицу соответствующую заданному повороту по часовой стрелке.
# - Примечание
# - Ваше решение должно содержать только функции.
# - В решении не должно быть вызовов требуемых функций.


def rotate(matrix: np.ndarray, angle: int) -> np.ndarray:
    """Поворачивает матрицу на заданный угол."""
    if angle == 90:
        result_90: np.ndarray = np.rot90(matrix, 3)
        return result_90
    if angle == 180:
        result_180: np.ndarray = np.rot90(matrix, 2)
        return result_180
    if angle == 270:
        result_270: np.ndarray = np.rot90(matrix, 1)
        return result_270
    if angle == 360:
        result_360: np.ndarray = matrix.copy()
        return result_360
    raise ValueError("Угол должен быть 90, 180, 270 или 360 градусов")


# ## Лесенка.
#
# - Напишите функцию stairs, принимающую вектор и возвращающую матрицу, в которой каждая строка является копией вектора со смещением.
# - Примечание
# - Ваше решение должно содержать только функции.
# - В решении не должно быть вызовов требуемых функций.


def stairs(a_stairs: np.ndarray) -> np.ndarray:
    """Создает матрицу со сдвинутыми строками."""
    n_stairs: int = len(a_stairs)
    matrix: np.ndarray = np.tile(a_stairs, (n_stairs, 1))
    for i in range(n_stairs):
        matrix[i, :] = np.roll(matrix[i, :], i)
    return matrix
