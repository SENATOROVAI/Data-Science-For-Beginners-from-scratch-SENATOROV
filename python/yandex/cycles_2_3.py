"""2.3. Циклы.

В этом параграфе мы научимся выполнять одни и те же действия
многократно с помощью циклов while и for. Вы узнаете, как
устроены циклы в Python, когда использовать каждый из них,
и как сделать код компактнее с помощью новых возможностей языка.
"""

# ## 1.Раз, два, три! Ёлочка, гори!
# - В этом параграфе мы изучили циклы, а значит, пришло время закрепить их на практике. Начнем с цикла while.
# - На новогоднем утреннике в детском саду дети должны прокричать «Три!», чтобы зажглась ёлочка. Но с порядком чисел у них пока сложности – они выкрикивают всё подряд.
# - Ваша задача — написать программу, которая ждёт правильный крик и только после этого зажигает ёлочку.
# - Формат ввода
# - Вводятся крики детей.
# - Формат вывода
# - Требуется выводить "Режим ожидания...", пока дети не прокричат "Три!".
# - В конце вывести "Ёлочка, гори!"


# +
def herringbone() -> None:
    """herringbone."""
    while True:
        noise_children: str = input()
        if noise_children == "Три!":
            break
        print("Режим ожидания...")
    print("Ёлочка, гори!")


if __name__ == "__main__":
    herringbone()


# -

# ## 2.Зайка — 3
# - Долгая поездка в поезде — испытание для родителей. Чтобы дети не скучали, они играют в поиск зверушек в придорожной растительности. Давайте присоединимся к этой игре и посчитаем, в скольких строках встречается зайка!
# - А поможет вам в этом цикл while.
# - Формат ввода
# - Вводятся строки описывающие придорожную местность.
# - В конце поездки вводится "Приехали!"
# - Формат вывода
# - Количество строк в которых есть зайка.


# +
def rabbit_three() -> None:
    """rabbit_four."""
    count_rabbit: int = 0
    string_count: str
    while (string_count := input()) != "Приехали!":
        if "зайка" in string_count:
            count_rabbit += 1
    print(count_rabbit)


if __name__ == "__main__":
    rabbit_three()


# -

# ## 3.Считалочка
# - Давайте поможем ребятам в детском саду выучить числа! Они называют два числа — начало и конец последовательности, а мы выводим все числа между ними.
# - Используйте для этого цикл for.
# - Формат ввода
# - Два числа в порядке возрастания, каждое с новой строки.
# - Формат вывода
# - Все числа от начала до конца (включительно), записанные через пробел.


# +
def counting_rhyme() -> None:
    """counting_rhyme."""
    start_num: int = int(input())
    finish_num: int = int(input())
    for number in range(start_num, finish_num + 1):
        print(number, end=" ")


if __name__ == "__main__":
    counting_rhyme()


# -

# ## 4.Считалочка 2.0
# - Продолжаем помогать ребятам в детском саду учить числа и тренируем работу с циклами!
# - Теперь числа могут называться в любом порядке — от меньшего к большему или от большего к меньшему.
# - Ваша задача — вывести все числа от начала до конца в правильном порядке.
# - Формат ввода
# - Два числа, каждое с новой строки.
# - Формат вывода
# - Все числа от начала до конца (включительно), записанные через пробел.


# +
def counting_rhyme_2() -> None:
    """counting_rhyme_2."""
    start: int = int(input())
    finish: int = int(input())
    if start <= finish:
        for number_first in range(start, finish + 1):
            print(number_first, end=" ")
    else:
        for number_first in range(start, finish - 1, -1):
            print(number_first, end=" ")


if __name__ == "__main__":
    counting_rhyme_2()


# -

# ## 5.Внимание! Акция!
# - Добавим к циклу while работу с дробными числами?
# - В продуктовом магазине объявили акцию:
# - скидка 10% на все товары, которые стоят 500 тугриков и больше.
# - Вам нужно разработать программу для кассового автомата, которая считает итоговую сумму покупки с учётом скидки.
# - Формат ввода
# - Вводится некоторое количество рациональных чисел - стоимость товаров.
# - Список завершается значением 0.
# - Формат вывода
# - Требуется вывести сумму всех товаров с учетом объявленной акции.


# +
def promotion() -> None:
    """promotion."""
    result: float = 0.0
    price: float
    while price := float(input()):
        if price >= 500:
            price *= 0.9
        result += price
    print(result)


if __name__ == "__main__":
    promotion()


# -

# ## 6.НОД
# - В одном из местных НИИ очень часто требуется находить наибольший общий делитель двух чисел.
# - Т.к. вы уже зарекомендовали себя, как одни из лучших "автоматизаторов" в округе, руководство НИИ заказало данное ПО именно у вас.
# - Формат ввода
# - Вводится два натуральных числа, каждое на своей строке.
# - Формат вывода
# - Требуется вывести одно натуральное число – НОД двух данных чисел.
# - Примечание
# - Самый распространенный способ поиска НОД – Алгоритм Евклида.


# +
def greatest_common_divisor() -> None:
    """greatest_common_divisor."""
    a_number: int = int(input())
    b_number: int = int(input())
    while b_number:
        a_number, b_number = b_number, a_number % b_number
    print(a_number)


if __name__ == "__main__":
    greatest_common_divisor()


# -

# ## 7.НОК
# - В одном из местных НИИ часто требуется находить наименьшее общее кратное (НОК) двух чисел.
# - Так как вы уже зарекомендовали себя как лучшие "автоматизаторы", руководство доверило вам разработку этой программы.
# - Решите эту задачу, используя цикл while.
# - Формат ввода
# - Вводится два натуральных числа, каждое на своей строке.
# - Формат вывода
# - Требуется вывести одно натуральное число – НОК двух данных чисел.


# +
def least_common_multiple() -> None:
    """least_common_multiple."""
    a_numb: int = int(input())
    b_numb: int = int(input())
    x_numb: int = a_numb
    y_numb: int = b_numb
    while y_numb:
        x_numb, y_numb = y_numb, x_numb % y_numb
    nod: int = x_numb
    noc: int = abs(a_numb * b_numb) // nod
    print(noc)


if __name__ == "__main__":
    least_common_multiple()


# -

# ## 8.Излишняя автоматизация 2.0
# - Снова переходим к работе с циклом for.
# - "Повторение - мать учения!" и "Если это можно автоматизировать - автоматизируй!"
# - Этим принципам следуют очень многие программисты.
# - А что будет если их объединить?
# - Формат ввода
# - В первой строке записана весьма полезная информация. Во второй натуральное число
# N – количество раз, которое ее нужно повторить, чтобы она закрепилась.
# - Формат вывода N раз повторенная весьма полезная информация


# +
def excessive_typing() -> None:
    """excessive_typing."""
    input_string: str = input()
    count_string: int = int(input())
    for _ in range(count_string):
        print(input_string)


if __name__ == "__main__":
    excessive_typing()


# -

# ## 9.Факториал
# - В одном из местных НИИ регулярно требуется находить факториал числа.
# - Поскольку вы уже зарекомендовали себя, как одни из лучших "автоматизаторов" в округе, руководство НИИ доверило разработку этого ПО именно вам!
# - Решите эту задачу, используя цикл for.
# - Формат ввода
# - Вводится одно неотрицательное число.
# - Формат вывода
# - Требуется вывести одно натуральное число – факториал заданного числа.
# - Примечания
# - Факториал нуля принят равным 1.


# +
def factorial() -> None:
    """factorial."""
    number_fac = int(input())
    factorial_num: int = 1
    for i in range(number_fac):
        factorial_num = factorial_num * (i + 1)
    print(factorial_num)


if __name__ == "__main__":
    factorial()


# -

# ## 10.Маршрут построен
#
# - Навигация всегда была важна. Нам достался архив маршрутов движения, но их так много, что без автоматизации справиться с ними просто невозможно.
# - Каждый маршрут представляет собой последовательность шагов в одном из четырёх направлений:
# - СЕВЕР
# - ЮГ
# - ВОСТОК
# - ЗАПАД
# - Для формализации маршрутов была выбрана географическая система координат в которой две оси (СЕВЕР-ЮГ и ВОСТОК-ЗАПАД), а единичный отрезок по каждой из них равен одному шагу.
# - Напишите программу, которая по заданному маршруту определит, в какой именно точке мы очутимся, если изначально находимся в точке(0;0).
# - Формат ввода
# - Вводятся инструкции маршрута в виде:
# - <направление>
# - <количество шагов>
# - Ввод завершается строкой СТОП
# - Формат вывода
# - Два целых числа – координаты конечной точки маршрута.


# +
def route_planning() -> None:
    """route_planning."""
    x_step: int = 0
    y_steep: int = 0
    direction: str
    steps: int

    while (direction := str(input())) != "СТОП":
        steps = int(input())
        if direction == "СЕВЕР":
            y_steep += steps
        elif direction == "ЮГ":
            y_steep -= steps
        elif direction == "ВОСТОК":
            x_step += steps
        elif direction == "ЗАПАД":
            x_step -= steps
    print(y_steep)
    print(x_step)


if __name__ == "__main__":
    route_planning()


# -

# ## 11.Цифровая сумма
# - Многие люди любят манипуляции с цифрами чисел.
# - Одно из самых простых действий – найти сумму цифр числа.
# - Напишите программу, которая выполнит эту задачу.
# - Она поможет потренироваться в построении базовых алгоритмов с циклом while.
# - Формат ввода
# - Вводится одно натуральное число.
# - Формат вывода
# - Требуется вывести одно натуральное число – сумму цифр исходного.


# +
def sum_of_digits() -> None:
    """sum_of_digits."""
    numb_count: int = int(input())
    count_number: int = 0

    while numb_count > 0:
        count_number += numb_count % 10
        numb_count = numb_count // 10
    print(count_number)


if __name__ == "__main__":
    sum_of_digits()


# -

# ## 12.Сильная цифра
# - Мы продолжаем наши эксперименты с числами!
# - На этот раз нужно выполнить другое действие — найти максимальную цифру числа.
# - Напишите программу для выполнения этого действия.
# - Формат ввода
# - Вводится одно натуральное число.
# - Формат вывода
# - Требуется вывести одно натуральное число – максимальную цифру исходного.


# +
def strong_number() -> None:
    """strong_figure."""
    numb_simple: int = int(input())
    count_num: int = 0
    while numb_simple > 0:
        count_num = max(count_num, numb_simple % 10)
        numb_simple = numb_simple // 10
    print(count_num)


if __name__ == "__main__":
    strong_number()


# -

# ## 13.Первому игроку приготовиться 2.0
# - Время передохнуть! Если чувствуете усталость, сделайте короткий отдых и возвращайтесь, когда будете готовы.
# - Во многих играх порядок определяется броском кубика или монетки, а у нас — лексикографическим сравнением имён.
# - Первым ходит тот, чьё имя идёт раньше в алфавитном порядке.
# - Определите, кто из игроков начнёт игру, используя цикл for.
# - Формат ввода
# - В первой строке записано одно натуральное число N – количество игроков.
# - В каждой из последующих N строк записано одно имя игрока (используются только латинские и кириллические символы).
# - Формат вывода
# - Имя игрока, который будет ходить первым.


# +
def first_player_2() -> None:
    """first_player."""
    players: int = int(input())
    if players == 1:
        print(input())
    first_player: str = input()
    for _ in range(players - 1):
        name: str = input()
        first_player = min(first_player, name)
    print(first_player)


if __name__ == "__main__":
    first_player_2()


# -

# ## 14.Простая задача
# - Одним из самых интересных видов чисел в математике являются простые числа.
# - Они остаются загадкой для учёных по всему миру и продолжают изучаться.
# - Кроме того, простые числа находят применение в вычислительной технике — они лежат в основе алгоритмов шифрования данных.
# - Напишите программу, которая определяет, является ли число простым. Эта задача поможет вам потренироваться в построении базовых алгоритмов с циклом for.
# - Формат ввода
# - Вводится одно натуральное число.
# - Формат вывода
# - Требуется вывести сообщение "YES" если число простое, иначе – "NO".
# - Примечание
# - Простым называется число, которое имеет ровно два делителя.


# +
def simple_task() -> None:
    """simple_task."""
    number_task: int = int(input())
    if number_task < 2:
        print("NO")
    else:
        is_prime: bool = True
        for divisor in range(2, int(number_task**0.5) + 1):
            if number_task % divisor == 0:
                is_prime = False
                break
        print("YES" if is_prime else "NO")


if __name__ == "__main__":
    simple_task()


# -

# ## 15.Зайка - 4
# - Где зайки, там и циклы. На этот раз тренируемся использовать for.
# - Долгая поездка в поезде — испытание для родителей. Чтобы дети не скучали, они играют в поиск зверушек в придорожной растительности.
# - Давайте присоединимся к этой игре и посчитаем, в скольких строках встречается зайка!
# - Формат ввода
# - В первой строке записано натуральное число N – количество выделенных придорожных местностей. В каждой из N последующих строка записано описание придорожной местности.
# - Формат вывода
# - Количество строк в которых есть зайка.


# +
def rabbit_fore() -> None:
    """rabbit_fore."""
    n_rabbit: int = int(input())
    count: int = 0

    for _ in range(n_rabbit):
        line = input()
        if "зайка" in line:
            count += 1
    print(count)


if __name__ == "__main__":
    rabbit_fore()


# -

# ## 16.А роза упала на лапу Азора 2.0
# - Следующая задача достаточно сложная. Поэтому чуть-чуть отдыха не повредит. Выпейте чашку чая, отдохните, а затем продолжайте!
# - В прошлом параграфе мы уже решали задачу о нахождении палиндрома. Давайте вспомним её суть:
# - Палиндром — это число, слово или фраза, которые читаются одинаково слева направо и справа налево.
# - Напишите программу, которая проверяет, является ли заданное число палиндромом. В этот раз будем использовать цикл while.
# - Формат ввода
# - Одно натуральное число
# - Формат вывода
# - YES если число является палиндромом, иначе NO.


# +
def palindrome_word() -> None:
    """palindrome_word."""
    numb: str = input()
    length: int = len(numb)
    left: int = 0
    right: int = length - 1
    is_palindrome: bool = True
    while left < right:
        if numb[left] != numb[right]:
            is_palindrome = False
            break
        left += 1
        right -= 1
    print("YES" if is_palindrome else "NO")


if __name__ == "__main__":
    palindrome_word()


# -

# ## 17.Чётная чистота
# - Одно из интересных действий, которое можно совершить – очистить число от определённых цифр.
# - Напишите программу для очистки числа от всех чётных цифр, используя цикл while.
# - Формат ввода
# - Одно натуральное число
# - Формат вывода
# - Одно натуральное число - результат очистки.


# +
def clearing_numbers() -> None:
    """clearing_numbers."""
    count: int = int(input())
    numbers: str = ""
    while count > 0:
        numb: int = count % 10
        if numb % 2 != 0:
            numbers += str(numb)
        else:
            pass
        count = count // 10
    revers_numb: str = numbers[::-1]
    print(revers_numb)


if __name__ == "__main__":
    clearing_numbers()


# -

# ## 18.Простая задача 2.0
# - Математика, "простые числа" и цикл while.
# - "Простые числа" не поддаются формализации и до сих пор изучаются учеными по всему миру.
# - Они применяются в вычислительной техники, как основа для алгоритмов шифрования данных.
# - Напишите программу для разложения числа на простые множители.
# - Формат ввода
# - Вводится одно натуральное число.
# - Формат вывода
# - Требуется составить математическое выражение – произведение простых неубывающих чисел, которое в результате дает исходное.


# +
def simple_task_2() -> None:
    """simple_task_2."""
    numb: int = int(input())
    if numb == 1:
        print("1")
    else:
        numbers: str = ""
        count: int = 2
        while numb > 1:
            while numb % count == 0:
                if numbers:
                    numbers += " * " + str(count)
                else:
                    numbers = str(count)
                numb = numb // count
            count += 1
    print(numbers)


if __name__ == "__main__":
    simple_task_2()


# -

# ## 19.Игра в «Угадайку»
# - Многие люди любят играть в различные "Угадайки".
# - Давайте сымитируем такую игру между двумя людьми.
# - Ваша задача — написать программу, которая угадывает загаданное целое число от 1 до 1000 с использованием цикла while.
# - Пользователь (или тестирующая система) загадывает число и не сообщает его программе.
# - Угадать число нужно не более чем за 10 попыток.
# - На каждую попытку пользователь отвечает одной из фраз:
# - Больше
# - Меньше
# - Угадал!


# +
def guessing_game() -> None:
    """guessing_game."""
    a_num: int = 1
    b_num: int = 1001
    z_num: int = 500
    print(z_num)
    answer: str
    while (answer := input()) != "Угадал!":
        if answer == "Больше":
            a_num = z_num
            z_num = (a_num + b_num) // 2
            print(z_num)
        if answer == "Меньше":
            b_num = z_num
            z_num = (a_num + b_num) // 2
            print(z_num)
    print("Число отгадано")


if __name__ == "__main__":
    guessing_game()


# -

# ## 20.Хайпанём немножечко!
# - Блокчейн (blockchain) переводится как «цепочка блоков». Это способ хранения данных, защищённый от подделки, используемый, в частности, криптовалютой биткоин.
# - Блокчейн действительно представляет собой последовательность блоков. Каждый блок представляет собой некоторую полезную информацию (в частности, в случае биткоина это список транзакций за определённый период времени — кто кому когда сколько денег передал), снабжённую случайным числом и некоторыми служебными данными, в том числе хэшем — числом, которое по определённой формуле зависит от остальной части блока и хэша предыдущего блока.
# - Хэш должен быть меньше определённого числа. При этом формула, по которой вычисляется хэш, устроена так, что невозможно получить достаточно маленький хэш иначе, чем перебирая различные значения случайного числа. Поэтому если злоумышленник решит подделать блокчейн (и, допустим, вставить в его середину блок с записью о том, что все люди передают ему все свои деньги), то ему придётся подобрать новое случайное число в новое поддельном блоке и всех последующих (ведь хэш каждого следующего блока зависит от хэша предыдущего), что потребует невозможно больших вычислительных мощностей.
# - Поэтому блокчейн в целом защищён от подобных атак.
# - Напишите программу, которая проводит проверку правильности хэшей в модельном блокчейне с простой хэш-функцией.
# - Блок bn с номером n включает полезную информацию mn, представленную натуральным числом, r n — случайное число от 0 до 255 и hn — хеш (целое число от 0 до 255). У каждого блока хэш вычисляется по формуле hn=37×(mn+rn+hn−1)(по модулю 256), при вычислении хэша начального блока h0 вместо хэша предыдущего блока берётся ноль.
# - При этом каждый блок представлен одним числом bn=hn+rn×256+mn×256**2. При этом требуется, чтобы хэш hnбыл меньше 100.
# - Формат ввода
# - На первой строке вводится натуральное число N — количество блоков. Далее следуют N чисел bn, каждое на отдельной строке.
# - Формат вывода
# - Следует вывести номер первого блока, у которого неправильный хэш (не меньше 100 или не совпадает с вычисленным по указанной в условии формуле), или -1, если все хэши в блокчейне правильные. Нумерация блоков идёт с нуля, т. е. они имеют номера от 0 до N-1.


# +
def hype() -> None:
    """hype."""
    quantity: int = int(input())
    previous_hash: int = 0
    err: int = 0
    is_err: bool = False

    for i in range(quantity):
        block: int = int(input())
        hash_value: int = block % 256
        r_numb: int = (block // 256) % 256
        m_numb: int = block // 256**2
        calculated_hash: int = (37 * (m_numb + r_numb + previous_hash)) % 256
        if calculated_hash != hash_value or calculated_hash >= 100:
            if is_err is False:
                err = i
                is_err = True
        previous_hash = hash_value
    if is_err is False:
        print(-1)
    else:
        print(err)


if __name__ == "__main__":
    hype()
