"""3.3. Списочные выражения. Модель памяти для типов языка Python."""

# - научитесь компактно создавать и фильтровать списки с помощью списочных выражений,
# узнаете, как работают генераторы и в чём их преимущество по сравнению со списками.
# - разберётесь, как Python хранит переменные в памяти,
# - чем изменяемые объекты отличаются от неизменяемых — и почему это важно при написании кода

# списочные выражения - более лаконичный способ создавать списки
#
# ![image.png](attachment:image.png)

# Списочные выражения и генераторные выражения (генераторы) в Python - это два способа создания последовательностей данных, но они отличаются по принципу работы и применению. Списочные выражения создают и хранят весь список в памяти, в то время как генераторы вычисляют значения по одному по мере необходимости, что экономит память, особенно при работе с большими объемами данных.
#
# Списочные выражения (List Comprehensions):
# Краткий синтаксис для создания списков на основе других итерируемых объектов.
# Вычисляют все элементы списка сразу и хранят их в памяти.
# Удобны для небольших списков, когда требуется весь результат сразу.
# Пример: squares = [x**2 for x in range(10)] создаст список [0, 1, 4, 9, 16, 25, 36, 49, 64, 81].
# Генераторные выражения (Generator Expressions):
# Создают итератор (генератор), который вычисляет значения по одному.
# Экономят память, так как значения вычисляются по мере необходимости, а не все сразу.
# Подходят для больших списков или бесконечных последовательностей.
# Пример: squares_gen = (x**2 for x in range(10)) создаст генератор, который при каждом обращении будет возвращать квадрат числа.
# Чтобы получить значения из генератора, нужно использовать его в цикле, например:
#
# ```python
# for square in squares_gen:
#     print(square)
# ```
# или применить функцию, которая принимает итераторы, например list()

# +
# поверхностная
import copy

squares_gen = (x**2 for x in range(10))
print(
    list(squares_gen)
)  # не принтует так как не хранит в памяти, пока не применить цикл для вывода или список
# -

# ### Изменяемые и неизменяемые типы
# Неизменяемые типы: int, float, str, tuple, frozenset.
# Изменяемые типы: list, set, dict.
#
# ![image.png](attachment:image.png)
#
# ![image-2.png](attachment:image-2.png)
#
# ### Как создать настоящую копию вложенного списка
#
# is - проверка на id
# == - это просто равенство содержимого
#
# ![image-3.png](attachment:image-3.png)
#
# ![image-4.png](attachment:image-4.png)

# В Python различают глубокую (deep) и поверхностную (shallow) копии объектов. Разница между ними заключается в том, как они обрабатывают вложенные (составные) объекты.
# поверхностная - используют copy.copy(original) или срезы - независимым становится только внешний список, а внутренний все такде зависим от ссылки
# глубокая - copy.deepcopy(original) - полная независимость копии.

# +
original = [[1, 2, 3], [4, 5, 6]]
sliced_copy = original[:]  # срез → поверхностная копия

# независим внешний список, потому меняется
# sliced_copy[0] = [0, 0, 0]
# print(sliced_copy)

# зависим вложенный цикл
# Изменение вложенного списка повлияет на оригинал!
sliced_copy[0][0] = 99

print(original)  # [[99, 2, 3], [4, 5, 6]] → изменился!
print(sliced_copy)  # [[99, 2, 3], [4, 5, 6]]

# +
# глубокая
original = [[1, 2, 3], [4, 5, 6]]
deep_copy = copy.deepcopy(original)

# Изменение вложенного списка в копии НЕ влияет на оригинал
deep_copy[0][0] = 99

print(original)  # [[1, 2, 3], [4, 5, 6]]  → не изменился!
print(deep_copy)  # [[99, 2, 3], [4, 5, 6]]
# -

# #### Задание 1 (Список квадратов)
# [number ** 2 for number in range(a, b + 1)]

# #### Задание 2 (Список квадратов 2)
# [x1 ** 2 for x1 in (range(a, b + 1) if a <= b else range(a, b - 1, -1))]

# #### Задание 3 (Основы фильтрации)
# [x2 for x2 in (range(a, b + 1) if a <= b else range(a, b - 1, -1)) if x2 % d == 0]

# #### Задание 4 (Множество нечетных чисел)
# {x2 for x2 in numbers if x2 % 2 == 1}

# #### Задание 5 (Множество всех полных квадратов)
# {number for number in numbers if number == int(number ** 0.5) ** 2}

# #### Задание 6 (Длины всех слов)
# [len(word) for word in sentence.split()]

# #### Задание 7 (Цифровая выжимка)
# ''.join(let for let in text if let.isdigit())

# #### Задание 8 (Аббревиатура)
# ''.join([s1[0].upper() for s1 in string.split()])

# #### Задание 9 (Преобразование в строку)
# " - ".join(str(i) for i in sorted({number for number in numbers}))

# #### Задание 10 (Огласите список)
# [word for word in words.split() if sum(len(letter) for letter in word if letter.lower() in "аяуюоёэеиыaeiouy") >= 3]

# #### Задание 11 (Выявление уникальности)
# {i2 for i2 in numbers if numbers.count(i2) == 1}

# #### Задание 12 (Максимальное произведение)
# max([first * second for first in numbers for second in numbers if first != second])

# #### Задание 13 (Словарный минимум)
# min([(sum(number), word) for word, number in data.items()])[1]

# #### Задание 14 (Поиск ошибок)
# {word for word, number in data.items() if len(number) > len(set(number))}

# #### Задание 15 (Буквенная статистика)
# dict(sorted({t1: text.lower().count(t1) for t1 in text.lower() if t1.isalpha()}.items()))
#
#
# <!-- # dict(sorted(my_dict.items()))
# # как сортировать словарь по ключу
# # my_dict.items() возвращает список кортежей вида [(ключ, значение), (ключ, значение), ...]
# # sorted() сортирует этот список кортежей по ключам (первому элементу кортежа)
# # dict() преобразует отсортированный список кортежей обратно в словарь. -->

# #### Задание 16 (RLE наоборот)
# "".join([tup[0] * tup[1] for tup in rle])

# #### Задание 17 (Таблица умножения 2.0)
# [[i3 * j3 for i3 in range(1, n + 1)] for j3 in range(1, n + 1)]

# #### Задание 18 (Делители)
# {num: [i for i in range(1, num + 1) if num % i == 0] for num in numbers}
#
# <!-- # Внешний {num: ... for num in numbers} — создаёт словарь, где ключом является число из numbers.
#
# # Внутренний [i for i in range(1, num + 1) if num % i == 0] — для каждого числа num находит все его делители -->

# #### Задание 19 (Простое множество)
# {num for num in numbers if all(num % i != 0 for i in range(2, int(num ** 0.5) + 1)) and num > 1}

# #### Задание 20 (Обобщение)
# {
#     tuple(sorted((w1, w2)))
#     for w1 in text.split()
#     for w2 in text.split()
#     if w1 < w2 and len(set(w1) & set(w2)) > 2
# }
