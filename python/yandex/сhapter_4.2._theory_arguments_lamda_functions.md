1.
map(функция, итерируемый объект) - применяет ко всем
filter(функция, итерируемый объект) - отбирает несколько

map(), filter() выдают подобные вещи <filter object at 0x0000026E05C71690>, т.е. выдают значения только при запросе

reduce(функция, итерируемый объект)




2.
позиционные - 
примеры 
def add_value(x, list_arg) - при вызове функции заполнение аргументов по порядку
именованные - 
примеры
print(final_price(1000, discount=5))
print(final_price(discount=10, price=1000))

Обратите внимание: позиционные аргументы всегда должны идти первыми, а именованные — после них.




3.
```python
# проблема изменяемого типа значения по умолчанию
def add_value(x, list_arg=[]):
    list_arg += [x]
    return list_arg

print(add_value(0))
print(add_value(0, [1, 2, 3]))
print(add_value(1))  # list_arg снова берётся по умолчанию, но теперь это [0] (изменённый в первом вызове!).

# список по умолчанию сохраняет изменения между вызовами, потому что он создаётся один раз при определении функции (т.е. один раз создался, и изменения присваиваются к нему же)

# Вывод программы:
# [0]
# [1, 2, 3, 0]
# [0, 1]

```




4.
```python
# Чтобы избежать таких ошибок, принято использовать None и создавать новый список внутри функции:

def add_value(x, list_arg=None):
    if list_arg is None:
        list_arg = []
    list_arg += [x]
    return list_arg

print(add_value(0))
print(add_value(0, [1, 2, 3]))
print(add_value(1))

# Теперь каждый вызов работает независимо, и никакие старые значения не сохраняются.
```




5.
### Как функция может принимать произвольное количество аргументов с помощью *args и **kwargs


#### Позиционные аргументы: *args


```python
# чтобы посчитать сразу несколько 
def final_price(*prices, discount=1):
    return [price - price * discount / 100 for price in prices]

print(final_price(100, 200, 300, discount=5))

# Вывод программы:
# [95.0, 190.0, 285.0]
```


#### Именованные аргументы: **kwargs


Такой параметр внутри функции представляет собой **словарь**, в котором:

ключи — это имена переданных аргументов;
значения — это их соответствующие значения.

!!! поэтому когда работаем с kwargs, мы можем использовать kwargs.items()

Допустим, мы хотим добавить в функцию final_price() фильтр: рассчитывать скидку только для цен в определённом диапазоне. Границы диапазона (price_low и price_high) передаются как именованные аргументы через **kwargs.


```python
def final_price(*prices, discount=1, **kwargs):
    low = kwargs.get("price_low", min(prices))  # если аргумент price_low не установлен, то вычисляется минимальное
    high = kwargs.get("price_high", max(prices))
    return [price - price * discount / 100 for price in prices if low <= price <= high]

print(final_price(100, 200, 300, 400, 500, discount=5))
print(final_price(100, 200, 300, 400, 500, discount=5, price_low=200))
print(final_price(100, 200, 300, 400, 500, discount=5, price_high=200))
print(final_price(100, 200, 300, 400, 500, discount=5, price_low=200, price_high=350))

# Вывод программы:

# [95.0, 190.0, 285.0, 380.0, 475.0]
# [190.0, 285.0, 380.0, 475.0]
# [95.0, 190.0]
# [190.0, 285.0]

# высчитывает только те, что в диапазоне, и остальные не выводит
```
![image.png](attachment:image.png)

т.е. в мы можем добавить дополнительные устойчивые аргументы, которые будут использоваться
6.
### Что такое функции высших порядков и как передавать функции как аргументы

Функции, которые принимают другие функции как аргументы, называют функциями высшего порядка.


7.
#### Функция filter()

позволяет отобрать элементы из итерируемого объекта по заданному критерию. 

В качестве критерия передаётся функция, возвращающая логическое значение (True или False). 

Результат filter() — это итератор, содержащий только те элементы, для которых функция-критерий вернула True.

```python
# Пример: отбираем из списка только положительные числа.
def only_pos(x):
    return x > 0

result = filter(only_pos, [-1, 5, 6, -10, 0])
print(", ".join(str(x) for x in result))

# 5, 6
```
```python
# Можно использовать не только пользовательские функции, но и встроенные методы Python, если они соответствуют условиям: принимают нужный тип данных и возвращают логическое значение.

result = filter(lambda x: x.isalpha(), "123ABcd()")
print("".join(result))
# ABcd
```



8.
#### Функция map()

позволяет преобразовать каждый элемент итерируемого объекта с помощью заданной функции. Она возвращает итератор, в котором каждый элемент — результат применения функции-обработчика.
```python
# Пример: возводим в квадрат все числа из диапазона.

def square(x):
    return x ** 2

result = map(square, range(5))
print(", ".join(str(x) for x in result))
# 0, 1, 4, 9, 16
```
```python
# в map() можно также передавать встроенные функции и методы.
result = map(str.lower, ["abCD", "EFGh", "IJkl"])
print("\n".join(result))
# abcd
# efgh
# ijkl
```
9.
### Как устроены лямбда-функции и когда их удобно применять в Python

как небольшая функция в качестве аргумента, например, в map() или filter()
```python
lambda x: x > 0
```

```python
# Использование в filter() и map()
result = filter(lambda x: x > 0, [-1, 5, 6, -10, 0])
print(", ".join(str(x) for x in result))


result = (map(lambda x: x ** 2, range(5)))  # возвращает итератор (т.е. не будет никакого списка или кортежа. Для этого нужно указать как преобразовать)
print(", ".join(str(x) for x in result))
```


10.
#### Сортировка с помощью sorted() и лямбда-функции


```python
# сортировка по длине строки
lines = ["abcd", "zb", "abc", "abcdef"]
print(sorted(lines, key=lambda line: len(line)))
# ['zb', 'abc', 'abcd', 'abcdef']
# lambda используется для сортировки списка строк (lines) по их длине (переводит строку в число (длину строки))

# Сортируем по этим числам:
# [2, 3, 4, 6] → ["ab", "abc", "abcd", "abcdef"]
```


11.
#### Сортировка строк по последнему символу:
words = ["apple", "banana", "cherry"]
sorted(words, key=lambda word: word[-1])  # ['banana', 'apple', 'cherry']


12.
#### Сортировка по нескольким критериям
lines = ["abcd", "ab", "ba", "acde"]
print(sorted(lines, key=lambda line: (len(line), line)))

сортировка сначала по длине, потом по алфавиту


13.
#### по убыванию длины, а при равенстве — по алфавиту
lines = ["abcd", "ab", "ba", "acde"]
print(sorted(lines, key=lambda line: (-len(line), line)))

14.
#### Применение в min() и max()

```python
# Лямбда-функции можно использовать и в других встроенных функциях, например
# чтобы найти самую длинную строку (а при равной длине — лексикографически меньшую)
lines = ["abcd", "ab", "ba", "acde"]
print(min(lines, key=lambda line: (-len(line), line)))
```
15.
#### reduce()
«сворачивает» последовательность в одно итоговое значение.

-reduce() — функция, которая последовательно применяет операцию к элементам списка.
-lambda (функция-операция) — анонимная (безымянная) функция для простых операций.

Функция принимает:

- Функцию (в нашем случае — lambda x, y: x + y),
- Последовательность (здесь — numbers = range(1, 6), т.е. [1, 2, 3, 4, 5]).

Она последовательно применяет функцию к элементам, сводя (reducing) список к одному значению.


```python
from functools import reduce
numbers = range(1, 6)
print(reduce(lambda x, y: x + y, numbers))

# аналогично
# def add(x, y):
#     return x + y

# print(reduce(add, numbers))  # тоже выведет 15

```
16.

Как разложить size на n и m
через isinstance()
if isinstance(size, tuple):  # происходит проверка size это кортеж или нет
    n, m = size
else:
    n = m = size
или
проверка типа
if type(size) is tuple:
    n, m = size
else:
    n = m = size

    
17.
isinstance(item[1], list) - проверяет, значение является ли списком


18.
**переменная как функция или внесение аргументов, к-рые требует функция**

Если в функция оканчивается на return lambda, то это работает как 

``` python
operator_plus = get_operator("+")  # исп. нашу функцию и присваиваем переменной
print(operator_plus(3, 5))  # чтобы обработать определенные значения, к-рые требует lambda, заполняем в скобках переменной аргументы
```

``` python
def get_operator(operator):
    if operator == '+':
        return lambda a, b: a + b
    elif operator == '-':
        return lambda a, b: a - b
    elif operator == '*':
        return lambda a, b: a * b
    elif operator == '//':
        return lambda a, b: a // b
    elif operator == '**':
        return lambda a, b: a ** b
```



19.
**перевод из 16 системы счисления в 10**
f'{multiplied:x}' - перевод без префикса
str(hex(multiplied)) - с префиксом


20.
Функция any() в Python — это встроенная функция, которая проверяет, есть ли хотя бы один истинный (True) элемент в переданной последовательности (например, списке, кортеже, множестве или генераторе).
### 🔹 **Примеры**  

#### 1️⃣ **Списки и кортежи**  
```python
numbers = [0, False, None, 5]  
print(any(numbers))  # True (потому что 5 — истинное значение)

empty_list = []  
print(any(empty_list))  # False (нет элементов)

booleans = [False, False, False]  
print(any(booleans))  # False (все элементы False)
```

#### 2️⃣ **Строки**  
```python
words = ["", "hello", ""]  
print(any(words))  # True (непустая строка "hello")

empty_strings = ["", "", ""]  
print(any(empty_strings))  # False (все строки пустые)
```

#### 3️⃣ **Генераторы и `any()`**  
```python
# Проверяем, есть ли хотя бы одно чётное число
numbers = [1, 3, 5, 8, 9]  
has_even = any(x % 2 == 0 for x in numbers)  
print(has_even)  # True (8 — чётное)
```

#### 4️⃣ **Словари (проверка ключей, значений или пар)**  
```python
user = {"name": "Alice", "age": 0, "active": False}  

# Есть ли хотя бы одно истинное значение?
print(any(user.values()))  # True ("Alice" — непустая строка)

# Есть ли хотя бы один ключ длиной > 3?
print(any(len(key) > 3 for key in user))  # True ("name" и "active" длиной 4 и 6)
```

---

### 🔹 **Разница между `any()` и `all()`**  
| Функция | Возвращает `True`, если... | Пример |
|---------|----------------------------|--------|
| `any()` | **хотя бы один** элемент истинный | `any([False, 0, 5]) → True` |
| `all()` | **все** элементы истинные | `all([True, 1, "hello"]) → True` |

---

### 🔹 **Полезные применения `any()`**  
1. **Проверка условий в списках**  
   ```python
   # Есть ли отрицательные числа?
   numbers = [1, 2, -3, 4]  
   has_negative = any(x < 0 for x in numbers)  # True
   ```

2. **Фильтрация данных**  
   ```python
   # Оставить только списки, содержащие хотя бы одно чётное число
   data = {"a": [1, 3], "b": [2, 4], "c": [5, 7]}  
   filtered = {k: v for k, v in data.items() if any(x % 2 == 0 for x in v)}  
   # Результат: {'b': [2, 4]}
   ```

3. **Проверка вложенных структур**  
   ```python
   # Есть ли хотя бы один непустой список?
   nested = [[], [1], [], [2, 3]]  
   print(any(nested))  # True
   ```

---

### 🔹 **Вывод**  
Функция `any()` — это удобный способ проверить, **существует ли хотя бы один истинный элемент** в последовательности. Она часто используется в комбинации с генераторами и условиями для лаконичной и эффективной фильтрации данных.



21.
**как работает .items() в словарях**

### 1. Почему `item[1]`, а не `item[0]` при работе с `.items()`?

Когда мы применяем `.items()` к словарю, он возвращает **представление** (view) из пар `(ключ, значение)`. Каждый элемент этого представления — это **кортеж из двух элементов**:

```python
dict_items([('first', 2), ('second', '2 + 2 = 4'), ('third', [1, 2, 3])])
```

В lambda-функции:
- `item[0]` — это **ключ** словаря
- `item[1]` — это **значение**, связанное с этим ключом

Пример:
```python
for item in {'a': 1, 'b': 2}.items():
    print(f"Ключ: {item[0]}, Значение: {item[1]}")

# Вывод:
# Ключ: a, Значение: 1
# Ключ: b, Значение: 2
```

### 2. Как работает lambda со словарём при использовании `.items()`?

Когда мы делаем:
```python
filter(lambda item: условие, словарь.items())
```

Происходит следующее:
1. `словарь.items()` преобразует словарь в последовательность кортежей `(ключ, значение)`
2. `filter()` поочерёдно передаёт каждый такой кортеж в lambda-функцию как `item`
3. В lambda мы можем обращаться:
   - `item[0]` — к ключу
   - `item[1]` — к значению

### 3. Почему в задаче проверяем именно `item[1]`?

В условии задачи сказано: фильтровать элементы, **где значение является списком**, содержащим чётные числа. Поэтому:

```python
lambda item: isinstance(item[1], list) and ...  # Проверяем ЗНАЧЕНИЕ (item[1])
```

Если бы мы проверяли `item[0]`, это означало бы, что мы работаем с **ключами** словаря, а не со значениями.

### 4. Полный разбор lambda из задачи:
```python
lambda item: (
    isinstance(item[1], list) and                # Значение - это список?
    any(isinstance(x, int) and x % 2 == 0       # Есть ли в нём чётные числа?
        for x in item[1])
)

```

### 5. Альтернативная запись с явными именами:
Чтобы было понятнее, можно использовать распаковку кортежа:
```python
lambda key_val: (
    isinstance(key_val[1], list) and 
    any(isinstance(x, int) and x % 2 == 0 
        for x in key_val[1])
)
```
Или ещё понятнее:
```python
lambda key, val: (
    isinstance(val, list) and 
    any(isinstance(x, int) and x % 2 == 0 
        for x in val)
```
(Но тогда нужно использовать `filter(lambda kv: условие, словарь.items())`)

### Итог:
- `.items()` превращает словарь в последовательность пар `(ключ, значение)`
- В lambda `item[0]` — всегда ключ, `item[1]` — всегда значение
- В данной задаче мы фильтруем по значениям, поэтому работаем с `item[1]`


22.
**проверка на итерируемость объекта**
if hasattr(item[1], '__iter__')