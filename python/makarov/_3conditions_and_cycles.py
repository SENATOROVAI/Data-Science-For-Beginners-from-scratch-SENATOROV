"""Условия и циклы.

Продолжение.
"""

# ## Еще раз про условия с if.
#
# - Помимо базовой уже известной нам структуры if-else, мы также можем прописать несколько условий (multi-way decisions) с помощью if-elif-else. Слово elif в данном случае как раз и позволяет добавить новые условия.
# - Например, мы хотим написать программу, которая разделит все передаваемые ей числа на малые (small), средние (medium) и большие (large). Сначала посмотрим на блок-схему.
#
# ![image.png](attachment:image.png)
#
# - Если слово меньше 10, то оно малое, меньше 100 — среднее, в противном случае оно большое. Теперь пропишем это на Питоне.

from collections.abc import Iterable

# +
# создадим массив и поместим в переменную number_array
# from typing import Iterable
from typing import Union

# импортируем библиотеку numpy
# import numpy as np
import numpy as np

x_1: int = 42  # зададим число

# и пропишем условия (не забывайте про двоеточие и отступ)
if x_1 < 10:
    print("Small")
elif x_1 < 100:
    print("Medium")
else:
    print("Large")
# -

# - До сих пор мы записывали число или строку в переменную. Пора познакомиться с возможностью ввода числа с клавиатуры. В этом нам поможет встроенная в Питон функция input(). В частности, описанная выше программа могла бы запрашивать число у пользователя, а уже потом классифицировать.

# +
# запросим число у пользователя
x_2: str = input("Введите число: ")

# преобразуем в тип int
y_1: int = int(x_2)

# и наконец классифицируем
if y_1 < 10:
    print("Small")
elif y_1 < 100:
    print("Medium")
else:
    print("Large")
# -

# - Обратите внимание на два момента. Во-первых, внутри функции input() в кавычках мы пишем сообщение, которое увидит пользователь. Во-вторых, любые введенные нами символы воспринимаются как тип str (string, строка). Соответственно, если мы хотим, чтобы ввод считался числом, сначала его нужно преобразовать с помощью функции int().
# - Помимо этого одно условие может быть вложено в другое (nested decisions). Приведем пример.

# +
# запрашиваем число
y_2: str = input("Введите число: ")

# проверяем первое условие (не пустая ли строка), если оно выполняется
if len(y_2) != 0:

    # преобразуем в тип int
    y_x: int = int(y_2)

    # и классифицируем
    if y_x < 10:
        print("Small")
    elif y_x < 100:
        print("Medium")
    else:
        print("Large")

# в противном, говорим, что ввод пустой
else:
    print("Ввод пустой")
# -

# - В коде можно прописать сразу несколько условий в одном выражении. Например, можно объединить if c логическими операторами and или or. Вначале приведу пример с логическим И.

# +
z_1: int = 42

# если z больше 10 и одновременно меньше 100
if z_1 > 10 and z_1 < 100:  # pylint: disable=R1716

    # у нас среднее число
    print("Medium")

# в противном случае оно либо маленькое либо большое
else:
    print("Small or Large")
# -

# - А также логическим ИЛИ.

# +
z_2: int = 2

# если z меньше 10 или больше 100
if z_2 < 10 or z_2 > 100:

    # оно либо маленькое либо большое
    print("Small or Large")

# в противном случае оно среднее
else:
    print("Medium")
# -

# - С помощью if мы можем проверить, входит ли элемент в состав какого-либо объекта или нет. Для этого используются операторы in и not in.
#     - Оператор in возвращает True, если элемент входит в объект;
#     - Оператор not in возвращает True, если элемент не входит в объект.
# - Посмотрим на примерах.

# +
# можно проверить вхождение слова в строку
sentence: str = "To be, or not to be, that is the question"
word: str = "question"

if word in sentence:
    print("Слово найдено")

# +
# или отсутствие элемента в списке
number_list: list[int] = [2, 3, 4, 6, 7]
number: int = 5

if number not in number_list:
    print("Такого числа в списке нет")
# -

# - Еще раз обращу ваше внимание на то, что not in возвращает True, когда элемента НЕТ в объекте. Именно поэтому в примере со списком условие после if выполнилось.
# - Применим оператор in к словарю.

# +
# возьмем очень простой словарь
d_1: dict[str, int] = {"apple": 3, "tomato": 6, "carrot": 2}

# вначале поищем яблоки среди ключей словаря
if "apple" in d_1:
    print("Нашлись")

# а затем посмотрим, нет ли числа 6 среди его значений
# с помощью метода .values()
if 6 in d_1.values():
    print("Есть")
# -

# - Теперь давайте поговорим про циклы.

# ## Циклы.
#
# ![image.png](attachment:image.png)
#
# ## Цикл for.
# ### Основные операции.
# - С циклом for (for loop) мы уже знакомы. Повторим пройденное на несложном примере.

# +
# поочередно выведем элементы списка
number_list_2: list[int] = [1, 2, 3]

# не забывая про двоеточие и отступ
for number in number_list_2:
    print(number)
# -

# - Мы также умеем выводить элементы словаря.

# +
# создадим словарь, значениями которого будут списки из двух элементов
d_2: dict[str, list[int | str]] = {
    "apple": [3, "kg"],
    "tomato": [6, "pcs"],
    "carrot": [2, "kg"],
}

# затем создадим две переменные-контейнера и применим метод .items()
for k_1, v_1 in d_2.items():
    print(k_1, v_1)
# -

# - Помимо этого мы можем вывести только ключи или только значения с помощью методов .keys() и .values() соответственно.
# - Предположим, что мы хотим вывести только числа (первый элемент значения словаря).

# возьмем только одну переменную и применим метод .values()
for v_2 in d_2.values():
    # значение представляет собой список, выведем его первый элемент с индексом [0]
    print(v_2[0])

# - Цикл for можно применить к массиву Numpy.

# +
number_array: Iterable[int] = np.array([1, 2, 3])

# пройдемся по нему с помощью цикла for
for number in number_array:
    print(number)
# -

# - Помимо этого мы можем вложить один цикл for в другой (nested for loops). Предположим, что у нас есть следующая база данных клиентов.

# from typing import Union
clients: dict[int, dict[str, Union[str, int]]] = {
    1: {"name": "Анна", "age": 24, "sex": "male", "revenue": 12000},
    2: {"name": "Илья", "age": 18, "sex": "female", "revenue": 8000},
}

# - База данных представляет собой словарь. Ключами являются id клиентов. Значениями — еще один (вложенный) словарь с информацией о каждом клиенте.
# - Ключами второго (вложенного) словаря выступают названия полей (ФИО, возраст, пол и выручка с клиента), а значениями — соответствующая информация. Выведем все эти данные.

# в первом цикле for поместим id и информацию о клиентах в переменные id и info
for id_, info_ in clients.items():

    # выведем id клиента
    print("client ID: " + str(id_))

    # во втором цикле возьмем информацию об очередном клиенте (тоже словарь)
    for k_2, v_2 in info_.items():  # type: ignore

        # и выведем каждый ключ (название поля) и значение (саму информацию)
        print(k_2 + ": " + str(v_2))

    # добавим пустую строку после того, как выведем информацию об одном клиенте
    print()

# - Два комментария.
#
#     - Обратите особое внимание на отступы слева, они указывают на очередность выполнения операций. Например, пустая команда print() (и соответственно пустая строка) имеет один отступ и будет выполнена после вывода всей информации об одном клиенте, а не после каждого поля с данными.
#     - При использовании функции print() мы можем объединить несколько строк, а вот объединить строку и число нельзя. Так как идентификатор (id), значение возраста (age) и значение выручки (revenue) являются числами (тип int), их нужно сначала принудительно сделать строкой через функцию str().

# ## Функции range() и enumerate()
#
# ### Функция range()
# - Иногда нам бывает нужно создать последовательность чисел и пройтись по ней в цикле. Конечно, можно создать список и заполнить его нужными элементами, но, во-первых, для этого надо написать много кода, во-вторых, это будет неэффективно с точки зрения памяти компьютера. Для этого есть специальная функция range().
# - Приведем несколько примеров.

# создадим последовательность от 0 до 4
for i in range(5):
    print(i)

# от 1 до 5
for i in range(1, 6):
    print(i)

# и от 0 до 5 с шагом 2 (то есть будем выводить числа через одно)
for i in range(0, 6, 2):
    print(i)

# - Теперь рассмотрим, как мы получили такие результаты более детально.
#
# ![image.png](attachment:image.png)
#
# - Функция range() принимает от одного до трех параметров.
#     - Если передать только один параметр, то мы начнем последовательность с нуля и закончим на элементе, предшествующем нашему параметру. В примере выше мы передали параметр «пять» (range(5)) и получили последовательность 0, 1, 2, 3, 4.
#     - Если указать два параметра, то мы начнем последовательность с первого параметра и законим на элементе, предшествующем второму параметру. В частности, если написать range(1, 6), то получится 1, 2, 3, 4, 5.
#     - Третий параметр устанавливает шаг. По умолчанию он равен единице, однако если, например, написать, range(0, 6, 2), то мы получим 0, 2, 4.
# - Что интересно, если совместить range() с функцией len(), то такую конструкцию можно использовать для того, чтобы в одном цикле вывести все элементы, например, двух списков по их индексу.

# +
# возьмем месяцы года
months: list[str] = [
    "Январь",
    "Февраль",
    "Март",
    "Апрель",
    "Май",
    "Июнь",
    "Июль",
    "Август",
    "Сентябрь",
    "Октябрь",
    "Ноябрь",
    "Декабрь",
]

# и продажи мороженого в тыс. рублей в каждый из месяцев
sales: list[int] = [47, 75, 79, 94, 123, 209, 233, 214, 197, 130, 87, 55]

# задав последовательность через range(len()),
for i in range(len(months)):  # pylint: disable=consider-using-enumerate

    # мы можем вывести каждый из элементов обоих списков в одном цикле
    print(months[i], sales[i])
# -

# - Мы уже применяли эту функцию. На занятии по кластеризации, в методе k-средних мы пробовали разное количество кластеров и смотрели как изменится ошибка модели. Эта функция также использовалась нами при создании рекомендательной системы и в модели экспоненциального сглаживания.
# - Интересно, что по последовательности, создаваемой функцией range() можно пройтись и в обратном порядке от конца к началу. Сделать это можно тремя способами.
# - Способ 1. Использовать функцию reversed(). Эта функция меняет порядок элементов списка на обратный.

# +
# создадим список
my_list: list[int] = [0, 1, 2, 3, 4]

# передадим его функции reversed() и
# выведем каждый из элементов списка с помощью цикла for
for i in reversed(my_list):
    print(i)
# -

# - Одновременно ей можно передать последовательность, создаваемую range() и вывести результат в цикле for.

for i in reversed(range(5)):
    print(i)

# - Способ 2. Указать -1 в качестве параметра шага. При этом важно, чтобы первым параметром указывался конечный элемент списка, а вторым — начальный.

for i in range(4, 0, -1):
    print(i)

# Обратите внимание, что в примере выше 4 входит в создаваемую последовательность, а вот 0 уже нет. Для того чтобы вывести 0, вторым параметром нужно также указать -1.

for i in range(4, -1, -1):
    print(i)

# - Способ 3. Функция sorted(). Наконец, хотя в данном случае это явно не оптимальный вариант, можно использовать функцию sorted(), которая сортирует элементы списка по убыванию, если передать ей параметр reverse = True.

# +
# создадим последовательность от 0 до 4
r_1 = range(5)

# отсортируем ее по убыванию
sorted_values = sorted(r_1, reverse=True)

# выведем элементы отсортированной последовательности
for i in sorted_values:
    print(i)
# -

# - Про функции reversed() и sorted() мы будем также говорить на занятии, посвященном спискам, кортежами и множествам.

# ### Функция enumerate()
#
# - Теперь давайте посмотрим на функцию enumerate(). Мы можем использовать эту функцию, если у нас есть, например, список и, проходясь в цикле по этому списку, мы хотим также получить порядковый номер (индекс) элементов списка.

# +
# пусть дан список с днями недели
days: list[str] = [
    "Понедельник",
    "Вторник",
    "Среда",
    "Четверг",
    "Пятница",
    "Суббота",
    "Воскресенье",
]

# выведем индекс (i) и сами элементы списка (day)
for i, day in enumerate(days):
    print(i, day)
# -

# - Все выглядит хорошо, но неделю логичнее начинать с первого дня, а не с нулевого. Для этого функции enumerate() можно передать начальное значение.

# так же выведем индекс и элементы списка, но начнем с 1
for i, day in enumerate(days, 1):
    print(i, day)

# - Эту функцию мы уже применяли на занятиях по компьютерному зрению и обработке естественного языка.

# ## Цикл while
#
# - С циклом while (while loop) мы пока не знакомы. Как уже было сказано, цикл выполняется пока верно прописанное в нем условие.
#
# ![image.png](attachment:image.png)
#
# - В целом все просто, но есть один нюанc.
#     - Условие должно в какой-то момент перестать быть верным, иначе цикл станет бесконечным. Для этого существует счетчик (counter).
# - Посмотрим как это можно реализовать на Питоне.
#

# +
# зададим начальное значение счетчика
i_4: int = 0

# пока счетчик меньше трех
while i_4 < 3:

    # в каждом цикле будем выводить его текущее значение
    print("Текущее значение счетчика:  " + str(i_4))

    # внутри цикла не забудем "нарастить" счетчик
    i_4 += 1

    # и выведем новое значение
    print("Новое значение счетчика:    " + str(i_4))

    # добавим пустую строку
    print()
# -

# - Рассмотрим еще раз, как мы получили такой результат:
#     - у нас есть начальное значение счетчика, равное нулю (i = 0) (хотя конечно значение счетчика может быть любым);
#     - при первой итерации, так как 0 < 3, исполняем код в цикле и увеличиваем счетчик на 1 (теперь i = 1);
#     - на второй итерации, 1 < 3, условие по-прежнему верно, снова исполняем код и увеличиваем счетчик на 1 (i = 2);
#     - на третьей итерации, 2 < 3, условие верно, исполняем код и увеличиваем счетчик на 1 (i = 3);
#     - далее, алгоритм пытается выполнить четвертую итерацию цикла, однако так как 3 < 3 ложно, цикл прерывается.
# - Небольшой лайфхак. Вместо того, чтобы писать i = i + 1 Питон позволяет использовать короткую запись (shorthand operator): i += 1.

# +
i_5: int = 0

while i_5 < 3:
    print(i_5)
    i_5 += 1
# -

# - Оператор += прибавляет значение переменной и одновременно присваивает ей это новое увеличенное значение (поэтому его еще называют addition assignment). Короткая запись также применяется к операциям вычитания ( -=), умножения ( *=) и деления ( /=).

# ### Операторы break и continue
# Ходом исполнения цикла можно управлять.

# ### Оператор break
# - Представьте, что вы пишете цикл, который затем примените к очень длинному словарю или списку (в нем, например, 10 тыс. элементов), но вы не уверены в своем коде. Если цикл применить сразу ко всему объекту и при этом окажется, что код делает не совсем то, что вы хотите, то придется ждать, пока компьютер выведет все 10 тыс. записей.
# - Логично протестировать код на первой записи, а уже потом двигаться дальше. В этом нам поможет оператор break (прерывание цикла).

# +
# вновь возьмем словарь clients
clients_5: dict[int, dict[str, Union[str, int]]] = {
    1: {"name": "Анна", "age": 24, "sex": "male", "revenue": 12000},
    2: {"name": "Илья", "age": 18, "sex": "female", "revenue": 8000},
}

# в цикле пройдемся по ключам и значениям словаря
for id_cli, info in clients_5.items():

    # и выведем их
    print(id_cli, info)

    # однако уже после первого исполнения цикла, прервем его
    break
# -

# - Цикл можно также прерывать при наступлении определенного условия.

# +
# зададим начальное значение счетчика
x_3: int = 6

# будем исполнять цикл пока x не равен нулю
while x_3 != 0:

    # выведем текущее значение счетчика
    print(x_3)

    # и уменьшим (!) его на 1
    x_3 -= 1

    # если значение счетчика станет равным 3, прервем цикл
    if x_3 == 3:
        break
# -

# - Мы прервали цикл, когда значение счетчика стало равно трем.
# - Также обратите внимание, что здесь цикл двигается в сторону уменьшения (с помощью -=). Мы начали с x = 6 и должны были вывести значения 6, 5, 4, 3, 2, 1, если бы условие не прервало выполнение цикла.

# ### Оператор continue
# - Иногда цикл не нужно прерывать, но нужно как бы «перескочить» одну или несколько итераций этого цикла. В этом случае применяется оператор continue.
# - Предположим, нам нужно создать последовательность целых чисел от 1 до 10 включительно и вывести только четные числа.
# - Последовательность создавать мы умеем. Взятие остатка от деления мы уже рассмотрели на прошлом занятии. Осталось написать код целиком.

# с помощью функции range создадим последовательность от 1 до 10
for i in range(1, 11):

    # если остаток от деления на два не равен нулю (то есть число нечетное)
    if i % 2 != 0:

        # идем к следующему числу последовательности
        continue

    # в противном случае выводим число

    print(i)

# - Как мы видим, остались только четные числа.

# ## Форматирование строк в функции print()
# - Результат работы программы может содержать как текст (строковые значения), так и переменные. Объединить их можно с помощью f-строк (f-string) и метода .format().
# - Сразу приведем пример.

# +
# снова возьмем список с днями недели
days_z: list[str] = [
    "Понедельник",
    "Вторник",
    "Среда",
    "Четверг",
    "Пятница",
    "Суббота",
    "Воскресенье",
]

# и для простоты поместим слово "Понедельник" в переменную Monday
Monday = days_z[0]
Monday
# -

# - Теперь напишем фразу «Понедельник — день тяжелый» следующим образом.

# - Мы использовали переменную Monday в строке вывода функции print(). Для этого перед строкой мы поставили букву f, а саму переменную заключили в фигурные скобки.
# - То же самое можно сделать с помощью метода .format().
# - Фигурные скобки внутри строки остались пустыми. К самой строке мы применяем метод .format(), которому передаем нашу переменную.
# - Мы уже использовали f-строки, когда выводили изображения из датасета MNIST или создавали мешок слов с помощью класса CountVectorizer. Рекомендую вновь посмотреть этот код.

# ## Обобщим сказанное
# - Систематизируем пройденное на сегодняшнем занятии. В первой части мы вновь обратились к условиям с if и научились:
#     - создавать множественные условия с if-elif-else;
#     - вкладывать одно условие в другое;
#     - объединять несколько условий с помощью логических операторов and и or; а также
#     - использовать конструкции if + in и if + not in, чтобы проверить вхождение элемента в список или, например, словарь.
# - Во второй части мы продолжили изучать цикл for и познакомились с циклом while. Мы узнали, что:
#     - циклы, как и условия, можно вкладывать один в другой;
#     - с помощью функции range() мы можем создавать новую последовательность элементов;
#     - функция enumerate() создает индекс для существующей последовательности;
#     - цикл while выполняется пока верно определенное условие, а чтобы он не стал бесконечным, нужно использовать счетчик.
# - Кроме того, мы узнали, что циклами можно управлять:
#     - оператор break позволяет прервать выполнение цикла;
#     -   оператор continue прерывает выполнение конкретной итерации, но сам цикл продолжает исполняться.
# - В заключительной части занятия мы узнали, как можно форматировать строковые значения и переменные через f-строки и метод .format().

# ## Ответы на вопросы
# - Вопрос. В функции range() только один обязательный параметр?
# - Ответ. Да, совершенно верно. Единственный обязательный параметр — это число, перед которым должна остановиться последовательность. То есть если вы пишете range(7), последовательность начнется с 0 и дойдет до 6 включительно. Прописав два параметра, вы укажете начало и конец последовательности. Три параметра — начало, конец и шаг.
# -
# - Вопрос. Можно ли с функцией range() использовать цикл while?
# - Ответ. Да, можно, но решение, скорее всего, будет не оптимальным.
# -
# - Вопрос. Почему range() более эффективна с точки зрения памяти компьютера?
# - Ответ. Список (list) возвращает набор чисел и сразу размещает все эти числа в оперативной памяти компьютера. Функция range() возвращает объект range, который представляет собой генератор чисел. Он выдает только одно число за раз и, таким образом, экономит память компьютера.
# -
# - Вопрос. Почему на занятии по обработке естественного языка в цикле for с функцией enumerate() вы использовали символ нижнего подчеркивания («_»)?
# - Ответ. Вероятно, вы имеете в виду код с этого занятия. Здесь у нас две переменные-контейнера: индекс и предложения. Так как нас интересует только индекс, предложения мы обозначили символом подчеркивания. Другими словами, так обозначают переменные, которые нельзя не указать, но которые затем не используются.
# -
# - Вопрос. Мне кажется, что в примере с оператором continue без последнего можно обойтись.
# - Ответ. Да, вы правы, можно обойтись без continue (вариант без этого оператора вы найдете в конце блокнота). Такой простой пример я конечно привел в учебных целях. В целом continue удобно использовать для того, чтобы (1) повысить читаемость кода при проверке множества условий (в противном случае вам придется использовать несколько вложенных if) или если вам нужно (2) проверить какое-либо условие перед выполнением очень длинного кода.

#
