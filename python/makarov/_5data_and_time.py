"""Дата и время в Питоне."""

# ## Дата и время в Питоне.
#
# - Говоря про временные ряды, мы уже начали анализировать данные, в которых присутствует дата и время (в частности, в библиотеке Pandas). Сегодня мы сделаем шаг назад и посмотрим в целом как работать с датой и временем в Питоне.
#
# ## Модуль datetime
#
# - В базовом функционале Питона нет отдельного типа данных, отвечающего за дату и время. Необходимо импортировать модуль, который называется datetime.
# - Первая особенность, про которую стоит сказать, datetime — это не только название модуля, но и название одного из классов внутри этого модуля. Помимо класса datetime, нас будет интересовать ещё один класс — timedelta.
#
# ![image.png](attachment:image.png)
#
# Перейдем к практике.
#
# ### Импорт модуля и класса datetime
# - Самый простой способ — импортировать весь модуль datetime.

# +
# импортируем весь модуль
# import datetime

# для этого вначале импортируем соответствующий класс
# from datetime import timedelta
from datetime import datetime, timedelta

import pytz

# -

# - Далее предположим, что мы хотим воспользоваться функцией now(), которая находится внутри класса datetime. Функция now() выводит текущие дату и время.

# чтобы получить доступ к функции now(), сначала обратимся к модулю, потом к классу
print(datetime.now())

# - Как вы видите, это не очень удобно. Можно импортировать только класс datetime и обращаться непосредственно к нему.

print(datetime.now())

# ### Объект datetime и функция now()
# - Теперь поговорим подробнее про то, что выводит функция now().

# поместим созданный с помощью функции now() объект datetime в переменную cur_dt
cur_dt: datetime = datetime.now()
print(cur_dt)

# - На выходе мы получаем текущие дату и время по UTC⧉, потому что серверы Google Colab настроены именно на это время (московское время, например, отличается на +3 часа). Сам вывод состоит из следующих компонентов.
#
# ![image.png](attachment:image.png)
#
# - Мы можем обратиться к каждому из этих компонентов по отдельности.
#
#

# с помощью соответствующих атрибутов выведем каждый из компонентов объекта
print(
    cur_dt.year,
    cur_dt.month,
    cur_dt.day,
    cur_dt.hour,
    cur_dt.minute,
    cur_dt.second,
    cur_dt.microsecond,
)

# - Мы также можем посмотреть на день недели, причем в двух форматах. Метод .weekday() считает, что неделя начинается с нуля, метод .isoweekday(), что с единицы.
#
# ![image.png](attachment:image.png)
#
# - Так как 18 ноября 2021 года — это четверг, то применив эти методы, мы должны получить цифры три и четыре соответственно.
#

print(cur_dt.weekday(), cur_dt.isoweekday())

# - Объект datetime, полученный из функции now(), не содержит данных о часовом поясе.

# посмотрим на часовой пояс с помощью атрибута tzinfo
print(cur_dt.tzinfo)

# - Для того чтобы добавить такую информацию и вывести, например, другой часовой пояс, нам нужно воспользоваться модулем pytz.

# выведем текущее время в Москве
dt_moscow: datetime = datetime.now(pytz.timezone("Europe/Moscow"))
print(dt_moscow)

# - Посмотрим, не появился ли часовой пояс.

print(dt_moscow.tzinfo)

# ## Timestamp
#
# - До сих пор мы работали с привычным для нас делением на годы, месяцы, дни, часы, минуты и секунды. При этом компьютеры используют так называемое время Unix, которое отсчитывается в секундах c первого января 1970 года. Для отображения даты и времени в таком формате в Питоне есть объект timestamp (по-английски — «временная отметка»).

# получим timestamp текущего времени с помощью метода .timestamp()
timestamp: float = datetime.now().timestamp()

# - Посмотрим, сколько секунд и микросекунд прошло с 01.01.1970 и до момента исполнения кода.

print(timestamp)

# - Не составляет труда вернуть timestamp обратно в привычный формат.

# для этого воспользуемся методом .fromtimestamp()
print(datetime.fromtimestamp(timestamp))

# ### Создание объекта datetime вручную
#
# - Дату и время не обязательно получать из функции now(). Мы вполне можем передать объекту datetime наши собственные параметры, например, день рождения Питона.

# передадим объекту datetime 20 февраля 1991 года
hb: datetime = datetime(1991, 2, 20)
print(hb)

# - Обратите внимание, мы ввели только год, месяц и день. Это обязательные параметры. Остальные параметры можно не вводить, в этом случае они заполнятся нулями.
# - Из этого объекта мы также можем извлечь компоненты (год, месяц, число и т.д.) и создать timestamp.

# +
# извлечем год с помощью атрибута year
print(hb.year)

# создадим timestamp
print(datetime.timestamp(hb))
# -

# ## Преобразование строки в datetime и наоборот
# ### Строка в datetime через .strptime()
#
# - Если дата содержится в строковом формате, Питон не сможет извлечь из нее компоненты. Предварительно строку нужно преобразовать. Для этого есть метод .strptime().
#

# дана строка с датой 2 декабря 2007 года и временем 12 часов 30 минут и 45 секунд
str_to_dt: str = "2007-12-02 12:30:45"
type(str_to_dt)

# - Преобразуем эту строку в объект datetime с помощью метода .strptime().

# +
res_dt: datetime = datetime.strptime(str_to_dt, "%Y-%m-%d %H:%M:%S")

print(res_dt)
print(type(res_dt))
# -

# - Как вы видите, сначала мы передаём этому методу саму строку, а затем тот формат, в котором содержится дата и время (иначе Питон не поймет, к чему относится конкретное число).
# - Давайте расшифруем каждое из обозначений:
#     - %Y — год в формате ГГГГ, например: 1995, 2003 и т.д.
#     - %m — месяц в виде числа с нулями, например, январь — 01, февраль — 02 и т.д.
#     - %d — день месяца в виде числа с нулями, например: 01, 02, …, 31
#     - %H — час в 24-часовом формате в виде числа с нулями, например: 00, 01, …, 23
#     - %M — минуты в виде числа с нулями, например: 00, 01, …, 59
#     - %S — секунды в виде числа с нулями, например: 00, 01, …, 59
# - Дефисы, пробелы, двоеточия или, например, запятые — тоже элементы формата и их тоже нужно указывать.

# ### Datetime в строку через .strftime()
#
# - Обратное преобразование также возможно. Это может быть полезно, если мы захотим вывести дату и время в строго определенном формате.

# вначале создадим объект datetime и передадим ему 19 ноября 2002 года
dt_to_str: datetime = datetime(2002, 11, 19)
type(dt_to_str)

# +
# преобразуем объект в строку в формате "день недели, месяц число, год"
res_str: str = datetime.strftime(dt_to_str, "%A, %B %d, %Y")

print(res_str)
print(type(res_str))
# -

# - Метод .strftime() можно применять непосредственно к объекту datetime.

dt_to_str.strftime("%A, %B %d, %Y")

# - Расшифруем обозначения:
#     - %A — полное название дня недели, например: Sunday, Monday, …
#     - %B — полное название месяца, например: January, February
#     - %d — день месяца в виде числа с нулями, например: 01, 02, …, 31
#     - %Y — год в формате ГГГГ, например: 1999, 2003 и т.д.

# ## Сравнение и арифметика дат
# ### Сравнение дат
# - Даты можно сравнивать между собой. Для этого используются стандартные операторы сравнения >, <, >=, <=, ==, !=.
# - Сравним две даты публикации работ Эйнштейна.

date1: datetime = datetime(1905, 6, 30)  # "К электродинамике движущихся тел"
date2: datetime = datetime(1916, 5, 11)  # Общая теория относительности

# - Вторая дата должна быть «больше», потому что она более поздняя.

date1 < date2

# - Обратное будет признано ложным.

date1 > date2

# ### Календарный и алфавитный порядок дат
#
# - Интересно, что если даты записаны в виде строки в формате ГГГГ.ММ.ДД, то в Питоне мы можем их сравнивать, как если бы мы сравнивали объекты datetime. Другими словами, календарный и алфавитный порядок дат совпадают. Приведем пример.

# вначале запишем даты в виде строки и сравним их
date_time_1: str = "2007-12-02"
date_time_2: str = "2002-11-19"
date_time_1 > date_time_2

# теперь в виде объекта datetime
print(datetime(2007, 12, 2) > datetime(2002, 11, 19))

# ### Промежуток времени и класс timedelta
# - Если из большей даты вычесть меньшую, то мы получим временной промежуток между датами.

diff = date2 - date1
print(diff)

# - при этом результат будет храниться в специальном объекте timedelta.

type(diff)

# - Атрибут days позволяет посмотреть только дни.

print(diff.days)

# - Объект timedelta также можно создать вручную.

# а затем создадим объект timedelta продолжительностью 1 день
timedelta(days=1)

# ### Арифметика дат
# - Объединив объекты datetime и timedelta, мы можем «путешествовать во времени».

# pylint: disable=line-too-long
# допустим сейчас 1 января 2070 года
future: datetime = datetime(2070, 1, 1)
future

# - И мы хотим отправиться в 1 января 1900 года, т.е. на 170 лет назад.

# +
# сначала просто умножим 365 дней на 170
time_travel: timedelta = timedelta(days=365) * 170

# а потом переместимся из будущего в прошлое
past: datetime = future - time_travel

# к сожалению, мы немного "не долетим", потому что не учли високосные годы, в которых 366 дней
past
# -

# - Давайте посмотрим, сколько дней мы преодолели.

365 * 170

# - Предлагаю узнать, сколько дней нам на самом деле нужно было пролететь. Мы уже умеем это делать, находя разницу между двумя объектами datetime.

print(datetime(2070, 1, 1) - datetime(1900, 1, 1))

# - Теперь снова совершим путешествие во времени, но на этот раз укажем правильное количество дней.

# +
time_travel = timedelta(days=62092)

past = future - time_travel
past
# -

# - Объект timedelta можно также прибавлять к объекту datetime. Например, нам может быть нужно создать перечень дат, пусть это будут новогодние празники в 2021 году. Для этого удобно использовать цикл while.

# +
cur_date: datetime = datetime(2021, 1, 1)  # эту дату мы будем выводить
end_date: datetime = datetime(2021, 1, 10)  # это граница (условие в цикле while)

# пока верно условие
while cur_date <= end_date:

    # выведем cur_date в формате "месяц число, год"
    print(cur_date.strftime("%b %d, %Y"))

    # прибавим к выводимой дате один день
    cur_date += timedelta(days=1)
# -

# ## Дата и обработка ошибок
# ### Конструкция try / except и оператор pass
# - Прежде чем мы перейдем к практическому примеру с обработкой дат, давайте познакомимся с одной полезной конструкцией. Часто мы не уверены, что наш код отработает без ошибок. Например, в данных может содержаться неточность, о которой мы ничего не знаем. При этом нам не хотелось бы, чтобы исполнение кода остановилось.
# - Для этого в Питоне есть конструкция try/except.
#
# ![image.png](attachment:image.png)
#
# - Приведем пример.

# +
# пусть дан список чисел в строковом формате, и мы хотим посчитать их сумму
# предположим, буква "а" попала в список случайно
numbers: list[str] = ["5", "10", "a", "15", "10"]

# объявим переменную суммы
total: int = 0

# пройдемся по числам
for number in numbers:

    # попробуем прибавить число к переменной total
    try:
        total += int(number)

    # если же этого сделать не удастся
    except ValueError:
        # перейдем к следующему числу
        pass

# выведем сумму
total
# -

# - Если бы такой конструкции не было, при попытке прибавить букву «а» алгоритм вывел бы ошибку.
# - Оператор pass просто говорит алгоритму продолжить работу. Вместо него можно вывести предупреждение.
#
#

# +
total = 0

for number in numbers:
    try:
        total += int(number)
    except ValueError:
        print(f"Элемент '{number}' обработать не удалось")

total
# -

# - Примечание. Обратите внимание на запись \'{number}\'. Обратная косая черта необходима, чтобы Питон воспринимал кавычки как часть строки.

# ## Обработка нескольких форматов дат
# - Теперь давайте посмотрим, как эта конструкция работает с датами. Вначале скачаем и подгрузим в Google Colab данные среднемесячной температуры в Нью-Йорке в 2002 году (в градусах Фаренгейта).
#
# ![image.png](attachment:image.png)
#
# - На данном этапе вы уже должны быть экспертами по работе с внешними данными.

# +
# посмотрим на данные
# import pandas as pd
# temp = pd.read_csv('temperature.csv')
# temp
# -

# ![image.png](attachment:image.png)
#
# - Предположим, что мы хотим вручную преобразовать каждую дату из строки в объект datetime. Теперь допустим, что проанализировав данные, мы выявили три шаблона: ГГГГ.ММ.ДД, ГГГГ.ММ.Д и ГГГГ.ММ. Напишем код, который в цикле for преобразует эти даты в объект datetime. Дополнительно наш код должен посчитать количество не обработанных записей.

# +
# создадим список с известными нам шаблонами
# formats = ['%Y-%m-%d', '%Y-%m-%-d', '%Y-%m']

# создадим счетчик для записей, которые не обработались
# counter = 0

# пройдемся в цикле по столбцу Date
# for d in temp.Date:

# затем пройдемся по известным нам форматам
# for format in formats:

# попробуем, применив каждый из форматов,
# преобразовать строку с датой в объект datetime
# try:
# print(datetime.strptime(d, format))
# counter += 1

# если что-то пошло не так
# except:
# перейдем к следующему формату (второй цикл for) или записи (первый цикл for)
# pass

# посмотрим, сколько записей не обработалось
# print('Не обработалось записей:', len(temp) - counter)
# -

# - Как мы видим, один формат мы все же упустили (данные за ноябрь в формате ММ.ГГГГ), и Питон не смог обработать эту запись.
# - Эту же работу мы можем поручить библиотеке Pandas через функцию read_csv() и параметр parse_dates (мы уже делали так, изучая временные ряды).

# +
# temp_parsed = pd.read_csv('temperature.csv', index_col = 'Date', parse_dates = True)
# temp_parsed
# -

# ![image.png](attachment:image.png)
#
# - В данном случае нам удалось обработать все записи, включая данные за ноябрь.

# индекс превратился в объект datetime
# type(temp_parsed.index)


# - Иногда, как мы видим, решение «из коробки» (то есть уже готовое решение) более эффективно, чем написанный самостоятельно код.

#
