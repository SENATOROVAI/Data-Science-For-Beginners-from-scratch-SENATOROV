"""Списки, кортежи и множества."""

# ## Списки, кортежи и множества.
# - На сегодняшнем занятии мы подробнее поговорим про три типа данных в Питоне: списки, кортежи и множества. Каждый из них относится к так называемым коллекциям (collections), то есть типам данных, содержащим сразу несколько элементов.
# - При этом у каждого из них есть свои важные особенности.
# ## Списки.
# ### Основы работы со списками.
# - Список можно создать (или как правильнее говорить инициализировать) через пустые квадратные скобки [] или с помощью функции list().

# +
# импортируем класс стеммера Портера
from nltk.stem import PorterStemmer

some_list_1: list[int] = []
some_list_2: list[int] = []
# some_list_2 = list()
print(some_list_1, some_list_2)
# -

# - Элементом списка может быть любой объект, например, число, строка, список или словарь.

number_three: list[int | str | list[str] | dict[str, int]] = [
    3,
    "число три",
    ["число", "три"],
    {"число": 3},
]
number_three

# - Длину списка можно узнать с помощью функции len().

len(number_three)

# ## Индекс и срез списка
# - Как мы уже знаем, у списка есть индекс. Элементы списка индексируются так же, как символы в строке.
#
# ![image.png](attachment:image.png)
#
#

# +
# создадим список из букв
abc_list: list[str] = ["a", "b", "c", "d", "e"]

# выведем первый и последний элементы
print(abc_list[0], abc_list[-1])
# -

# - Рассмотрим пример со вложенными списками (nested list). Для того чтобы обратиться, например, к первому элементу второго вложенного списка нужно использовать двойной индекс [1][0].

salary_list: list[list[str | int]] = [
    ["Анна", 90000],
    ["Игорь", 85000],
    ["Алексей", 95000],
]
salary_list[1][0]

# - Обратите внимание, мы начали с индекса вложенного списка ['Игорь', 85000] в общем списке salary_list (как бы снаружи). Он соответствует [1]. Затем мы указали индекс первого элемента внутри вложенного списка [0].
# - Индекс элемента в списке можно узнать с помощью метода .index(). Предположим, мы хотим узнать индекс элемента 'c' в списке abc_list.

abc_list.index("c")

# - Метод .index() можно применить ко вложенному списку.

# возьмем первый [0] список ['Анна', 90000] и выясним индекс уровня зарплаты
salary_list[0].index(90000)

# - В случае если мы хотим получить срез списка, то так же как и в случае строк, мы указываем начало среза и элемент до которого (но не включая который) сделать срез.

days_list: list[str] = ["Пн", "Вт", "Ср", "Чт", "Пт", "Сб", "Вс"]
days_list[1:5]

# - У среза есть третий параметр — шаг. Он позволяет пропускать заданное количество элементов.

# начнем с Пн и будем брать дни через один вплоть до, но не включая, Сб [5]
days_list[:5:2]

# - Кроме того, мы можем проверить содержится ли элемент в списке с помощью ключевого слова in.

"Пн" in days_list

if "Вт" in days_list:
    print("Такое слово есть")

# ### Добавление, замена и удаление элементов списка.
# - Мы уже умеем использовать метод .append(), который добавляет элемент в конец списка.

# +
weekdays: list[str] = ["Понедельник", "Вторник"]

weekdays.append("Четверг")
weekdays
# -

# - Метод .insert() позволяет добавить элемент в середину списка, при этом индекс последующих элементов сдвигается.

# для этого методу .insert() мы передаем желаемый индекс нового элемента
# и сам этот элемент
weekdays.insert(2, "Среда")
weekdays

# - Элемент списка можно заменить по индексу.

weekdays[3] = "Пятница"
weekdays

# - Элемент можно удалить, указав либо его название, либо индекс.

# для удаления по названию можно использовать метод .remove()
weekdays.remove("Пятница")
weekdays

# ключевое слово del удаляет элемент по индексу
del weekdays[2]
weekdays

# метод .pop() не просто удаляет элемент по индексу,
# но и выводит удаляемый элемент
weekdays.pop(1)

# Убедимся, что остался только понедельник.
weekdays

# ### Сложение списков.
# - Добавить к списку еще один список можно с помощью метода .extend(). Мы с вами уже использовали его на занятии по обработке естественного языка.

# +
# добавим к списку, в котором есть только понедельник, остальные дни
more_weekdays: list[str] = ["Вторник", "Среда", "Четверг", "Пятница"]

weekdays.extend(more_weekdays)
weekdays
# -

# - Кроме того, два списка можно просто сложить (concatenate).

# прибавим выходные
weekend: list[str] = ["Суббота", "Воскресенье"]
print(weekdays + weekend)

# - Добавлю, что иногда бывает полезно «размножить» элементы списка.

# для этого элемент в квадратных скобках нужно умножить на
# желаемую длину списка
["Понедельник"] * 2

# - Такие «произведения» также можно складывать.

["Понедельник"] * 2 + ["Вторник"] * 2

# ### Распаковка списков.
# - Ранее мы уже познакомились с возможностью распаковки списков (unpacking), то есть помещения элементов списка в переменные. Теперь посмотрим на этот функционал более внимательно.

# заново создадим список с днями недели
week: list[str] = [
    "Понедельник",
    "Вторник",
    "Среда",
    "Четверг",
    "Пятница",
    "Суббота",
    "Воскресенье",
]

# - Во-первых, элемент можно вывести по индексу и поместить в переменную.

mon = week[0]
mon

# - Несколько элементов можно поместить сразу в несколько переменных. Количество передаваемых элементов можно регулировать срезом.

# количество переменных должно быть равно количеству элементов среза
mon, Tue, Wed = week[:3]
mon, Tue, Wed

# - Если нас интересует только первый элемент списка, но мы не хотим использовать индекс, можно распаковать список в две переменные, пометив вторую символом *. В первую попадет первый элемент, во вторую — все остальные.

# +
# в переменную _ попадут дни со вторника по воскресенье
mon, *_ = week

# в Mon - только понедельник
mon
# -

# - Аналогичным образом мы можем распаковать первый, *остальные и последний элемент списка.

# в days попадут дни со вторника по субботу
mon, *days, Sun = week
mon, Sun

# ### Сортировка списков.
# - Для сортировки списка можно использовать функцию sorted() и метод .sort(). Функция sorted() не изменяет объект и сразу выводит результат сортировки.

# отсортируем список по возрастанию
nums: list[int] = [25, 10, 30, 20, 5, 15]
sorted(nums)

# исходный список остается прежним
nums

# - Впрочем, если записать результат вызова функции sorted() в переменную, изменение станет постоянным.

sorted_nums: list[int] = sorted(nums)
sorted_nums

# - Метод .sort() изменяет сам объект, но результат сортировки нужно вывести отдельно.

# с помощью параметра reverse = True сортируем список по убыванию
nums.sort(reverse=True)
nums

# - Метод .reverse() задает обратный порядок элементов списка (объект также изменяется, результат по умолчанию не выводится).

nums.reverse()
nums

# - Функция reversed() выдает специальный объект, называемый итератором.

reversed(nums)

# - Для того чтобы вывести сами элементы в обратном порядке, необходимо передать этот объект функции list().

list(reversed(nums))

# - Результат при этом не сохраняется.

nums

# ### Преобразование списка в строку.
# - Мы уже умеем разбивать строку на части и превращать в список. Иногда бывает полезно сделать обратное. Возьмем список, состоящий из букв.

str_list: list[str] = ["P", "y", "t", "h", "o", "n"]

# - И преобразуем его в строку с помощью метода .join(). Обратите внимание, пространство между элементами списка мы ничем не заполняем и для этого оставляем кавычки пустыми ''.

joined_str: str = "".join(str_list)
joined_str

# - Конечно, мы можем указать любой другой межбуквенный элемент.

joined_str_: str = "_".join(str_list)
joined_str_

# ### Арифметика в списках.
# - Вновь создадим список, состоящий из чисел.

nums_: list[int] = [3, 2, 1, 4, 5, 12, 3, 3, 7, 9, 11, 15]

# - С помощью метода .count() мы можем посчитать частоту вхождения элемента в список.

# посмотрим, сколько раз число "три" встречается в нашем списке
nums_.count(3)

# - Функции min(), max() и sum() позволяют рассчитать минимальное и максимальное значение, а также сумму элементов списка.

print(min(nums_), max(nums_), sum(nums_))

# ## List comprehension.
# - А теперь рассмотрим list comprehension. По сути, list comprehension позволяет превратить один список в другой, преобразовывая и отбирая элементы исходного списка.
#
# ![image.png](attachment:image.png)
#
# - Рассмотрим на примерах. Предположим, у нас есть список имен.

names: list[str] = ["Артем", "Антон", "Александр", "Борис", "Виктор", "Геннадий"]

# - И на основе этого списка мы хотим создать новый список, в котором останутся только имена, начинающиеся с буквы «А». Очевидно, мы можем использовать цикл for.

# +
# создадим пустой список a_names
a_names: list[str] = []

# пройдемся по списку имен
for name in names:

    # если имя начинается с 'А'
    if name.startswith("А"):

        # добавим его в список a_names
        a_names.append(name)

# посмотрим на результат
a_names
# -

# - List comprehension позволяет сделать то же самое, но в одну строку.

# +
# a_names: list[str] = [name for name in names if name.startswith("А")]
# a_names
# -

# - Немного изменив код, мы можем перевести все заглавные буквы имен исходного списка в строчные.

lower_names: list[str] = [name.lower() for name in names]
lower_names

# - На основе этих двух примеров давайте разберемся с синтаксисом list comprehension.
#
# ![image.png](attachment:image.png)
#
# - вначале идет выражение, преобразующее каждый элемент исходного списка:
#     - если просто указать переменную, как это было в первом примере с переменной name, элементы перейдут из исходного списка в новый без изменений;
#     - во втором примере, мы изменили регистр с заглавной буквы на строчную с помощью метода .lower(); затем
# - идет блок, по сути, повторяющий цикл for; и наконец
# - если это необходимо, условие c if, с помощью которого мы можем отобрать не все, а лишь некоторые из элементов исходного списка.
# - Приведу еще один пример.

replace_name: list[str] = [name if name != "Виктор" else "Вадим" for name in names]
replace_name

# - Как вы видите, здесь схема немного изменилась. Интерпретировать эту запись можно следующим образом:
#     - name if name != 'Виктор' — оставь элемент в списке без изменений, если он не совпадает с именем «Виктор»;
#     - else 'Вадим' — в противном случае (т.е. если совпадает), замени на «Вадим»;
#     - for name in names — сделай все это, проходясь по элементам исходного списка.
# - Также напомню, что мы уже использовали list comprehension на занятии по обработке естественного языка. Мы брали список слов после лемматизации.

lemmatized: list[str] = [
    "paris",
    "visited",
    "lot",
    "museum",
    "first",
    "went",
    "louvre",
    "largest",
    "art",
    "museum",
    "world",
    "always",
    "interested",
    "art",
    "spent",
    "many",
    "hour",
    "museum",
    "enormous",
    "week",
    "would",
    "enough",
]

# - И применяли стеммер к каждому из элементов списка с помощью list comprehension.

# +
# и создаем объект этого класса
porter = PorterStemmer()

# применяем метод .stem() к каждому слову с помощью list comprehension
stemmed_p: list[str] = [porter.stem(s) for s in lemmatized]
print(stemmed_p)
# -

# ## Кортежи.
# - Кортеж (tuple) инициализируется при помощи круглых скобок () или функции tuple().

# +
# создадим две переменные и поместим в них пустые кортежи
tuple_1: tuple[()] = ()
tuple_2: tuple[()] = ()
# tuple_2: tuple[()] = tuple()

print(tuple_1, tuple_2)
# -

# - Во многом кортеж похож на список. Это также упорядоченный набор элементов с индексом, начинающимся с нуля.

# +
# создадим кортеж
letters: tuple[str, str, str] = ("a", "b", "c")

# и выведем его первый элемент
letters[0]
# -

# - Например, заменить элемент по его индексу нельзя.

# +
# попробуем заменить первый элемент кортежа
# letters[0] = 'd'
# -

# ![image.png](attachment:image.png)

# - Для этого придется вначале преобразовать кортеж в список.

# +
# преобразуем кортеж в список через функцию list()
letters_2: list[str] = list(letters)

# теперь элементы можно изменять
letters_2[0] = "d"
letters_2
# -

# - Создать кортеж из одного элемента можно с помощью запятой.

let_a: tuple[str] = ("a",)
type(let_a)

# - Если запятую не ставить, получится строка.

let_a_str: str = "a"
type(let_a)

# ### Функция enumerate()
# - Если в цикле с функцией enumerate() использовать не две, как мы делали раньше, а одну переменную, результатом ее работы будет кортеж, состоящий из индекса и соответствующего элемента списка.
#

# +
# создадим список с названием трех компаний
companies: list[str] = ["Microsoft", "Apple", "Tesla"]

# и в цикле поместим результат работы функции enumerate()
# в одну переменную company
for company in enumerate(companies):
    print(company, type(company))
# -

# ## Просмотр элементов словаря.
# - Аналогично, если в цикле for к словарю применить знакомый нам метод .items() и использовать только одну переменную, мы получим кортежи из ключа и значения.

# +
# возьмем уже знакомый нам по вводному курсу словарь с овощами
shopping_dict: dict[str, int] = {"огурцы": 2, "помидоры": 3, "лук": 1, "картофель": 2}

# пройдемся по ключам и значениям с помощью метода .items(),
# но поместим результат в одну переменную item
for item in shopping_dict.items():
    print(item)
# -

# ### Распаковка кортежей.
# - Распаковать кортеж — значит поместить каждый из его элементов в отдельную переменную.

# если в кортеже три элемента, то и переменных должно быть три
a_1: str
b_1: str
c_1: str
a_1, b_1, c_1 = ("a", "b", "c")
# выведем переменную a
print(a_1)

# - Кортежи удобно распаковывать в цикле for.

# +
# снова возьмем список компаний
companies_2: list[str] = ["Microsoft", "Apple", "Tesla"]

# однако с функцией enumerate() используем две переменные
for idx, comp in enumerate(companies_2):
    print(idx, comp)
# -

# - С элементами словаря получается то же самое.

# +
shopping_dict_2: dict[str, int] = {"огурцы": 2, "помидоры": 3, "лук": 1, "картофель": 2}

# используем две переменные с методом .items()
for k_1, v_1 in shopping_dict_2.items():
    print(k_1, v_1)
# -

# ### Создание кортежа через функцию zip()
# - Функция zip() принимает два и более списка и формирует объект из кортежей. В первом кортеже содержатся первые элементы каждого из списков, во втором — вторые и так далее.
#
# ![image.png](attachment:image.png)

# +
# создадим два списка: список имен и список доходов
# names = ['Артем', 'Антон', 'Александр', 'Борис', 'Виктор', 'Геннадий']
# income = [97000, 110000, 95000, 84000, 140000, 120000]

# передадим эти списки функции zip()
# zip(names, income)
# -

# - Получившийся zip-объект нужно преобразовать в список.

# +
# list(zip(names, income))
# -

# zipped_list

# ## Множества.
#
# - Про множества важно запомнить три факта:
#     - элементы множества изменять нельзя;
#     - множество — это набор уникальных элементов, а значит повторы в нем удаляются;
#     - у множества нет индекса, элементы не упорядочены.
#
# ### Создание множества.
# - Множество можно создать с помощью функции set() или перечислив элементы в фигурных скобках {}.

# +
# создадим одно пустое
# set_1: set = set()

# и два непустых множества с повторяющимся элементом 'c'
# set_2: set[str] = {"a", "b", "c", "c"}
# set_3: set[str] = {"a", "b", "c", "c"}

# print(set_1, set_2, set_3)
# -

# - Обратите внимание, Питон вывел элементы множества не в том порядке, в котором они были изначально записаны, и кроме того удалил повторяющийся элемент 'c'.
# - Пустыми фигурные скобки оставлять нельзя. Это способ создания словаря.

# +
# not_a_set: dict = {}
# type(not_a_set)
# -

#
