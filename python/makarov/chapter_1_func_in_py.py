"""Функции в Питоне."""

# ### Встроенные функции

# +
# напомню, что мы создали список из кортежей
# и в каждом кортеже был
# индекс фильма и расстояние до него
# # функция может возвращать сразу два значения
# from typing import Callable, List, Tuple, Union

# # импортируем библиотеки
# import matplotlib.pyplot as plt

# # перед вызовом функции нужно не
# забыть импортировать соответствующую библиотеку
# import numpy as np

# # установим точку отсчета
# np.random.seed(42)
# # и снова сгенерируем данные о росте
# (как мы делали на восьмом занятии вводного курса)
# height = list(np.round(np.random.normal(180, 10, 1000)))

# +
# # теперь построим гистограмму передав
# ей два параметра, данные о росте и количество интервалов
# # первый параметр у нас позиционный, второй - именованный
# plt.hist(height, bins=10)
# plt.show()

# +
# # первый параметр можно также сделать именованным (данные обозначаются через x)
# # и тогда порядок параметров можно менять
# plt.hist(bins=10, x=height)
# plt.show()

# +
# # у параметра bins есть аргумент по умолчанию (как раз 10 интервалов),
# # а значит, этот параметр можно не указывать
# plt.hist(height)
# plt.show()

# +
# # функция может не принимать параметров
# print("Первая строка")
# print()
# print("Третья строка")

# +
# # дана строка
# some_string: str
# some_string = "machine learning"

# # применим метод .title()
# some_string.title()

# +
# # к списку
# some_list: list[str]
# some_list = ["machine", "learning"]

# # этот метод не применить
# some_list.title()
# -

# ### Собственные функции в Питоне

# ## Объявление и вызов функции
# Функции не обязательно должны быть встроены в базовый функционал или библиотеки. Мы вполне можем объявлять (т.е. создавать) собственные функции (user-defined functions). Рассмотрим пример.

# +
# # создадим функцию, которая удваивает любое передаваемое ей значение


# def double(numb1: int) -> int:
#     """Возвращает число умноженное на 2."""
#     result1 = numb1 * 2
#     return result1

# +
# # и вызовем ее, передав число 2
# double(2)

# +
# # тело функции не может быть пустым


# def only_return():
#     # нужно либо указать ключевое слово return
#     return

# +
# only_return()

# +
# # либо оператор pass


# def only_pass():
#     """Ничего не делает."""
#     pass

# +
# only_pass()

# +
# # такая функция вернет тип данных None (отсутствие значения)
# print(only_return())
# -

# #### Функция print() вместо return

# +
# # можно использовать print(), но есть нюансы (см. на странице урока)


# def double_print(numb2: int) -> int:
#     """Возвращает число умноженное на 2."""
#     result2 = numb2 * 2
#     print(result2)

# +
# double_print(5)
# -

# #### Параметры собственных функций

# +
# def calc_sum(number1: int, number2: int) -> int:
#     """Возвращает сумму двух целых чисел."""
#     return number1 + number2

# +
# # вызовем эту функцию с одним позиционным и одним именованным параметром
# calc_sum(1, number2=2)

# +
# # параметрам функции можно задать аргументы по умолчанию


# def calc_sum_default(number3: int = 1, number4: int = 2) -> int:
#     """Возвращает сумму двух целых чисел."""
#     return number3 + number4


# # и при вызове тогда их указывать не обязательно
# calc_sum_default()

# +
# # функция может не иметь параметров


# def print_string() -> str:
#     """Возвращает строку."""
#     print("Some string")


# print_string()
# -

# #### Аннотация функции

# +
# # укажем, что на входе функция принимает тип float, а возвращает int
# # значение 3,5 - это значение параметра x по умолчанию


# def f(number5: float = 3.5) -> int:
#     return int(number5)

# +
# # желаемый тип данных можно посмотреть через атрибут __annotations__
# f.__annotations__

# +
# # вызовем функцию без параметров
# f()

# +
# # сохраним аннотации, но изменим суть функции


# def f(number6: float) -> int:
#     """вместо int функция будет возвращать float"""
#     return float(number6)

# +
# # вновь вызовем функцию, передав ей на входе int, и ожидая на выходе получить float
# f(3)
# -

# #### Дополнительные возможности

# +
# # вызов функции можно совмещать с арифметическими
# calc_sum(1, 2) * 2

# +
# # и логическими операциями
# calc_sum(1, 2) > 2

# +
# # можно и так


# def first_letter() -> str:
#     """Возвращает строку."""
#     return "Python"


# first_letter()[0]

# +
# # функция может не принимать параметров, но использовать input()


# def use_input() -> int:
#     """Возвращает квадрат введеного числа/цифры."""
#     # запросим у пользователя число и переведем его в тип данных int
#     user_inp = int(input("Введите число: "))

#     # возведем число в квадрат
#     result = user_inp**2

#     # вернем результат
#     return result


# # вызовем функцию
# use_input()
# -

# #### Результат вызова функции

# +
# # функция может возвращать также список, кортеж, словарь и др.


# # объявим функцию, которая на входе получает число,
# # а на выходе формирует список чисел от 0 и до числа, предшествующего заданному
# def create_list(pl_in: int) -> list[int]:
#     """Возваращает список чисел от 0 до введеного."""
#     # создадим пустой список
#     list_qt = []

#     # в цикле for создадим последовательность
#     for nums in range(pl_in):

#         # и поместим ее в список
#         list_qt.append(nums)

#     return list_qt


# # результатом вызова этой функции будет список
# create_list(5)

# +
# """Возвращает строку и целое число."""


# def tuple_f() -> Tuple[str, int]:
#     string = "Python"
#     number7 = 42
#     return string, number7

# +
# # если использовать две переменные
# number8, number9 = tuple_f()

# # на выходе мы получим строку и число
# print(number8, number9)
# print(type(number8), type(number9))

# +
# # если одну
# number10 = tuple_f()

# # получится кортеж
# print(number10)
# print(type(number10))

# +
# # выводом может быть логическое значение (True или False)


# def if_divisible(div_n: int) -> bool:
#     """Проверяет четное число или нет."""
#     # если остаток от деления на два равен нулю
#     if div_n % 2 == 0:

#         # вернем True
#         return True

#     else:

#         # в противном случае False
#         return False


# if_divisible(10)
# -

# #### Использование библиотек

# +
# # применим функцию mean() библиотеки Numpy для расчета среднего арифметического


# # на входе наша функция примет список или массив x,
# def mean_f(ls_mean: list) -> list:
#     """Возварщает среднее арифметическое."""
#     # рассчитает среднее арифметическое и прибавит единицу
#     return np.mean(ls_mean) + 1

# +
# # и подготовить данные
# my_list: List[int]
# my_list = [1, 2, 3]

# mean_f(my_list)
# -

# #### Глобальные и локальные переменные

# +
# # создадим глобальную переменную вне функции
# global_name: str
# global_name = "Петр"

# # а затем используем ее внутри новой функции


# def show_name():
#     """Выводит глобальную переменную."""
#     print(global_name)

# +
# show_name()

# +
# # а теперь вначале создадим функцию,
# # внутри которой объявим локальную переменную


# def show_local_name() -> str:
#     """Выводит строку."""
#     local_name = "Алена"
#     print(local_name)

# +
# show_local_name()

# +
# при попытке обратиться к переменной
# вне функции мы получим ошибку
# local_name

# +
# # превратить локальную
# переменную в глобальную можно через ключевое слово global


# def make_global() -> str:
#     """Выводит строку."""
#     global local_name
#     local_name = "Алена"
#     print(local_name)

# +
# make_global()

# +
# # теперь ошибки быть не должно
# local_name

# +
# # объявим глобальную переменную
# global_number: int
# global_number = 5


# def print_number() -> int:
#     """Выводит число."""
#     # затем объявим локальную переменную
#     local_number = 10
#     print("Local number:", local_number)

# +
# # функция всегда "предпочтет" локальную переменную
# print_number()

# +
# # при этом значение глобальной
# переменной для остального кода не изменится
# print("Global number:", global_number)
# -

# ### Lambda-функции

# +
# # создадим функцию, которая
# принимает два числа и перемножает их
# lamb_f = lambda a, b: a * b

# # вызовем функцию и передадим ей числа 2 и 3
# lamb_f(2, 3)

# +
# # этот же функционал можно поместить в обычную функцию


# def normal_f(nums1: int, nums2: int) -> int:
#     """Возвращает произведение двух целых чисел."""
#     return nums1 * nums2


# normal_f(2, 3)
# -

# #### Lambda-функция внутри функции filter()

# +
# создадим список
# ls_nums = list[int]
# ls_nums = [15, 27, 9, 18, 3, 1, 4]

# напишем lambda-функцию, которая выведет True, если число больше 10, и False, если меньше
# criterion = lambda n: True if (n > 10) else False

#  поместим список и lambda-функцию в функцию
# filter() и преобразуем результат в список
# list(filter(criterion, ls_nums))

# +
#  все это можно записать в одну строчку
# list(filter(lambda n: True if (n > 10) else False, ls_nums))

# +
# ту же задачу можно решить через обычную функцию,
# но придется написать больше кода


# def criterion_2(num_n) -> bool:
#     """Проверка больше ли числи 10 или нет."""
#     if num_n > 10:
#         return True
#     else:
#         return False


# list(filter(criterion_2, ls_nums))
# -

# #### Lambda-функция внутри функции sorted()

# +
# indices_distances: List[Tuple[int, float]] = [
#     (901, 0.0),
#     (1002, 0.22982440568634488),
#     (442, 0.25401128310081567),
# ]

# # lambda-функция возьмет каждый кортеж и вернет второй [1] его элемент
# # передав эту функцию через параметр key, мы отсортируем список по расстоянию
# sorted(indices_distances, key=lambda x: x[1], reverse=False)
# -

# #### Немедленно вызываемые функции

# +
# # lambda-функцию можно вызвать сразу в момент объявления
# (lambda x: x * x)(10)

# +
# # *args и *kwargs
# # напишем функцию для расчета среднего арифметического двух чисел


# def mean(number11: int, number12: int) -> int:
#     """Считает среднее арифметичское двух чисел."""
#     return (number11 + number12) / 2

# +
# mean(1, 2)

# +
# # объявим функцию, которой нужно передать список


# def mean(list_):
#     """Считает среднее арифметическое."""
#     # зададим переменную для суммы,
#     total = 0

#     # в цикле сложим все числа из списка
#     for i in list_:
#         total += i

#     # и разделим на количество элементов
#     return total / len(list_)

# +
# # создадим список
# list_: list[int]
# list_ = [1, 2, 3, 4]

# # и передадим его в новую функцию
# mean(list_)

# +
# однако новая функция уже не может работать с отдельными числами
# mean(1, 2)

# +
# # объявим функцию с *args


# def mean(*nums) -> float:
#     """Считает среднее арифметическое."""
#     # в данном случае мы складываем элементы кортежа
#     total = 0
#     for i in nums:
#         total += i

#     return total / len(nums)

# +
# # теперь мы можем передать функции отдельные числа
# mean(1, 2, 3, 4)

# +
# # или список
# mean(*list_)

# +
# # убедимся, что оператор распаковки * формирует кортеж


# def test_type(*nums) -> tuple:
#     """Распаковывает и формирует кортеж."""
#     print(nums, type(nums))


# test_type(1, 2, 3, 4)

# +
# # со списком происходит то же самое
# test_type(*list_)

# +
# # для наглядности приведем еще один пример
# list1 = [1, 2, 3]
# list2 = [*list1, 4, 5, 6]

# print(list2)

# +
# # **kwargs преобразует именованные параметры в словарь


# def funcc(**kwargs) -> dict:
#     """Преобразует именованные параметры в словарь."""
#     return kwargs.items()

# +
# funcc(number13=1, number14=2)

# +
# def simple_stats(*nums: Union[int, float], **params: bool) -> None:
#     """Возвращает кортеж и словарь."""

#     if params.get("mean") is True:
#         print(f"mean:\t{np.round(np.mean(nums), 3)}")

#     if params.get("std") is True:
#         print(f"std:\t{np.round(np.std(nums), 3)}")

# +
# # вызовем функцию simple_stats() и передадим ей числа и именованные аргументы
# simple_stats(5, 10, 15, 20, mean=True, std=True)

# +
# # если для одного из параметров задать значение False,
# # функция не выведет соответствующую метрику
# simple_stats(5, 10, 15, 20, mean=True, std=False)

# +
# # если мы хотим передать параметры списком и словарем,
# llist_: list[int]
# settings: dict[str | bool]
# llist_ = [5, 10, 15, 20]
# settings = {"mean": True, "std": True}

# # то нам нужно использовать операторы распаковки * и ** соответственно
# simple_stats(*list_, **settings)

# +
# # ничто не мешает нам добавить еще один параметр
# simple_stats(5, 10, 15, 20, mean=True, std=True, median=True)
