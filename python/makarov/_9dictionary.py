"""Словарь."""

# ## Словарь.
# - Словари, наряду со списками, кортежами и множествами, также относятся к коллекциям (collections), т.е. типам данных, содержащим несколько элементов. Мы уже начали изучать словари на пятом занятии вводного курса. Продолжим этот путь.
# ### Понятие словаря в Питоне.
# - Словарь — неупорядоченный набор элементов с доступом по ключу.
#
# ![image.png](attachment:image.png)
#
# ### Создание словаря.
# - Пустой словарь можно инициализировать через фигурные скобки {} или функцию dict().

# +
# from pprint import pprint
from pprint import pprint

import numpy as np

dict_1: dict[str, int]
dict_2: dict[str, int]
dict_1, dict_2 = {}, {}
print(dict_1, dict_2)
# -

# - Словарь можно сразу заполнить ключами и значениями.

company: dict[str, str | int] = {
    "name": "Toyota",
    "founded": 1937,
    "founder": "Kiichiro Toyoda",
}
company

# - Словарь можно также создать из вложенных списков.

tickers: dict[str, str] = dict([["TYO", "Toyota"], ["TSLA", "Tesla"], ["F", "Ford"]])
tickers

# - Иногда бывает полезно создать словарь с заранее известными ключами и заданным значением. В этом нам поможет метод .fromkeys().

# +
# ключи мы поместим в кортеж
keys: tuple[str, str, str] = ("k1", "k2", "k3")

# значением каждого ключа будет 0,
# если ничего не указывать, ключи получат значение None
value: int = 0

empty_k: dict[str, int] = dict.fromkeys(keys, value)
empty_k
# -

# ### Ключи и значения словаря.
# - Ключами словаря могут быть только неизменяемые типы данных. Например, строки, числа, кортежи или логические значения (Boolean). Кроме того, ключи должны быть уникальными и соответственно не могут повторяться.
# - Значения словаря, наоборот, могут состоять из чисел, строк, пропущенных (NaN) и логических значений, значения типа None, списков, массивов Numpy и вложенных словарей.

# +
# mypy: ignore-errors
value_types = {
    "k1": 123,
    "k2": "string",
    "k3": np.NaN,
    "k4": True,  # логическое значение
    "k5": None,
    "k6": [1, 2, 3],
    "k7": np.array([1, 2, 3]),
    "k8": {1: "v1", 2: "v2", 3: "v3"},
}

value_types
# -

# ### Методы .keys(), .values() и .items()
# - Создадим словарь с данными сотрудника.

person: dict[str, str | int] = {
    "first name": "Иван",
    "last name": "Иванов",
    "born": 1980,
    "dept": "IT",
}

# - Как мы уже знаем, доступ к ключам и значениям можно получить через методы .keys() и .values() соответственно.

person.keys()

person.values()

# - Метод .items() возвращает и то, и другое в формате списка из кортежей.

person.items()

# ### Использование цикла for.
# - Ключи и значения словаря удобно просматривать с помощью цикла for и метода .items().

for k_1, v_1 in person.items():
    print(k_1, v_1)

# - Как мы уже знаем, если записать результат метода .items() в одну переменную, будут выведены кортежи из ключа и значения.
# - Использование в цикле for методов .keys() и .values() выводит только ключи или только значения соответственно.
# ### Доступ по ключу и метод .get()
# - Конкретное значение в словаре можно получить, введя название словаря и затем название ключа в квадратных скобках.

person["last name"]

# - Если такого ключа нет, Питон выдаст ошибку.

# +
# person['education']
# -

# ![image.png](attachment:image.png)
#
# - Для того чтобы этого не произошло, можно использовать метод .get(). Он также выводит значение по ключу.

person.get("born")

# - Если ключа в словаре нет, метод .get() возвращает значение None.

print(person.get("education"))

# ### Проверка наличия ключа и значения в словаре.
# - С помощью оператора in мы можем проверить наличие определенного ключа в словаре.

"born" in person

# - Важно сказать, что оператор in работает быстрее метода .get().
# - Метод .values() поможет проверить наличие определенного значения.

# +
# 1980 in person.values()
# -

# - Метод .items() поможет проверить наличие пары ключ : значение. Обратите внимание, эту пару мы записываем в форме кортежа.

# +
# ("born", 1980) in person.items()
# -

# ## Операции со словарями
# ### Добавление и изменение элементов
# - Добавить элемент можно, передав новому ключу новое значение.

# обратите внимание, в данном случае новое значение - это список
person["languages"] = ["Python", "C++"]  # type: ignore
person

# - Изменить элемент можно передав существующему ключу новое значение.

# значение - это по-прежнему список, но из одного элемента
person["languages"] = ["Python"]  # type: ignore
person

# - Метод .update() позволяет соединить два словаря.

# +
# возьмем еще один словарь
new_elements: dict[str, str | int] = {"job": "программист", "experience": 7}

# и присоединим его к существующему словарю с помощью метода .update()
person.update(new_elements)
person
# -

# - Метод .setdefault() не изменяет значение, если указанный ключ уже содержится в словаре.

person.setdefault("last name", "Петров")
person

# - Если такого ключа нет, ключ и соответствующее значение будут добавлены в словарь.

person.setdefault("f_languages", ["русский", "английский"])
person

# ### Удаление элементов.
# - Метод .pop() удаляет элемент по ключу и выводит удаляемое значение.

person.pop("dept")

# - Убедимся, что этой пары ключа и значения больше нет в словаре.

person

# - Ключевое слово del также удаляет элемент по ключу.

# удаляемое значение не выводится
del person["born"]

# - Метод .popitem() удаляет и выводит последний добавленный в словарь элемент.

person.popitem()

# - Метод .clear() удаляет все ключи и значения и возвращает пустой словарь.

person.clear()
person

# - Ключевое слово del также позволяет удалить словарь целиком.

# +
# удалим весь словарь
# del person

# если попытаться вновь вызвать эту переменную, Питон выдаст ошибку
# person
# -

# ![image.png](attachment:image.png)
#
# ### Сортировка словарей.
# - Для сортировки словарей можно использовать функцию sorted().

# возьмем несложный словарь
dict_to_sort: dict[str, int] = {"k2": 30, "k1": 20, "k3": 10}

# - Отсортируем ключи этого словаря.

sorted(dict_to_sort)

# - Теперь отсортируем значения с помощью метода .values().

sorted(dict_to_sort.values())

# - Если мы хотим отсортировать пары «ключ : значение» по ключу или по значению, вначале воспользуемся методом .items() для извлечения этих пар (кортежей) из словаря.

dict_to_sort.items()

# - Затем мы укажем эти кортежи в качестве первого аргумента функции sorted(). Параметру key этой же функции мы передадим lambda-функцию, которая вернет либо ключ lambda x : x[0] каждого кортежа, либо его значение lambda x : x[1]. Именно по ним и будет произведена сортировка.

# посмотрим на сортировку по ключу
sorted(dict_to_sort.items(), key=lambda x: x[0])

# а теперь по значению
sorted(dict_to_sort.items(), key=lambda x: x[1])

# ### Копирование словарей.
#

# создадим исходный словарь с количеством студентов на первом и втором курсах университета
original: dict[str, int] = {"Первый курс": 174, "Второй курс": 131}

# - Копирование объектов в Питоне (не только словарей) осуществляется с помощью метода .copy().

# +
# создадим копию исходного словаря с помощью метода .copy()
new_1: dict[str, int] = original.copy()

# добавим информацию о третьем курсе в новый словарь
new_1["Третий курс"] = 117

# выведем исходный и новый словари
print(original)
print(new_1)
# -

# - Как мы видим, исходный словарь не изменился. Так и должно быть.
# - Теперь давайте попробуем скопировать словарь с помощью оператора присваивания =.

# +
# передадим исходный словарь в новую переменную
new_2: dict[str, int] = original

# удалим элементы нового словаря
new_2.clear()

# выведем исходный и новый словари
print(original)
print(new_2)
# -

# - Данные были удалены из обоих словарей. Так быть не должно и поэтому такой метод копирования использовать не стоит.
# ### Пример со словарем.
# - Теперь поработаем со словарями. Предположим, что мы продолжаем спрашивать людей об их росте, и у нас есть несколько американцев, которые сообщили свой рост в футах.

height_feet: dict[str, float] = {"Alex": 6.1, "Jerry": 5.4, "Ben": 5.8}

# - Наша задача — создать точно такой же словарь, но чтобы футы были преобразованы в метры. Вначале создадим список с данными о росте в метрах.

# один фут равен 0,3048 метра
metres: list[float] = list(map(lambda m: m * 0.3048, height_feet.values()))
metres

# - Здесь мы снова воспользовались lambda-функцией, которую в качестве аргумента передали в функцию map(). Обратите внимание, вторым аргументом стали значения словаря, полученные через метод .values().
# - После этого мы можем снова воспользоваться функцией zip(), которой передадим ключи исходного словаря и список данных о росте с округлением до двух знаков после запятой.

dict(zip(height_feet.keys(), np.round(metres, 2)))

# - Как и в предыдущем примере, эту задачу можно решить с помощью dict comprehension.

# мы просто преобразуем значения словаря в метры
height_meters = {k: np.round(v * 0.3048, 2) for (k, v) in height_feet.items()}

# - Код соответствует основной схеме, приведенной выше, и в целом читается проще, чем конструкция с lambda-функцией и функцией map().
# ## Вложенные словари.
# - Рассмотрим более сложный словарь с информацией о нескольких сотрудниках.

employees: dict[str, dict[str, str | int]] = {
    "id1": {
        "first name": "Александр",
        "last name": "Иванов",
        "age": 30,
        "job": "программист",
    },
    "id2": {
        "first name": "Ольга",
        "last name": "Петрова",
        "age": 35,
        "job": "ML-engineer",
    },
}

# - В данном случае ключами словаря выступают id сотрудников, а значениями — вложенные словари с информацией о них.

for v_1 in employees.values():
    print(v_1)

# ## Базовые операции.
# - Для того чтобы вывести значение элемента вложенного словаря, воспользуемся двойным ключом.

# первый ключ - нужный нам сотрудник, второй - элемент с информацией о нем
employees["id1"]["age"]

# - Небольшое отступление от темы. Сложные структуры данных бывает удобно вывести с помощью функции pprint() одноименного модуля.

# - Функция pprint() расшифровывается как pretty print («красивая печать») и в некоторых случаях справляется со своей задачей лучше обычной функции print().
# - Посмотрим как можно добавить вложенный словарь.

# +
# добавим информацию о новом сотруднике
employees["id3"] = {
    "first name": "Дарья",
    "last name": "Некрасова",
    "age": 27,
    "job": "веб-дизайнер",
}

# и выведем обновленный словарь с помощью функции pprint()
pprint(employees)
# -

# - Изменить значение вложенного словаря можно также с помощью двойного ключа.

employees["id3"]["age"] = 26
pprint(employees)

# ## Циклы for
# - Посмотрим, как можно использовать цикл for со вложенными словарями. Давайте заменим тип данных с информацией о возрасте сотрудника с int на float.

# +
# для этого вначале пройдемся по вложенным словарям,
# т.е. по значениям info внешнего словаря employees
for info in employees.values():

    # затем по ключам и значениям вложенного словаря info
    for k_2, v_2 in info.items():

        # если ключ совпадет со словом 'age'
        if k_2 == "age":

            # преобразуем значение в тип float
            info[k_2] = float(v_2)

pprint(employees)
# -

# ## Вложенные словари и dict comprehension
# - Вложенные словари также допускают использование dict comprehension. Предположим, что мы хотим вернуть данные о возрасте из типа float обратно в тип int. Разобьем эту задачу на несколько этапов.
# - Шаг 1. Просто выведем словарь employees без изменений, используя dict comprehension.

pprint({id: info for id, info in employees.items()})

# - Шаг 2. Создадим еще один dict comprehension, с помощью которого внутри каждого вложенного словаря мы заменим тип данных значения с float на int, если ключ совпадает с age, если не сопадает — оставим значение без изменений (по сути, условие с if-else).

# pylint: disable=W0631
nev_zev = {k: (int(v) if k == "age" else v) for k, v in info.items()}
# pylint: enable=W0631

# - Шаг 3. Вставим второй dict comprehension в первый вместо переменной info. Напомнью, info — это значения внешнего словаря, которые сами по себе являются словарями. Именно к ним мы и применим второй dict comprehension.

pprint(
    {
        id: {k: (int(v) if k == "age" else v) for k, v in info.items()}
        for id, info in employees.items()
    }
)

# - С поставленной задачей мы справились. Впрочем, такая сложная схема dict comprehension идет вразрез с самой идеей этого метода, которая заключается в упрощении кода.
# ### Частота слов в тексте.
# - Напоследок разберем очень несложный пример подсчета частоты слов в тексте. Это уже знакомый нам мешок слов (Bag of Words, BoW). В качестве примера возьмем уже известный нам текст про Париж, музеи и искусство.

corpus: str = (
    "When we were in Paris we visited a "
    "lot of museums. We first went to the "
    "Louvre, the largest art museum in the "
    "world. I have always been interested in "
    "art so I spent many hours there. The museum "
    "is enormous, so a week there would not be enough."
)

# ### Предварительная обработка текста.
# - Превратим строку в список слов.

words: str = corpus.split()
print(words)

# - Применим list comprehension, чтобы избавиться от точек и запятых. Помимо этого, переведем все слова в нижний регистр.

words: str = [word.strip(".").strip(",").lower() for word in words]
print(words)

# - Мы готовы создавать мешки слов разными способами.
# ### Способ 1. Условие if-else
# - Начнем с простых условий if-else.

# +
# создадим пустой словарь для мешка слов bow
# bow_1 = {}

# пройдемся по словам текста
# for word in words:

# если нам встретилось слово, которое уже есть в словаре
#   if word in bow_1:

# увеличим его значение (частоту) на 1
#     bow_1[word] = bow_1[word] + 1

# в противном случае, если слово встречается впервые
#   else:

# зададим ему значение 1
#     bow_1[word] = 1

# отсортируем словарь по значению в убываюем порядке (reverse = True)
# и выведем шесть наиболее частотных слов
# sorted(bow_1.items(), key = lambda x : x[1], reverse = True)[:6]
# -

# ## Способ 2. Метод .get()
# - Помимо этого мы можем использовать метод .get().

# +
# bow_2 = {}

# for word in words:
#   bow_2[word] = bow_2.get(word, 0) + 1

# sorted(bow_2.items(), key = lambda x : x[1], reverse = True)[:6]
# -

# - Поясню приведенный код. Метод .get() проверит наличие ключа (слова) в словаре и, если его нет, выведет 0.

# +
# bow_2.get(word, 0)
# -

# - Далее мы прибавим к нулю единицу (потому что слово встретилось первый раз) и запишем это слово в наш словарь.

# +
# bow_2[word] = bow_2.get(word, 0) + 1
# -

# - Если такой ключ (слово) уже есть, метод .get() выведет его значение (частоту слова) и мы просто увеличим это значение на один.

# ## Способ 3. Класс Counter модуля collections
# - Напомню, что этот же функционал реализован в классе Counter модуля collections.

# +
# импортируем класс Counter
# from collections import Counter

# создадим объект этого класса, передав ему список слов
# bow_3 = Counter(words)

# выведем шесть наиболее часто встречающихся слов с помощью метода .most_common()
# bow_3.most_common(6)
# -

# - Результат. Обратите внимание, в отличие от мешка слов, который мы создавали на занятии по обработке естественного языка, в число наиболее популярных слов вошли артикли, предлоги и союзы. Они не несут полезной информации о содержании текста. Это так называемые стоп-слова. Кроме того, мы не провели лемматизацию, и поэтому museum и museums считаются разными словами.

# ## Ответы на вопросы
#
# - Вопрос. А что будет, если в словаре есть одинаковые ключи?
# - Ответ. Давайте посмотрим на примере. При создании словаря с одинаковыми ключами:

# +
# {'k1' : 1, 'k1' : 2, 'k1' : 3}
# Питон выведет:
# {'k1': 3}
# -

# - Как мы видим, Питон оставил только последний элемент из серии одинаковых ключей. Ошибки при этом не возникает.
#
# - Вопрос. Словарь — это изменяемый или неизменяемый тип данных в Питоне?
# - Ответ. Большое спасибо за отличный вопрос. Давайте в целом разберем, какие типы данных в Питоне считаются изменяемыми (mutable), а какие неизменяемыми (immutable).
# - Весь код на Питоне представляет собой объекты либо отношения между ними. У каждого объекта есть identity (адрес объекта в памяти компьютера), type (тип) и value (значение).
# - Создадим строковый объект и посмотрим на identity, type и value.

# +
# создадим объект
# string = 'Python'

# посмотрим на identity, type и value
# функция id() выводит адрес объекта в памяти компьютера
# id(string), type(string), string
# -

# - Теперь попробуем изменить этот объект.

# +
# расширим наше представление о Питоне
# string = string + ' is cool'

# посмотрим на identity, type и value
# id(string), type(string), string
# -

# -
#     - Как вы видите, адрес объекта в памяти изменился, а значит это уже другой объект и тип str относится к неизменяемым типам данных.
# - Теперь возьмем список, выведем его identity, type и value, добавим в этот список новый элемент и посмотрим как изменятся его свойства.

# +
# создадим список
# lst = [1, 2, 3]

# посмотрим на identity, type и value
# id(lst), type(lst), lst

# +
# добавим элемент в список
# lst.append(4)

# снова выведем identity, type и value
# id(lst), type(lst), lst

# -

# - Список пополнился новым элементом, при этом оставшись в той же ячейке памяти. Это изменяемый тип данных. В целом,
#     - к изменяемым типам данных относятся: список, словарь, множество и созданные пользователем классы;
#     - неизменяемые типы данных: int, float, bool, str, tuple и range.
# - Теперь посмотрим как свойство изменяемости и неизменяемости влияет на копирование объектов. Начнем со строки.

# +
# вновь создадим строку
# string = 'Python'

# скопируем через присваивание
# string2 = string

# изменим копию
# string2 = string2 + ' is cool'

# посмотрим на результат
# string, string2
# -

# - Благодаря тому, что при изменении строки был создан новый объект, копирование прошло успешно (исходная строка при изменении копии не была затронута). Тот факт, что мы имеем дело с разными объектами можно также проверить через оператор is.

# +
# оператор == сравнивает значения (values)
# оператор is сравнивает identities
# string == string2, string is string2
# -

# - Посмотрим, что будет со списком.

# +
# создадим список
# lst = [1, 2, 3]

# скопируем его в новую переменную через присваивание
# lst2 = lst

# добавим новый элемент в скопированный список
# lst2.append(4)

# выведем исходный список и копию
# lst, lst2
# -

# - В данном случае копирование через присваивание и последующее добавление новых элементов в список не создало новых объектов. По этой причине изменился как исходный объект, так и его копия.

# +
# убедимся, что речь идет об одном и том же объекте
# lst == lst2, lst is lst2
# -

# - Как и в случае со словарем, необходимо использовать метод .copy().

# +
# вновь создадим список
# lst = [1, 2, 3]

# скопируем с помощью метода .copy()
# lst2 = lst.copy()

# добавим новый элемент в скопированный список
# lst2.append(4)

# выведем исходный список и копию
# lst, lst2
# -

# - Теперь копирование прошло успешно. Прежде чем завершить, давайте добавим число четыре в исходный список и убедимся, что речь идет о разных объектах.

# +
# lst.append(4)

# lst, lst2, lst == lst2, lst is lst2
# -

# - Значения списков совпадают, а вот их адреса — нет.

#
