"""Функции в Питоне."""

# ## Функции в Питоне.
#
# - Функция в программировании не совсем то же самое, что функция в математике. В математике функция принимает одно значение и возвращает другое. В программировании — это программа в программе, отдельный участок кода, к которому можно обратиться по имени.
#
# ![image.png](attachment:image.png)
#
# - Зачем это нужно? Если у вас есть код, который используется несколько раз в рамках программы, то функция позволяет написать код один раз, а потом просто вызывать его (call a function) при необходимости. Так мы не дублируем код и лучше его структурируем.
#
# ### Встроенные функции.
#
# - В Питоне есть множество встроенных в (1) стандартный функционал (built-in functions) и (2) дополнительные библиотеки (library functions) функций, и мы много раз их использовали.
# - Рассмотрим функцию для создания гистограммы plt.hist(). Вначале импортируем библиотеки.

# +
import matplotlib.pyplot as plt
import numpy as np

# pylint: disable=line-too-long
# -

# - Сгенерируем данные, которые передадим этой функции (эти же данные мы создавали и использовали на восьмом занятии вводного курса).

# +
# установим точку отсчета для воспроизведения такого же результата
np.random.seed(42)

# и сгенерируем данные о росте
height: list[float] = list(np.round(np.random.normal(180, 10, 1000)))
# -

# - Теперь построим гистограмму, передав ей в качестве параметров и аргументов наши данные и количество интервалов.

plt.hist(height, bins=10)
plt.show()

# - Как мы видим, достаточно обратиться к соответствующей библиотеке ( plt), вызвать эту функцию по имени ( hist) и задать параметры и их аргументы ( heightи bins = 10), и будет исполнен тот код, который заложили в нее создатели библиотеки Matplotlib.
# - Теперь несколько слов про параметры и аргументы функции.
#
# ### Параметры и аргументы функции.
# - Для начала определимся с терминами:
#     - параметр — это то, что запрашивает функция при вызове (например, bins, количество интервалов);
#     - аргумент — значение этого параметра (в нашем случае, 10).
# - Возникает вопрос, что же такое height? Логично предположить, что это аргумент (ведь это наши данные). Но тогда как функция узнает, какому параметру он соответствует?
# - Все дело в том, что параметры и их аргументы могут быть позиционными (positional) и именованными (keyword).
#
# ![image.png](attachment:image.png)
#
# - В первом случае, достаточно указать аргумент и поставить его в правильном порядке (позиции). Функция сама поймет, какой параметр ей передают. Во втором случае, нужно указать и название параметра, и аргумент.
# - Позиционный параметр можно сделать именованным, и тогда порядок важен не будет.

# данные в этой функции обозначаются через x
plt.hist(bins=10, x=height)
plt.show()

# - Кроме того, функция может иметь параметры с аргументами по умолчанию. Это делает такой параметр не обязательным, а значит упрощает и ускоряет вызов функции.

# у параметра bins есть аргумент по умолчанию (как раз 10 интервалов)
# а значит, этот параметр можно не указывать
plt.hist(height)
plt.show()

# - Как вы видите, результат во всех трех случаях совершенно одинаковый.
# - Стоит отметить, что функция может как принимать один, два или несколько параметров, так и не принимать их вовсе. Например, функция print(), если не указывать параметры, выдает пустую строку.

print("Первая строка")
print()
print("Третья строка")

# ### Функции и методы.
#
# - Некоторые функции называются методами. Методы — это функции, которые можно применить только к конкретному объекту. Другими словами, если обычная функция будет выполнена «сама по себе», это просто участок кода, которому дали имя, то методу для исполнения нужен объект (например, строка, список или словарь). При этом, что важно, у каждого объекта свои методы.
# - Предположим, у нас есть строка, и мы хотим сделать первую букву каждого слова заглавной. Для этого у строки есть метод .title().

# +
# создаем строковый объект и
some_string: str = "machine learning"

# применяем к нему метод .title()
some_string.title()


# -

# - А теперь попробуем применить этот метод к списку, состоящему из тех же слов, что и строка.

# +
# some_list = ["machine", "learning"]
# some_list.title()
# AttributeError: 'list' object has no attribute 'title'
# -

# - Как мы видим, Питон выдал ошибку.
#
# ## Собственные функции в Питоне.
# ### Объявление и вызов функции.
# - Функции не обязательно должны быть встроены в базовый функционал или библиотеки. Мы вполне можем объявлять (т.е. создавать) собственные функции (user-defined functions). Рассмотрим пример.


# создадим функцию, которая удваивает
# любое передаваемое ей значение
def double(x_1: int) -> int:
    """Удваивает значение."""
    res = x_1 * 2
    return res


# и вызовем ее, передав число 2
double(2)


# - Теперь давайте разберем каждый элемент этого кода. Вначале посмотрим как объявить функцию (declare a function).
#
# ![image.png](attachment:image.png)
#
#     - ключевое слово def необходимо для объявления функции;
#     - далее идут название функции, которое вы сами определяете; и
#     - параметры, которые может принимать ваша функция;
#     - после двоеточия на новой строке с отступом идет так называемое тело функции, то есть то, что будет исполняться при вызове функции;
#     - в конце ставится ключевое слово return, возвращающее результат работы функции.
# - Затем, когда это необходимо, мы можем вызвать функцию (call a function), указав ее имя и передав, при их наличии, соответствующие аргументы внутри круглых скобок.
#
# ![image-2.png](attachment:image-2.png)
#
# ### Пустое тело функции.
# - Оставлять тело функции совсем пустым нельзя. Нужно как минимум указать ключевое слово return или оператор pass.
#
#


# тело функции не может быть пустым
def only_return() -> None:
    """Пустое тело функции."""
    # нужно либо указать ключевое слово return
    return


only_return()


# либо оператор pass
def only_pass() -> None:
    """Пустое тело функции с заглушкой."""
    pass  # pylint: disable=unnecessary-pass


only_pass()

# - Хотя может показаться, что в этом случае функция ничего не выдает, на самом деле это не так. И в том, и в другом случае функция возвращает особый тип данных None (отсутствие значения).

print(only_return())  # type: ignore[func-returns-value]


# ### Функция print() вместо return.
# - Помимо ключевого слова return, результат работы функции можно вывести с помощью print().


def double_print_2(x_2: int) -> None:
    """Вывод с помощью print."""
    res_2: int = x_2 * 2
    print(res_2)


double_print_2(5)


# - Хотя визуально вывод идентичен, отличие все-таки есть:
#     - Использование return возвращает значение функции (в нашем случае значение переменной res) и прерывает ее работу;
#     - Функция print() просто выводит это значение пользователю и не влияет на дальнейшее исполнение кода, если он есть.
#
# ### Параметры собственных функций.
#
# - С точки зрения параметров, у собственных функций те же самые возможности, что и у встроенных функций. В частности, параметры могут быть позиционными и именованными.


# +
# объявим функцию с параметрами x и y,
def calc_sum(x_1: int, y_1: int) -> int:
    """Суммирование."""
    # которая возвращает их сумму
    return x_1 + y_1


# вызовем эту функцию с одним позиционным и одним именованным параметром
calc_sum(1, y_1=2)


# -

# - Параметры собственной функции также могут быть заданы по умолчанию. В этом случае при вызове функции их указывать не обязательно.


# +
def calc_sum_default(x_2: int = 1, y_2: int = 2) -> int:
    """Параметры заданы по умолчанию."""
    return x_2 + y_2


calc_sum_default()


# -

# - И конечно функция может изначально не иметь параметров.


# +
# эта функция просто выводит текст 'Some string'
def print_string() -> None:
    """Без начальных пераметров."""
    print("Some string")


print_string()


# -

# ### Аннотация функции.
#
# Аннотация функции (function annotation) позволяет явно прописать тип данных параметров (parameter annotation) и возвращаемых значений (return annotation).


# укажем, что на входе функция принимает тип float, а возвращает int
# значение 3,5 - это значение параметра x по умолчанию
def f_(x_anot: float = 3.5) -> int:
    """Аннотации."""
    return int(x_anot)


# желаемый тип данных можно посмотреть через атрибут __annotations__
f_.__annotations__

# вызовем функцию без параметров
f_()


# - Аннотация не является обязательной и никак не вляет на выполнение кода.


# сохраним аннотации, но изменим суть функции
def f_fl(x_flo: int) -> float:
    """Меняет int на float."""
    # теперь вместо int она будет возвращать float
    return float(x_flo)


# вновь вызовем функцию, передав ей на входе int, и ожидая на выходе получить float
f_fl(3)

# ### Дополнительные возможности функций.
#
# - Вызов функции можно совмещать с арифметическими операциями.

# вызовем объявленную выше функцию и умножим ее вывод на два
calc_sum(1, 2) * 2  # pylint: disable=expression-not-assigned

# - Доступны и логические операции.

calc_sum(1, 2) > 2  # pylint: disable=expression-not-assigned


# - Если результатом вывода является строка, то у этой строки также есть индекс.


# +
def first_letter() -> str:
    """Индекс строки."""
    return "Python"


# обратимся к первой букве слова Python
first_letter()[0]  # pylint: disable=expression-not-assigned


# -

# - Функция может не использовать параметры, но получать данные от пользователя через input().


# +
def use_input() -> int:
    """Возведение в степень."""
    # запросим у пользователя число и переведем его в тип данных int
    user_inp: int = int(input("Введите число: "))

    # возведем число в квадрат
    result: int = user_inp**2

    # вернем результат
    return result


# вызовем функцию
use_input()


# -

# - Появится окно для ввода числа.
#
# ![image.png](attachment:image.png)
#
# Введем число 5 и посмотрим на результат.
#
# ### Результат вызова функции.
#
# - Функция не обязательно возвращает только число или строку, это может быть, в частности, список, кортеж или словарь. Рассмотрим несколько примеров.


# +
# объявим функцию, которая на входе получает число,
# а на выходе формирует список чисел от 0 до числа,
# предшествующего заданному
def create_list(x_lst: int) -> list[int]:
    """Формирование списка."""
    # создадим пустой список
    l_int: list[int] = []

    # в цикле for создадим последовательность
    for i in range(x_lst):

        # и поместим ее в список
        l_int.append(i)

    return l_int


# результатом вызова этой функции будет список
create_list(5)


# -

# - Функция может возвращать сразу несколько значений.


def tuple_f() -> tuple[str, int]:
    """Возвращает несколько значений."""
    string: str = "Python"
    x_str: int = 42
    return string, x_str


# - Если результат вызова этой функции записать в две переменных, то ожидаемо в них окажется строка и число.
#

a_ret, b_ret = tuple_f()
print(a_ret, b_ret)
print(type(a_ret), type(b_ret))

# - Если записать в одну, то получится кортеж.

c_cort = tuple_f()
print(c_cort)
print(type(c_cort))


# - Функция может возвращать и логическое значение. Давайте объявим функцию, которая проверяет четное ли ей передали число (и в этом случае вернет True) или нечетное (и тогда False).


# +
# проверим равен ли нулю остаток от деления на два
def if_divisible(x_b: int) -> bool:  # noqa: FNE005
    """Возвращает булево значение."""
    if x_b % 2 == 0:  # pylint: disable=R1703,R1705
        return True
    else:
        return False


# попробуем с числом 10
if_divisible(10)


# -

# ### Использование библиотек.
#
# - Внутри функций можно использовать дополнительные библиотеки Питона. Например, применим функцию mean() библиотеки Numpy для расчета среднего арифметического.


# +
# mypy: disable-error-code="no-any-return,return-value"
# pylint: disable=redefined-outer-name
# на входе функция примет список или массив x,
def mean_f(x_4: list[int]) -> float:
    """Находим среднее арифметичское."""
    # рассчитает среднее арифметическое и прибавит единицу

    return np.mean(x_4) + 1


# перед вызовом функции нужно не забыть импортировать соответствующую библиотеку


# и подготовить данные
x_4: list[int] = [1, 2, 3]

mean_f(x_4)
# -

# ### Глобальные и локальные переменные.
# - Некоторые переменные существуют (или как еще говорят, видны) только внутри функции, другие во всей программе. В первом случае, говорят про локальные переменные (local variables), во втором — про глобальные (global variables). Сразу приведем несложный пример.

# +
# создадим глобальную переменную ВНЕ функции
global_name: str = "Петр"

# а затем используем ее внутри новой функции


def show_name() -> None:
    """Глобальная переменная."""
    print(global_name)


# -

show_name()


# - Здесь никаких проблем не возникло. Мы создали глобальную переменную и потом легко использовали ее внутри очередной функции. Обратное не всегда возможно.


# а теперь вначале создадим функцию,
# внутри которой объявим локальную переменную
def show_local_name() -> None:
    """Создание локальной переменной."""
    local_name: str = "Алена"
    print(local_name)


show_local_name()

# - Функция была вызвана без проблем. При этом если мы попробуем обратиться к переменной local_name вне этой функции, Питон выдаст ошибку.

# +
# local_name
# NameError: name 'local_name' is not defined
# -

# - Все дело в том, что область видимости этой переменной ограничена функцией show_local_name(). Для того чтобы она была видна во всей программе, можно использовать ключевое слово global.

# +
# def make_global() -> None:
# """Меняем локальную переменную на глобальную."""
# global local_name  # pylint: disable=global-variable-undefined
# local_name: str = "Alena"
# print(local_name)

# +
# make_global()

# +
# теперь ошибки быть не должно
# local_name
# -

# - Давайте посмотрим, что будет, если есть две переменные с одинаковым названием, причем одна из них глобальная, а вторая — локальная.

# +
# объявим глобальную переменную
# global_number = 5

# def print_number():
# затем объявим локальную переменную
#  local_number = 10
#  print('Local number:', local_number)
# -

# - Функция всегда «предпочтет» содержащуюся в ней локальную переменную.

# +
# print_number()
# -

# - При этом значение глобальной переменной для остального кода не изменится.
#
#

# +
# print('Global number:', global_number)
# -

# ### Анонимные или lambda-функции.
# - Функции создают не только через ключевое слово def и название функции. Можно использовать слово lambda и вообще обойтись без названия (отсюда и второе название — анонимная (anonymous) функция).
# - Приведем простой пример.

# +
# создадим функцию, которая принимает два числа и перемножает их
# lf = lambda a, b: a * b

# вызовем функцию и передадим ей числа 2 и 3
# lf(2, 3)
# -

# - Теперь давайте в деталях рассмотрим, как мы получили такой результат.
#
# ![image.png](attachment:image.png)
#
#     - вначале ставится ключевое слово lambda;
#     - за ним идут передаваемые параметры;
#     - через двоеточие пишется исполняемое выражение.
# - Разумеется, ничто не мешает поместить этот же функционал в обычную функцию.

# +
# def normal_f(a, b):
#  return a * b

# normal_f(2, 3)
# -

# - Анонимную функции при этом удобно использовать в тех случаях, когда применение обычной функции избыточно. Продемонстрирую на примере.
#
# ### Lambda-функция внутри функции filter().
# - Предположим, у нас есть список чисел, и мы хотим оставить в нем только те числа, которые больше 10. Давайте решим эту задачу с помощью функции filter() и lambda-функции.
# - Функция filter() принимает два параметра:
#     - Во-первых, еще одну функцию, выполняющую роль критерия; она выдает True, если элемент нужно оставить, и False — если убрать;
#     - Во-вторых, набор элементов, которые нужно отфильтровать в виде списка, кортежа или множества.
# - Получив их, filter() применяет критерий (функцию) к каждому из элементов набора.
# - Посмотрим на реализацию на Питоне. Вначале создадим список.

# +
# nums = [15, 27, 9, 18, 3, 1, 4]
# -

# - Теперь зададим фильтрующую lambda-функцию.

# +
# буквально мы пишем:
# "для каждого n, выдай True, если число больше 10, иначе - False"
# criterion = lambda n: True if (n > 10) else False
# -

# - После этого поместим criterion и nums в функцию filter(). Так как сама функция filter() вернет нам не список, а специальный объект iterator, его в свою очередь нужно преобразовать обратно в список с помощью функции list().

# +
# list(filter(criterion, nums))
# -

# - Чаще такой функционал записывают в одну строку.

# +
# list(filter(lambda n: True if (n > 10) else False, nums))
# -

# - И в этом и заключается удобство lambda-функции, ее не надо объявлять заранее. Через обычную функцию код выглядел бы так.

# +
# def criterion_2(n):
#  if n > 10:
#    return True
#  else:
#    return False

# list(filter(criterion_2, nums))
# -

# ### Lambda-функция внутри функции sorted()
# - Теперь рассмотрим lambda-функцию в коде, который мы использовали на занятии по рекомендательным системам. Воспроизведем в миниатюре часть решения из того занятия.
# - В какой-то момент мы получили список из кортежей. И в каждом кортеже был индекс фильма и расстояние до него.

# +
# indices_distances = [(901, 0.0), (1002, 0.22982440568634488), (442, 0.25401128310081567)]
# -

# - Затем мы захотели отсортировать этот список по расстоянию, то есть по второму элементу кортежа.
# - Мы взяли функцию sorted() и в качестве параметра ключа, по которому сортировать список (key), передали ей lambda-функцию, принимающей кортеж из двух элементов на входе, и выдающей второй его элемент на выходе.

# +
# sorted(indices_distances, key = lambda x: x[1], reverse = False)
# -

# - Параметр reverse = False, напомню, задает сортировку по возрастанию. В данном случае, от наименьшего расстояния до искомого фильма к наибольшему.
#
# ### Немедленно вызываемые функции.
# - Lambda-функции относятся к так называемым немедленно вызываемым функциям или immediately invoked function expressions (IIFE). Это означает, что мы можем одновременно объявить и вызвать такую функцию.

# +
# обратите внимание на использование скобок
# (lambda x: x * x)(10)
# -

# ## *args и **kwargs
# - режде чем завершить, поговорим про еще одну важную тему, а именно про так называемые *args (сокращение от arguments) и **kwargs (keyword arguments).
# - Они позволяют передавать функции различное количество позиционных (*args) или именованных (**kwargs) аргументов.
# - Рассмотрим на примере. Начнем с *args.
#
# ### *args
# - Предположим, что у нас есть простая функция, которая принимает два числа и вычисляет их среднее арифметическое значение.

# +
# объявим функцию
# def mean(a, b):
#  return (a + b) / 2

# и передадим ей числа 1 и 2
# mean(1, 2)
# -

# - Все отлично работает, но мы не можем передать этой функции больше двух чисел. Возможным решением станет функция, которая изначально принимает список в качестве аргумента.

# +
# объявим функцию, которой нужно передать список
# def mean(list_):

# зададим переменную для суммы,
#  total = 0

# в цикле сложим все числа из списка
#  for i in list_:
#    total += i

# и разделим на количество элементов
# return total / len(list_)

# +
# создадим список
# list_ = [1, 2, 3, 4]

# и передадим его в новую функцию
# mean(list_)
# -

# - Все опять же работает, но нам каждый раз нужно создавать список. При попытке передать отдельные числа функция выдаст ошибку.

# +
# mean(1, 2)

# +
# объявим функцию с *args
# def mean(*nums):
#  total = 0
#  for i in nums:
#    total += i
#  return total / len(nums)

# +
# mean(1, 2, 3, 4)
# -

# - Как вы видите, главным элементом здесь является оператор распаковки * (unpacking operator). Он принимает все передаваемые в функцию числа и формирует из них кортеж.
# - Затем мы проходимся по элементам этого кортежа, рассчитываем их сумму и делим на количество элементов. Использовать слово args не обязательно, мы назвали наш позиционный аргумент nums.
# - Если мы по какой-то причине захотим передать функции список, мы можем это сделать.

# - *args позволяет передавать функции произвольное количество отдельных чисел.

# +
# передадим в функцию список
# mean(*list_)
# -

# - В этом случае мы передаем название списка со звездочкой *.
# - Для того чтобы убедиться, что отдельные числа и списки преобразуются в кортеж, напишем вот такую несложную функцию.

# +
# def test_type(*nums):
#  print(nums, type(nums))

# +
# test_type(1, 2, 3, 4)

# +
# test_type(*list_)
# -

# - Для наглядности приведем еще один, не относящийся напрямую к работе функции, пример.

# +
# a = [1, 2, 3]
# b = [*a, 4, 5, 6]

# print(b)
# -

# - Как мы видим, здесь распаковка произошла в список.
#
# ### **kwargs
# - При использовании **kwargs происходит почти то же самое за тем исключением, что мы распаковываем именованные, а не позиционные аргументы. И распаковываем их в словарь, а не в кортеж или список. Сразу посмотрим на примере.

# +
# def f(**kwargs):
#  return kwargs.items()

# +
# оператор ** примет произвольное количество именованных аргументов
# и внутри функции сформирует из них словарь
# f(a = 1, b = 2)
# -

# - Приведем более сложный пример. Напишем функцию, которая на вход примет произвольное количество чисел (позиционный аргумент), преобразует в кортеж (*args) и рассчитает среднее арифметическое (mean) и среднее квадратическое отклонение (standard deviation).
# - Для каждой из метрик мы дополнительно создадим именованный параметр, который определит, выводить эту метрику или нет. Параметры мы передадим через **kwargs. Внутри функции из них будет сформирован словарь.

# +
# nums функция преобразует в кортеж, params - в словарь
# def simple_stats(*nums, **params):

# если ключ 'mean' есть в словаре params и его значение == True
#  if 'mean' in params and params['mean'] == True:

# рассчитаем среднее арифметическое кортежа nums и округлим
# \t - это символ табуляции
#    print(f'mean: \t{np.round(np.mean(nums), 3)}')

# если ключ 'std' есть в словаре params и его значение == True
#  if 'std' in params and params['std'] == True:

# рассчитаем СКО кортежа nums и округлим
#    print(f'std: \t{np.round(np.std(nums), 3)}')
# -

# - Вызовем функцию simple_stats() и передадим ей числа и именованные аргументы.

# +
# simple_stats(5, 10, 15, 20, mean = True, std = True)
# -

# - Если для одного из параметров задать значение False, функция не выведет соответствующую метрику.

# +
# simple_stats(5, 10, 15, 20, mean = True, std = False)
# -

# - Для того чтобы передать параметры списком и словарем, нам нужно использовать операторы распаковки * и ** соответственно.

# +
# list_ = [5, 10, 15, 20]
# settings = {'mean' : True, 'std' : True}

# simple_stats(*list_, **settings)
# -

# - Количество именованных аргументов в **kwargs может быть любым. Ничто не мешает нам добавить еще один параметр.

# +
# добавим параметр median
# simple_stats(5, 10, 15, 20, mean = True, std = True, median = True)
# -

# - Впрочем, для того чтобы это имело смысл, такой параметр должен быть прописан внутри функции.
# - В заключение скажу, что все приведенные выше примеры являются учебными и без *args и **kwargs здесь конечно можно обойтись. На практике, они применяются в более сложных конструкциях, например, в так называемых декораторах, однако эта тема выходит за рамки сегодняшнего занятия.

# ## Ответы на вопросы
# - Вопрос. Скажите, а почему используется символ нижнего подчеркивания в названии переменной list_?
# - Ответ. Не стоит использовать просто list для именования переменных, потому что это слово зарезервировано для названия функции list(). Аналогично не стоит использовать dict, tuple, set и т.д. При этом некоторые слова использовать в качестве названия переменных просто не получится. Питон выдаст ошибку. Это, например, if, for, True, False, import и т.п.
# - Символ подчеркивания является одним из вариантов решения.
