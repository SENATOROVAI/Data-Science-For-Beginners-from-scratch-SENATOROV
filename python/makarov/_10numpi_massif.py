"""Массив Numpy."""

# ## Массив Numpy.
# - Первое знакомство с библиотекой NumPy (Numerical Python) состоялось на двенадцатом занятии вводного курса. Затем мы несколько раз использовали эту библиотеку при построении моделей. Пришло время посвятить ее функционалу отдельный раздел.
# - Библиотека Numpy является основой для многих других библиотек в Питоне, например, Pandas, Matplotlib, scikit-learn или scikit-image. Главный объект библиотеки — массив Numpy (Numpy array). О нем мы поговорим сегодня.
# - На следующем занятии мы изучим математические операции над массивами, а через одно — рассмотрим работу со случайными числами.
#
# ## Понятие массива Numpy.
# - Массив Numpy — это многомерный массив (ndarray, n-dimensional array) данных, над которыми можно быстро и эффективно выполнять множество математических, статистических, логических и других операций.
# - Приведу пример массива с нулевым измерением, а также одно-, двух- и трехмерного массивов.
#
# ![image.png](attachment:image.png)
#
# - Теперь посмотрим как работать с этими массивами на практике.
# - Вначале нужно импортировать библиотеку Numpy.

# +
# импортируем библиотеку matplotlib
import matplotlib.pyplot as plt

# библиотеку Numpy принято сокращать как np
import numpy as np

# импортируем функцию csr_matrix()
from scipy.sparse import csr_matrix

# mypy: ignore-errors
# -

# ## Как создать массив Numpy.
# - Рассмотрим два варианта создания одномерного массива.
#
# ### Функция np.array()
# - Во-первых, массив можно создать с помощью функции np.array(), которой мы передаем, например, список или кортеж элементов.

# создадим массив из списка
arr_mas: np.ndarray = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
arr_mas

# или кортежа
arr_cor: np.ndarray = np.array((0, 1, 2, 3, 4, 5, 6, 7, 8, 9))
arr_cor

# ### Функция np.arange()
# - Кроме того, можно воспользоваться функцией np.arange(). Эта функция, как и функция range(), с которой мы уже знакомы, создает последовательность элементов. Обязательным параметром является верхняя граница, которая не входит в последовательность.

# создадим последовательность из 10 элементов
arr_1: np.ndarray = np.arange(10)
arr_1

# - Нижняя граница и шаг обязательными не являются.

# зададим нижнюю и верхнюю границу и шаг
# На некоторых системах используют int32
# поэтому нужно преобзарозывать  dtype=np.int64
arr: np.ndarray = np.arange(2, 10, 2, dtype=np.int64)
print(arr)

# - Отличие range() от функции np.arange() заключается в том, что первая не допускает использования типа float.

# +
# создадим список с помощью функций range() и list()
# list(range(2, 5.5, 0.5))
# -

# ![image.png](attachment:image.png)
#
# - При этом в массиве Numpy тип float вполне может использоваться.

np.arange(2, 5.5, 0.5)

# ### Тип данных элементов массива.
# - Как вы уже вероятно обратили внимание, в массивах тип данных определяется автоматически. При этом при создании массива мы можем задать этот параметр принудительно.

# +
# создадим массив с элементами типа float
arr_f: np.ndarray = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], float)

print(arr_f)

# тип данных можно посмотреть через атрибут dtype
print(arr_f.dtype)
# -

# - Обратите внимание, в отличие, например, от списков, чаще всего в массивах содержатся элементы только одного типа (в частности, int или float).
#
# ## Свойства (атрибуты) массива.
# - Возьмем массив, который мы создали выше.

arr

# - Важным свойством (или как правильнее говорить атрибутом) массива является количество его измерений, ndim. В данном случае это одномерный массив или вектор.

arr.ndim

# - Теперь, с помощью атрибута shape, посмотрим на количество элементов в каждом измерении.

arr.shape

# - Обратите внимание, даже когда массив одномерный, результат атрибута shape выводится в виде кортежа (на это указывают круглые скобки и запятая после цифры четыре).
# - Атрибут size показывает общее количество элементов во всех измерениях.

# пока что у нас одно измерение, в котором четыре элемента
arr.size

# - Как уже было сказано выше, атрибут dtype показывает тип данных отдельного элемента.

# в нашем случае - это целое число длиной 64 бита
arr.dtype

# - Атрибут itemsize позволяет узнать размер в байтах (один байт состоит из 8 бит) одного элемента. В нашем случае, элемент (число) состоит из 64 бит, что составляет восемь байтов.

# 64 / 8 бит = 8 байтов
arr.itemsize

# - Общий размер массива в байтах (nbytes) позволяет понять, в частности, поместится ли массив в оперативную память компьютера.

# у нас четыре элемента по восемь байтов или 32 байта
arr.nbytes

# - Тот же результат можно получить, умножив общее количество элементов на размер одного элемента в байтах.

arr.size * arr.itemsize

# ## Измерения массива.
# - Как уже было сказано, ndarray (массив Numpy) — это многомерный массив. Давайте еще раз взглянем на массивы с различными измерениями, добавив только что изученные атрибуты этих массивов.
#
# ![image.png](attachment:image.png)
#
# - Теперь подробнее поговорим про размерность. Измерения (dimensions) создаются за счёт вложения одного массива в другой с помощью квадратных скобок []. Начнем с массива с нулевой размерностью.
#
# ### Массив с нулевой размерностью.
# - Массив с нулевой размерностью — это число (скаляр) и квадратных скобок не имеет.

arr_0d: np.ndarray = np.array(42)
arr_0d

# - Посмотрим на свойства этого массива.

print(arr_0d.ndim)
print(arr_0d.shape)
print(arr_0d.size)

# - Атрибут shape показывает отсутствие размерности, а size указывает на один элемент в массиве.
#
# ### Одномерный массив (вектор).
# - Вложив несколько массивов с нулевой размерностью в квадратные скобки, мы получим одномерный массив или вектор.

arr_1d: np.ndarray = np.array([1, 2, 3])
arr_1d

# ### Двумерный массив (матрица)
# - Поместив во вторые квадратные скобки, например, два одномерных массива, мы получим двумерный массив или матрицу.

# с точки зрения синтаксиса - это просто вложенные списки
arr2d: np.ndarray = np.array([[1, 2, 3], [4, 5, 6]])
arr2d

# Посмотрим на свойства.
print(arr2d.ndim)
print(arr2d.shape)
print(arr2d.size)

# - Атрибут size двумерного массива более интуитивно понятен. В данном случае два элемента одного измерения умножены на три элемента второго.
# - Добавлю, что с точки зрения Numpy матрица с одной строкой или одним столбцом — это разные объекты. Начнем с матрицы, которая имеет три вектора по одному элементу.

column: np.ndarray = np.array([[1], [2], [3]])
column

# посмотрим на размерность
column.shape

# - Теперь наоборот, создадим матрицу с одной строкой, в которой три элемента.

row_2: np.ndarray = np.array([[1, 2, 3]])
row_2

# размерность будет иной
row_2.shape

# ### Трехмерный массив.
# - Теперь создадим трехмерный массив, внутри которого будут два двумерных массива 2 х 3. Общее количество элементов будет равно двенадцати (2 х 2 х 3). Визуально это можно представить как стек (наложение) двух матриц.
#
# ![image.png](attachment:image.png)
#
# - При этом, вместо того чтобы вручную прописывать все 12 значений, мы последовательно воспользуемся функцией np.arange() и методом np.reshape().

arr_3d: np.ndarray = np.arange(12).reshape(2, 2, 3)
arr_3d

# - Функция np.arange(), как мы уже видели выше, создаст одномерный массив из 12 элементов, а метод np.reshape() распределит их по измерениям. Выведем атрибуты.

print(arr_3d.ndim)
print(arr_3d.shape)
print(arr_3d.size)

# -
#     - Обратите внимание, атрибут shape сначала выводит размерность внешнего измерения, в нем две матрицы. Далее в каждую матрицу вложены два одномерных вектора. В каждом векторе по три элемента.
# - Аналогичным образом создаются четырехмерные массивы, а также массивы с большим количеством измерений.
#
# ### Понятие тензора.
# - Добавлю, что в математике n-мерный массив называется тензором, а числа (скаляры), векторы и матрицы являются его частными случаями для нуля, одного и двух измерений соответственно.
#
# ![image.png](attachment:image.png)
#
# ## Другие способы создания массива.
# ### Массив из нулей
# - Иногда бывает полезно создать массив, все элементы которого равны нулю. Для этого используется функция np.zeros().

# ей мы можем передать одно значение для создания одномерного массива
np.zeros(5)

# или кортеж из чисел для указания количества нулей в каждом измерении
np.zeros((2, 3))

# ### Массив из единиц.
# - В тех случаях когда нужно создать массив, заполненный единицами, можно воспользоваться функцией np.ones().

# создадим трехмерный массив
np.ones((2, 2, 3))

# ### Массив, заполненный заданным значением.
# - Функция np.full() создает массив, заполненный заданным значением.

# создадим матрицу 2 х 3 и заполним ее цифрой четыре
np.full((2, 3), 4)

# ## Пустой массив Numpy.
# - В отличие от предыдущих инструментов, функция np.empty() возвращает массив заданной размерности, но без инициализации его значений. Другими словами, пустой массив.

# создадим пустую матрицу 3 х 2
np.empty((3, 2))

# - Кроме того, любой массив Numpy можно преобразовать в описанные выше массивы с помощью функций np.zeros_like(), np.ones_like(), np.full_like() и np.empty_like(). Приведу пример для np.zeros_like().

# создадим массив 2 x 3 с числами от 1 до 6
a_mas: np.ndarray = np.arange(1, 7).reshape(2, 3)
a_mas

# и превратим его в массив с нулями
np.zeros_like(a_mas)

# ### Функция np.linspace()
# - Функция np.linspace() позволяет указать диапазон начального и конечного значений, а также количество равноудаленных точек внутри этого диапазона (включая начальное и конечное значения).

# создадим диапазон от 0 до 0,9 и
# разделим его на десять точек, включая 0 и 0,9
np.linspace(0, 0.9, 10)

# - Обратите внимание, функция np.linspace() сама определяет, где расставить точки. Нам нужно лишь указать их количество. Этим она отличается от функции np.arange(), в которой мы указываем шаг в пределах заданного диапазона.

# с функцией np.arange мы точно знаем, где будут расположены точки
np.arange(0, 1, 0.1)

# - Функцию np.linspace() удобно использовать для построения графиков функций.

# +
# зададим размер графика в дюймах
plt.figure(figsize=(8, 6))

# зададим интервал, например, от -5 до 5 и сформируем на нем 5000 точек
# это будут наши координаты по оси x
x_g = np.linspace(-5, 5, 5000)

# по оси y отложим квадрат этих точек
y_g = x_g**2

# создадим сетку
plt.grid()

# выведем кривую и подписи на графике
plt.plot(x_g, y_g)
plt.xlabel("x", fontsize=14)
plt.ylabel("y", fontsize=14)

# результатом будет парабола
plt.show()
# -

# - В качестве примера выведем первые 10 точек, созданные функцией np.linspace().

x_g[:10]

# ### Функции np.random.rand() и np.random.randint()
# - Массивы можно также создавать с помощью функций, генерирующих псевдослучайные числа. В частности, функция np.random.rand() создает массив заданной размерности, заполненный числами от 0 до 1 (единица в диапазон не входит).

np.random.rand(4, 3)

# - Функция np.random.randint() формирует массив целых чисел в заданном диапазоне (верхняя граница не входит в диапазон) и с заданной размерностью.

# создадим массив размерностью 2 x 3 x 2 c числами [-3, 3)
np.random.randint(-3, 3, size=(2, 3, 2))

# - Более подробно с этими и другими похожими функциями мы познакомимся на занятии по модулю random.
#
# ### Создание массива из функции.
# - Помимо вышеупомянутых способов массив можно создавать с помощью собственных функций. Для того чтобы понять, как это работает, вначале давайте вспомним координаты массива Numpy.
#
# ![image.png](attachment:image.png)
#
# - Функция np.fromfunction() берет координаты (i, j) каждой ячейки и передает их в собственную функцию. Посмотрим, как это работает на практике.

# +
# создадим собственную функцию, которая принимает два числа
# и возводит первое число в степень второго


def power(i_fanc: int, j_fanc: int) -> float | int:
    """Создание собственной функции."""
    result = i_fanc**j_fanc
    return result  # type: ignore[no-any-return]


# -

# - Теперь применим эту функцию к каждой ячейке (координатам) массива с размерностью (3, 3).

np.fromfunction(power, (3, 3))

# - В np.fromfunction() можно передать и lambda-функцию.

# напишем lambda-функцию, которая принимает два числа и
# проверяет равны ли они (тогда она выводит True) или нет (тогда False)
lambda i_fanc, j_fanc: i_fanc == j_fanc

# ## Матрица csr и метод .toarray()
# - Кроме этого в случае если данные хранятся в формате csr (сжатое хранения строкой, compressed sparse row), то мы можем преобразовать их обратно в массив Numpy с помощью метода .toarray().

a_mat: np.ndarray = np.array(
    [[2, 0, 0, 1, 0, 0, 0], [0, 0, 3, 0, 0, 2, 0], [0, 0, 0, 1, 0, 0, 0]]
)
a_mat

# - Долю нулевых значений несложно посчитать через функцию np.count_nonzero() и атрибут size.

1.0 - np.count_nonzero(a_mat) / a_mat.size  # pylint: disable=expression-not-assigned

# - Преобразуем матрицу в формат csr.

# и применим ее к матрице А
b_mat = csr_matrix(a_mat)
print(b_mat)

# - Вернем матрицу csr обратно в формат массива Numpy.

c_mat = b_mat.toarray()
c_mat

# - Напомню, что с форматом csr мы впервые познакомились, когда изучали рекомендательные системы. Метод .toarray() мы активно применяли на занятии по обработке естественного языка.

# ## Индексы и срезы.
# ### Индекс элемента массива.
# - Подобно спискам, к элементам массива можно получить доступ по их индексу. Главное отличие — необходимо учитывать наличие измерений. Вначале рассмотрим индексы массива на схеме.
#
# ![image.png](attachment:image.png)
#
# - Если мы хотим получить доступ к элементу массива, то необходимо вначале указать индекс внешнего измерения (оно будет первым по счету в выводе атрибута shape), а затем индекс внутреннего.
#     - Другими словами, мы двигаемся как бы снаружи вовнутрь, перемещаясь из одного измерения в другое.
# - Посмотрим, как это реализовать на Питоне. Создадим двумерный массив.

a_massive: np.ndarray = np.array([[1, 2, 3], [4, 5, 6]])
a_massive

# - Посмотрим на измерения и количество элементов в каждом из них.

a_massive.shape

# - Выведем первый элемент первого (внешнего) измерения.

# первый элемент представляет собой вектор
a_massive[0]

# Второй индекс позволяет обратиться, например, к первому элементу первого вектора.
a_massive[0][0]

# Теперь выведем значение шесть.
a_massive[1][2]

# ## Срез массива.
# - В массиве Numpy доступны и срезы (slice). Срез одномерного массива очень похож на срез списка.

# создадим одномерный массив
b_massive: np.ndarray = np.array([1, 2, 3, 4, 5, 6, 7, 8])
b_massive

# Возьмем каждый второй элемент в интервале с 1-го по 6-й индекс.
b_massive[1:6:2]

# - Посмотрим на схему.
#
# ![image.png](attachment:image.png)
#
# - Когда измерений больше одного, внутри квадратных скобок измерения отделяются запятой. Создадим двумерный массив.

c_massive: np.ndarray = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
c_massive

# - Сделаем срез из первой строки (внешнее измерение) и первых двух столбцов (внутреннее измерение).

# 0 указывает на первую строку, диапазон :2 - на первые два столбца
c_massive[0, :2]

# - Если нужно взять все элементы одного из измерений, достаточно поставить двоеточие без указания индекса.

# возьмем обе строки во втором столбце
c_massive[:, 1]

# - С помощью среза можно вывести конкретный элемент массива.

# выведем элемент в первой строке и первом столбце
c_massive[0, 0]

# - Другими словами, c[0, 0] == c[0][0].
#     - Кроме того, обратите внимание, что индекс в формате array[i, j] и координаты элементов массива, которые мы рассмотрели ранее, это одно и то же.
# - Допускаются срезы с отрицательным индексом.

# выведем элемент в последней строке и последнем столбце
c_massive[-1, -1]

# - Рассмотрим более сложный пример. Возьмем всю вторую строку [1] и каждый второй столбец [::2].
#
#

c_massive[1, ::2]

# - Теперь создадим массив с тремя измерениями.

# -1 означает, что Питон сам рассчитает количество элементов в этом измерении
d_massive: np.ndarray = np.arange(16).reshape(4, 2, -1)
d_massive

# - Можно сказать, что наш 3D массив состоит из четырех матриц 2 x 2.
# - Вначале выведем значение десять. Если идти снаружи вовнутрь, получается, что это третья матрица [2], второй вектор [1] и первый элемент [0].
#

d_massive[2][1][0]

# - Для срезов понадобится две запятых.

# выведем третью и четвертую матрицу [2:]
# и в них вторую строку [1] и все столбцы [:]
d_massive[2:, 1, :]

# - Если указать только один срез, мы будем работать только во внешнем измерении (с четырьмя матрицами).

# выведем первые две матрицы массива
d_massive[:2]

# - Прежде чем завершить разговор про срезы, выведем первые строки каждой матрицы.

d_massive[:, 0, :]

# ## Оси массива.
# - С концепцией измерения массива тесно связано понятие оси (axis, множественное число — axes). У массива столько же осей, сколько и измерений. Мы уже столкнулись с осями двух и трехмерного массивов, когда работали с изображениями.
# - Рассмотрим этот вопрос ещё раз.
#
# ## Массив 2D
# - В двумерном массиве два измерения и соответственно две оси.
#
# ![image.png](attachment:image.png)
# -
#     - В документации Numpy существует такое понятие как первая и последняя ось. Применительно к двумерному массиву, ось 0 — это первая ось, а ось 1 — последняя.
# - Многие, в частности, математические и статистические методы в Numpy предполагают указание параметра оси. Продолжим работу с приведенным выше двумерным массивом.

arr_2d_bev: np.ndarray = np.array([[1, 2], [3, 4]])
arr_2d_bev

# ### Сложение вдоль первой оси (axis = 0)
# - Найдем сумму по столбцам (вдоль оси 0).

np.sum(arr_2d_bev, axis=0)

# ![image.png](attachment:image.png)
#
# ### Сложение вдоль второй оси (axis = 1)
# - Теперь найдем сумму по строкам (вдоль оси 1).

np.sum(arr_2d_bev, axis=1)

# - ![image.png](attachment:image.png)
# -
#     - Обратите внимание, хотя axis = 0 принято ассоциировать со строками двумерного массива, сложение происходит вдоль вертикальной оси или по столбцам. Параметр axis = 1, отвечающий за столбцы, наоборот предполагает сложение вдоль горизонтальной оси по строкам.
# - При таких операциях говорят, что мы агрегируем (aggregate) данные и сворачиваем (collapse) или сокращаем (reduce) измерения вдоль определенной оси. И действительно, в каждой из описанных выше операций двумерный массив превратился в одномерный.
#
# ### Сложение вдоль обеих осей (axis = (0, 1))
# - Если в параметр axis передать кортеж с указанием обеих осей (0, 1), сумма будет рассчитана сначала вдоль оси 0, затем вдоль оси 1.

np.sum(arr_2d_bev, axis=(0, 1))

# ![image.png](attachment:image.png)
#
# - Если параметр axis не указывать, сумма также будет рассчитана по всем элементам массива.

np.sum(arr_2d_bev)

# - В этом случае «под капотом» стоит значение по умолчанию axis = None.

np.sum(arr_2d_bev, axis=None)

# ### Отрицательные значения в параметре axis
# - Массив Numpy допускает отрицательное значение параметра axis. Параметр axis = −1 соответствует последней по счету оси, то есть оси 1.

np.sum(arr_2d_bev, axis=-1)

# - Сложение вдоль оси 0 соответствует параметру axis = −2.

np.sum(arr_2d_bev, axis=-2)

# ## Массив 3D
# - Расположение осей трехмерного массива не всегда бывает очевидным.
# - Как уже было сказано, оси тесно связаны с измерениями и понять какая ось первая, какая вторая, а какая третья проще всего через атрибут shape. Вновь рассмотрим приведенный выше трехмерный массив.
#
# ![image.png](attachment:image.png)
#
# - Как мы видим, первая ось (axis = 0) в параметре shape всегда стоит на первом месте.
# ## Сложение вдоль первой оси (axis = 0)
# - Применим функцию np.sum() с параметром axis = 0.

np.sum(arr_3d, axis=0)

# - Визуально это можно представить как поэлементное сложение двух матриц.
#
# ![image.png](attachment:image.png)
#
# - Если использовать индексы массива, то поэлементное сложение вдоль оси 0 можно реализовать следующим образом.

# возьмем первую матрицу
arr_3d[0]

# возьмем вторую матрицу
arr_3d[1]

# и поэлементно сложим их
arr_3d[0] + arr_3d[1]

# - Эту же задачу можно решить с помощью цикла for. Вначале нам нужно создать нулевую матрицу, размерность которой будет соответствовать желаемому результату сложения вдоль оси 0.

# создадим нулевую матрицу размером 2 x 3
total: np.ndarray = np.zeros((2, 3))

# - Теперь создадим цикл for с двумя итерациями (потому что мы складываем две матрицы внутри трехмерного массива) через функцию range() с параметром 2.

for i in range(2):
    total += arr_3d[i]

# - Внутри цикла мы на первой итерации (i равно 0) запишем в нулевой массив нашу первую матрицу, а на второй итерации (i равно 1) поэлементно прибавим вторую. Переменная i в данном случае стала индексом для массива arr_3D.

total

# -
#     - Мы применили цикл for к массиву Numpy исключительно в учебных целях. На практике этого стоит избегать. Встроенные функции Numpy исполняются гораздо быстрее.
#
# ### Сложение вдоль второй оси (axis = 1)
# - Теперь посмотрим на сложение с параметром axis = 1.

# применим np.sum()
np.sum(arr_3d, axis=1)

# - Сложение вдоль оси 1 предполагает, что мы складываем столбцы каждой матрицы.
#
# ![image.png](attachment:image.png)
#
# - Посмотрим на сложение через индексы.

# сложим столбцы первой
arr_3d[0][0] + arr_3d[0][1]

# и второй матрицы
arr_3d[1][0] + arr_3d[1][1]

# - Теперь, опять же в учебных целях, решим эту задачу через цикл for.

# +
# создадим нулевую матрицу 2 x 3
total = np.zeros((2, 3))

# вначале пройдемся по матрицам
for i in range(2):

    # затем по строкам каждой матрицы
    for j_s in range(2):

        # и в первую строку total запишем сумму столбцов первой матрицы arr_3D,
        # а во вторую - сумму столбцов второй матрицы
        total[i] += arr_3d[i][j_s]

total
# -

# ### Сложение вдоль третьей оси (axis = 2)

# применим np.sum()
np.sum(arr_3d, axis=2)

# - Сложение вдоль оси 2 предполагает, что мы складываем строки каждой матрицы.
#
# ![image.png](attachment:image.png)
#
# - Покажем сложение строк через индексы для первой строки первой матрицы [0, 1, 2].

arr_3d[0][0][0] + arr_3d[0][0][1] + arr_3d[0][0][2]

# +
# создадим нулевой массив 2 x 2 для записи результатов
total = np.zeros((2, 2))

# пройдемся по матрицам
for i in range(2):

    # по строкам матрицы
    for j_st in range(2):

        # и по столбцам
        for k_st in arr_3d[i][j_st]:

            # индексы i, j запишут результат сложения элементов строк k
            # в квадратную матрицу 2 x 2
            total[i][j_st] += k_st

total
# -

# ### Сложение вдоль первой и второй осей (axis = (0, 1))

# применим функцию np.sum()
np.sum(arr_3d, axis=(0, 1))

# - Здесь мы объединили две операции сложения вначале вдоль оси 0, затем вдоль оси 1. Схемы этих операций можно посмотреть выше.
# - В цикле for этот алгоритм можно реализовать либо (1) через два отдельных цикла, либо (2) через вложенные друг в друга циклы. При использовании двух циклов (1) мы вначале складываем матрицы.

# +
# произведем сложение по оси 0
total_0 = np.zeros((2, 3))

for i in range(2):
    total_0 += arr_3d[i]

total_0
# -

# - На втором этапе мы складываем столбцы предыдущего результата.

# +
# произведем сложение по оси 1
total_1 = np.zeros(3)

for j_string in range(2):
    total_1 += total_0[j_string]

total_1
# -

# - При использовании вложенных циклов (2) мы пройдемся по строкам каждой матрицы и поэлементно сложим их (т.е. произведем сложение по столбцам).

# +
total = np.zeros(3)

for i in range(2):
    for j_str_1 in range(2):
        total += arr_3d[i][j_str_1]

total
# -

# ### Сложение вдоль всех трех осей (axis = (0, 1, 2))
# - При сложении вдоль всех трех осей мы можем указать каждую ось в параметре axis.

np.sum(arr_3d, axis=(0, 1, 2))

# - Кроме того, аналогично двумерному массиву, если параметр axis не указывать, сложение также будет произведено по всем измерениям.

np.sum(arr_3d)

# - Реализация алгоритма через цикл for в данном случае достаточно проста.

# +
total = 0  # type: ignore

# в трех вложенных циклах мы пройдемся по всем элементам массива
for i in range(2):
    for j_q in range(2):
        for k_q in range(3):

            # и запишем сумму этих элементов в переменную total
            total += arr_3d[i][j_q][k_q]

total
# -

# - В целом, результатом сложения по всем измерениям для массива любой размерности будет скаляр (число).
#     - Обратите внимание, при работе с трехмерным массивом также происходит агрегирование данных и сокращение измерений. Исчезает та ось или измерение, вдоль которого осуществлялось сложение.
# - Напоследок замечу, что мы использовали функцию np.sum() в большей степени для иллюстриции операций вдоль определенной оси.
#
# ## Операции с массивами.
# ### Функция len()
# - Вновь возьмем трехмерный массив.

arr_3d_nev: np.ndarray = np.arange(12).reshape(2, 2, 3)
arr_3d_nev

# - По умолчанию функция len() выводит длину внешнего измерения (ось 0). Это внешние скобки, в которых содержатся две матрицы 2 x 3.

len(arr_3d)

# - Для того чтобы вывести, например, длину внутреннего измерения, т.е. вектора из трех элементов (ось 1), нужно воспользоваться индексом.

len(arr_3d[0][0])

# ## Вхождение элемента в массив.
# - Проверим, входит ли значение 3 в созданный выше массив arr_3D.

3 in arr_3d

# Теперь проверим, не входит ли значение 11.
11 not in arr_3d

# ## Распаковка массива.
# - Возьмем матрицу из трех строк и девяти столбцов.

a_m: np.ndarray = np.arange(1, 28).reshape(3, 9)
a_m

# - Во внешнем измерении (ось 0) три элемента. Мы можем распаковать (unpack) их в три переменные.

x_m, y_m, z_m = a_m

# - Выведем первую переменную (строку).

x_m

# - Теперь распакуем первый, последний и остальные элементы первой строки в отдельные переменные.

x_m, *y_m, z_m = a_m[0]

# Выведем каждую переменную.
print(x_m)
print(y_m)
print(z_m)

# ## Изменение элементов массива.
# - Обратимся к двумерному массиву.

arr_2d_nev: np.ndarray = np.array([[1, 2, 3], [4, 5, 6]])
arr_2d_nev

# Заменим первый элемент первой строки по его индексу.
arr_2d_nev[0, 0] = 2
arr_2d_nev

# - Запишем значение 1 в первую строку.

arr_2d_nev[0] = 1
arr_2d_nev

# Пусть третий столбец массива состоит из нулей.
arr_2d_nev[:, 2] = 0
arr_2d_nev

# Теперь потренируемся с трехмерным массивом.
arr_3d_n: np.ndarray = np.arange(12).reshape(2, 2, 3)
arr_3d_n

# Выберем второй столбец второй матрицы и заменим
# значения столбца 7 и 10 на 0 и 1.
# при такой операции размер среза должен совпадать
# с количеством передаваемых значений
arr_3d_n[1, :, 1] = [0, 1]
arr_3d_n

# Заменим все элементы массива на число семь с помощью метода .fill().
arr_3d_n.fill(7)
arr_3d_n

# ## Сортировка массива и обратный порядок его элементов.
# ### Функция np.sort()
# - Возьмем двумерный массив.

a_nev_mas: np.ndarray = np.array([[4, 8, 2], [2, 3, 1]])
a_nev_mas

# - Как и во многих других функциях главное разобраться с применением параметра axis. По умолчанию сортировка идет с параметром axis = −1 (последняя ось).

np.sort(a_nev_mas)

# Для двумерного массива это ось 1.
np.sort(a_nev_mas, axis=1)

# Теперь посмотрим на сортировку по оси 0.
np.sort(a_nev_mas, axis=0)

# - Параметр axis = None вначале возвращает одномерный массив, а затем сортирует его.

np.sort(a_nev_mas, axis=None)

# ### Обратный порядок элементов массива.
# - Для того чтобы задать обратный порядок элементов, можно использовать оператор среза с параметром шага −1.

_ = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])[::-1]

# - Обратный порядок элементов можно совмещать со срезами.

# обратите внимание, мы используем и положительный, и отрицательный индексы
_ = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])[-3:3:-1]

# - Теперь возьмем двумерный массив.
#
#

a_two = np.array([[4, 8, 2], [2, 3, 1], [1, 7, 2]])
a_two

# С помощью оператора среза можно задать обратный порядок по двум измерениям.
# такая запись аналогична параметру axis = (0, 1)
a_two[::-1, ::-1]

# - Разумеется, мы можем задать обратный порядок только по внешнему или только внутреннему измерениям.

# обратный порядок по внешнему (axis = 0)
a_two[::-1]

# и внутреннему измерению (axis = 1)
a_two[:, ::-1]

# - Помимо этого, обратный порядок можно задать через функцию np.flip(). По умолчанию эта функция задает обратный порядок по двум измерениям.

# то же самое, что axis = (0, 1)
np.flip(a_two)

# - Отдельно можно задать порядок по внешнему и внутреннему измерениям.

# внешнее измерение
np.flip(a_two, axis=0)

# внутреннее измерение
np.flip(a_two, axis=1)

# ### Сортировка в убывающем порядке.
# - Возможно вы обратили внимание, что при использовании функции np.sort() мы сортировали элементы только в возрастающем порядке. По другому она не умеет. Для того чтобы отсортировать элементы в убывающем порядке можно воспользоваться оператором среза.
#
#

# возьмем простой одномерный массив
a_2: np.ndarray = np.array([4, 2, 6, 1, 7, 3, 5])

# - Одновременно применим функцию np.sort() и оператор среза с параметром шага −1.

print(np.sort(a_2)[::-1])

# - Обращу ваше внимание, что исходный массив не изменился.

a_2

# - При этом можно воспользоваться и методом .sort().

# здесь нужно сначала задать обратный порядок, а потом отсортировать
print(np.sort(a_2)[::-1])

# - Изменится исходный массив.

a_2

# ## Изменение размерности.
# ### Метод .reshape()
# - Возьмем простой трехмерный массив.

arr_3d_2: np.ndarray = np.arange(12).reshape(2, 2, 3)
arr_3d_2

# в нем 12 элементов
arr_3d_2.size

# - С помощью метода .reshape() мы можем изменить количество измерений. Например, мы можем превратить этот массив в матрицу с размерностью 2 x 6.

# при этом важно, чтобы общее количество элементов было тем же
arr_2d_res = arr_3d_2.reshape(2, 6)
arr_2d_res

# ### Функция np.resize() и метод .resize()
# - С другой стороны, если мы хотим не только задать другую размерность, но и изменить общее количество элементов, то мы можем воспользоваться функцией np.resize() и методом .resize().

# функция np.resize() позволяет не сохранять прежнее количество элементов
# существующие элементы копируются в новые ячейки
np.resize(arr_2d_res, (3, 6))

# - Перед тем как воспользоваться методом .resize() нам необходимо создать копию массива arr_2D. Все дело в том, что переменная arr_2D ссылается на другой массив (в частности, на трехмерный массив arr_3D), а метод .resize() может работать только с исходным массивом.

arr_2d_copy = arr_2d_res.copy()

# - Метод .resize() также создаст отдельную копию, изменит размерность и заполнит пропуски нулями.

arr_2d_copy.resize(4, 6)
arr_2d_copy

# ### Методы .flatten() и .ravel()
# - Метод .flatten() переводит («вытягивает») массив в одно измерение и создает копию исходного массива (как метод .copy()).

arr_3d_2.flatten()

# -
#     - Напомню, что концепцию вытягивания массива мы использовали при работе с изображениями на занятиях по компьютерному зрению и основам нейронных сетей.
# - Метод .ravel() делает то же самое, но не создает копию исходного массива и за счет этого быстрее, чем .flatten().

arr_3d_2.ravel()

# - Метод .ravel() мы использовали на занятии по обработке естественного языка.
# ### np.newaxis
# - Объект np.newaxis добавляет измерение в уже существующем массиве.

# создадим одномерный массив
a_one: np.ndarray = np.array([1, 2, 3])
a_one.shape

# - Мы можем добавить в этот массив новое первое измерение и, таким образом, сделать существующее измерение вторым.

# +
b_one = a_one[np.newaxis, :]

print(b_one)
print(b_one.shape)
# -

# - Аналогично, мы можем добавить новое второе измерение, а существующее измерение оставить первым.

# +
c_one = a_one[:, np.newaxis]

print(c_one)
print(c_one.shape)
# -

# ### Функция np.expand_dims()
# - Функция np.expand_dims() добавляет измерение, указанное в параметре axis. Возьмем двумерный массив.

a_next: np.ndarray = np.array([[1, 2], [3, 4]])
a_next

# Добавим внешнее измерение.
np.expand_dims(a_next, axis=0)

# Теперь добавим измерение «по середине».
np.expand_dims(a_next, axis=1)

# А также внутреннее измерение.
np.expand_dims(a_next, axis=2)

# ### Функция np.squeeze()
# - Возьмем массив 4D, в котором первое и последнее измерения содержат по одному элементу.

arr_4d: np.ndarray = np.arange(9).reshape(1, 3, 3, 1)
arr_4d

# - Удалим эти измерения с помощью функции np.squeeze().

np.squeeze(arr_4d)

# Новый массив имеет только два измерения.
_ = np.squeeze(arr_4d).shape

# ## Объединение массивов.
# ### Функция np.concatenate()
# - Предположим, что у нас есть два квардратных массива a и b размерностью 2 x 2.

a_end: np.ndarray = np.arange(4).reshape(2, 2)
a_end

b_end: np.ndarray = np.arange(4, 8).reshape(2, 2)
b_end

# - Объединим массивы вдоль оси 0 без добавления нового измерения.

np.concatenate((a_end, b_end), axis=0)

# - Точно так же массивы можно объединить вдоль оси 1.

np.concatenate((a_end, b_end), axis=1)

# ### Функция np.stack()
# - Отличие функции np.stack() от np.concatenate() в том, что при объединении массивов мы добавляем новое измерение (новую ось).

# при axis = 0 мы просто добавляем внешнее измерение
np.stack((a_end, b_end), axis=0)

# - Несколько более сложным оказывается поведение при axis = 1 и axis = 2.

# при axis = 1 мы объединяем первые и вторые строки двух массивов
np.stack((a_end, b_end), axis=1)

# при axis = 2 объединяются элементы с одинаковыми индексами
np.stack((a_end, b_end), axis=2)
