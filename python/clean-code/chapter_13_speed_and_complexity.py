"""Speed and complexity."""

# # Глава 13. Измерение быстродействия и анализ сложности алгоритмов
#
# ## 1. Модуль timeit
#
# ### Основные принципы
#
# - **Преждевременная оптимизация** — корень всех зол в программировании
# - Хитроумные трюки часто приводят к нечитаемому коду без реального улучшения производительности
# - Измерение необходимо для объективной оценки быстродействия
#
# ### Использование timeit
#
# ```python
# import timeit
#
# # Измерение одной строки кода
# timeit.timeit("a, b = 42, 101; a, b = b, a")
#
# # Измерение многострочного кода
# timeit.timeit(
#     """a, b = 42, 101
# a = a ^ b
# b = a ^ b
# a = a ^ b"""
# )
#
# # С подготовительным кодом и настройкой количества итераций
# timeit.timeit("random.randint(1, 100)", "import random", number=10000000)
# ```
#
# ### Важные особенности
#
# - Модуль запускает код тысячи/миллионы раз для усреднения
# - Временно отключает сборщик мусора для стабильных результатов
# - Для доступа к переменным использовать `globals=globals()`
#
# ## 2. Профилировщик cProfile
#
# ### Назначение
#
# - Анализ целых функций или программ
# - Детальная информация о времени выполнения каждого вызова функции
#
# ### Использование
#
# ```python
# import cProfile
#
# cProfile.run("функция_для_анализа()")
# ```
#
# ### Результаты профилирования
#
# - **ncalls** — количество вызовов функции
# - **tottime** — общее время выполнения функции (без подфункций)
# - **percall** — время на один вызов
# - **cumtime** — накопленное время (включая подфункции)
# - **filename:lineno(function)** — местоположение функции
#
# ### Закон Амдала
#
# Формула ускорения: `1 / ((1 — p) + (p / s))`
#
# - s — ускорение компонента
# - p — доля компонента в общем времени
# - **Вывод**: оптимизация самых медленных частей дает наибольший эффект
#
# ## 3. Нотация «O-большое»
#
# ### Определение
#
# Метод анализа алгоритмов, описывающий масштабирование времени выполнения с ростом объема данных.
#
# ### Основные порядки сложности (от быстрых к медленным)
#
# #### Быстрые алгоритмы
#
# 1. **O(1) — постоянное время**
#
#     - Время не зависит от размера данных
#     - Пример: проверка, пуста ли полка
# 2. **O(log n) — логарифмическое время**
#
#     - Алгоритмы "разделяй и властвуй"
#     - Пример: бинарный поиск в отсортированном массиве
#
# #### Хорошие алгоритмы
#
# 3. **O(n) — линейное время**
#
#     - Время растет пропорционально размеру данных
#     - Пример: чтение всех элементов списка
# 4. **O(n log n) — время N-Log-N**
#
#     - Все эффективные алгоритмы сортировки
#     - Пример: сортировка слиянием, быстрая сортировка
#
# #### Медленные алгоритмы
#
# 5. **O(n²) — полиномиальное время**
#
#     - Время растет квадратично
#     - Пример: поиск дубликатов в неупорядоченном списке
# 6. **O(2ⁿ) — экспоненциальное время**
#
#     - Перебор всех комбинаций
#     - Пример: фотографирование всех возможных комбинаций книг
# 7. **O(n!) — факториальное время**
#
#     - Перебор всех перестановок
#     - Пример: задача коммивояжера
#
# ## 4. Анализ алгоритмов
#
# ### Четыре шага определения сложности
#
# 1. **Определить n** — размер входных данных
# 2. **Подсчитать шаги** — количество операций
# 3. **Исключить низшие порядки** — оставить доминирующий
# 4. **Исключить коэффициенты** — убрать константы
#
# ### Пример анализа
#
# ```python
# def readingList(books):  # n = len(books)
#     print("Here are the books:")  # 1 шаг
#     numberOfBooks = 0  # 1 шаг
#     for book in books:  # n * 2 шага
#         print(book)  # 1 шаг
#         numberOfBooks += 1  # 1 шаг
#     print(numberOfBooks)  # 1 шаг
# ```
#
# Итого: 1 + 1 + 2n + 1 = 2n + 3 → O(n)
#
# ### «O-большое» как оценка худшего сценария
#
# - Описывает поведение при наименее благоприятных условиях
# - Существуют также Ω (Омега) для лучшего случая и Θ (Тэта) для среднего
#
# ## 5. Порядки сложности популярных операций Python
#
# ### Последовательности (списки, строки, кортежи)
#
# - `s[i]`, `s[i] = value` — O(1)
# - `s.append(value)` — O(1)
# - `s.insert(i, value)` — O(n)
# - `s.remove(value)` — O(n)
# - `s.reverse()` — O(n)
# - `s.sort()` — O(n log n)
# - `value in s` — O(n)
# - `len(s)` — O(1)
#
# ### Отображения (словари, множества)
#
# - `m[key]`, `m[key] = value` — O(1)
# - `m.add(value)` — O(1)
# - `value in m` — O(1)
# - `len(m)` — O(1)
#
# ## 6. Быстрый анализ сложности
#
# ### Общие правила
#
# - Нет обращения к данным → **O(1)**
# - Один цикл по данным → **O(n)**
# - Два вложенных цикла по данным → **O(n²)**
# - Операция "разделяй и властвуй" → **O(log n)**
# - Сортировка + обход → **O(n log n)**
# - Все комбинации → **O(2ⁿ)**
# - Все перестановки → **O(n!)**
#
# ## 7. Практические соображения
#
# ### Когда «O-большое» не важно
#
# - При малых значениях n (а они обычно малы)
# - "Хитроумные алгоритмы медленно работают при малых n" — Роб Пайк
# - Профилирование часто важнее теоретического анализа
#
# ### Ключевые принципы
#
# 1. **Сначала работоспособность, потом эффективность**
# 2. **Измеряйте, не предполагайте**
# 3. **Читаемость кода важна**
# 4. **Оптимизируйте узкие места, а не весь код**
